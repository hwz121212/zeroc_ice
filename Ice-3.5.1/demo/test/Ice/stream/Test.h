// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/BuiltinSequences.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class MyClass;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MyClass*);

class OptionalClass;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalClass>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalClass*);

class MyInterface;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MyInterface>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MyInterface*);

}

}

namespace Test
{

class MyClass;
bool operator==(const MyClass&, const MyClass&);
bool operator<(const MyClass&, const MyClass&);
::Ice::Object* upCast(::Test::MyClass*);
typedef ::IceInternal::Handle< ::Test::MyClass> MyClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass> MyClassPrx;
void __patch(MyClassPtr&, const ::Ice::ObjectPtr&);

class OptionalClass;
bool operator==(const OptionalClass&, const OptionalClass&);
bool operator<(const OptionalClass&, const OptionalClass&);
::Ice::Object* upCast(::Test::OptionalClass*);
typedef ::IceInternal::Handle< ::Test::OptionalClass> OptionalClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalClass> OptionalClassPrx;
void __patch(OptionalClassPtr&, const ::Ice::ObjectPtr&);

class MyInterface;
bool operator==(const MyInterface&, const MyInterface&);
bool operator<(const MyInterface&, const MyInterface&);
::Ice::Object* upCast(::Test::MyInterface*);
typedef ::IceInternal::Handle< ::Test::MyInterface> MyInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyInterface> MyInterfacePrx;
void __patch(MyInterfacePtr&, const ::Ice::ObjectPtr&);

}

namespace Test
{

enum MyEnum
{
    enum1,
    enum2,
    enum3
};

struct SmallStruct
{
    bool bo;
    ::Ice::Byte by;
    ::Ice::Short sh;
    ::Ice::Int i;
    ::Ice::Long l;
    ::Ice::Float f;
    ::Ice::Double d;
    ::std::string str;
    ::Test::MyEnum e;
    ::Test::MyClassPrx p;

    bool operator==(const SmallStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(bo != __rhs.bo)
        {
            return false;
        }
        if(by != __rhs.by)
        {
            return false;
        }
        if(sh != __rhs.sh)
        {
            return false;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        if(l != __rhs.l)
        {
            return false;
        }
        if(f != __rhs.f)
        {
            return false;
        }
        if(d != __rhs.d)
        {
            return false;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(e != __rhs.e)
        {
            return false;
        }
        if(p != __rhs.p)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SmallStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(bo < __rhs.bo)
        {
            return true;
        }
        else if(__rhs.bo < bo)
        {
            return false;
        }
        if(by < __rhs.by)
        {
            return true;
        }
        else if(__rhs.by < by)
        {
            return false;
        }
        if(sh < __rhs.sh)
        {
            return true;
        }
        else if(__rhs.sh < sh)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        if(l < __rhs.l)
        {
            return true;
        }
        else if(__rhs.l < l)
        {
            return false;
        }
        if(f < __rhs.f)
        {
            return true;
        }
        else if(__rhs.f < f)
        {
            return false;
        }
        if(d < __rhs.d)
        {
            return true;
        }
        else if(__rhs.d < d)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(e < __rhs.e)
        {
            return true;
        }
        else if(__rhs.e < e)
        {
            return false;
        }
        if(p < __rhs.p)
        {
            return true;
        }
        else if(__rhs.p < p)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SmallStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const SmallStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const SmallStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const SmallStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

class ClassStruct : public IceUtil::Shared
{
public:
    
    ClassStruct() {}
    explicit ClassStruct(::Ice::Int __ice_i) :
        i(__ice_i)
    {
    }
    

    ::Ice::Int i;

    bool operator==(const ClassStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ClassStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ClassStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ClassStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::IceUtil::Handle< ::Test::ClassStruct> ClassStructPtr;

typedef ::std::vector< ::Test::MyEnum> MyEnumS;

typedef ::std::vector< ::Test::SmallStruct> SmallStructS;

typedef ::std::vector< ::Test::MyClassPtr> MyClassS;

typedef ::std::vector< ::Ice::BoolSeq> BoolSS;

typedef ::std::vector< ::Ice::ByteSeq> ByteSS;

typedef ::std::vector< ::Ice::ShortSeq> ShortSS;

typedef ::std::vector< ::Ice::IntSeq> IntSS;

typedef ::std::vector< ::Ice::LongSeq> LongSS;

typedef ::std::vector< ::Ice::FloatSeq> FloatSS;

typedef ::std::vector< ::Ice::DoubleSeq> DoubleSS;

typedef ::std::vector< ::Ice::StringSeq> StringSS;

typedef ::std::vector< ::Test::MyEnumS> MyEnumSS;

typedef ::std::vector< ::Test::SmallStructS> SmallStructSS;

typedef ::std::vector< ::Test::MyClassS> MyClassSS;

typedef ::std::map< ::Ice::Byte, bool> ByteBoolD;

typedef ::std::map< ::Ice::Short, ::Ice::Int> ShortIntD;

typedef ::std::map< ::Ice::Long, ::Ice::Float> LongFloatD;

typedef ::std::map< ::std::string, ::std::string> StringStringD;

typedef ::std::map< ::std::string, ::Test::MyClassPtr> StringMyClassD;

class MyException : public ::Ice::UserException
{
public:

    MyException() {}
    explicit MyException(const ::Test::MyClassPtr&);
    virtual ~MyException() throw();

    virtual ::std::string ice_name() const;
    virtual MyException* ice_clone() const;
    virtual void ice_throw() const;

    virtual bool __usesClasses() const;

    ::Test::MyClassPtr c;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    virtual void __writeImpl(const ::Ice::OutputStreamPtr&) const;
    virtual void __readImpl(const ::Ice::InputStreamPtr&);
};

static MyException __MyException_init;

namespace Sub
{

enum NestedEnum
{
    nestedEnum1,
    nestedEnum2,
    nestedEnum3
};

struct NestedStruct
{
    bool bo;
    ::Ice::Byte by;
    ::Ice::Short sh;
    ::Ice::Int i;
    ::Ice::Long l;
    ::Ice::Float f;
    ::Ice::Double d;
    ::std::string str;
    ::Test::Sub::NestedEnum e;

    bool operator==(const NestedStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(bo != __rhs.bo)
        {
            return false;
        }
        if(by != __rhs.by)
        {
            return false;
        }
        if(sh != __rhs.sh)
        {
            return false;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        if(l != __rhs.l)
        {
            return false;
        }
        if(f != __rhs.f)
        {
            return false;
        }
        if(d != __rhs.d)
        {
            return false;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(e != __rhs.e)
        {
            return false;
        }
        return true;
    }

    bool operator<(const NestedStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(bo < __rhs.bo)
        {
            return true;
        }
        else if(__rhs.bo < bo)
        {
            return false;
        }
        if(by < __rhs.by)
        {
            return true;
        }
        else if(__rhs.by < by)
        {
            return false;
        }
        if(sh < __rhs.sh)
        {
            return true;
        }
        else if(__rhs.sh < sh)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        if(l < __rhs.l)
        {
            return true;
        }
        else if(__rhs.l < l)
        {
            return false;
        }
        if(f < __rhs.f)
        {
            return true;
        }
        else if(__rhs.f < f)
        {
            return false;
        }
        if(d < __rhs.d)
        {
            return true;
        }
        else if(__rhs.d < d)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(e < __rhs.e)
        {
            return true;
        }
        else if(__rhs.e < e)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const NestedStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const NestedStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const NestedStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const NestedStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

class NestedClassStruct : public IceUtil::Shared
{
public:
    
    NestedClassStruct() {}
    explicit NestedClassStruct(::Ice::Int __ice_i) :
        i(__ice_i)
    {
    }
    

    ::Ice::Int i;

    bool operator==(const NestedClassStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        return true;
    }

    bool operator<(const NestedClassStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const NestedClassStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const NestedClassStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const NestedClassStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const NestedClassStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::IceUtil::Handle< ::Test::Sub::NestedClassStruct> NestedClassStructPtr;

class NestedException : public ::Ice::UserException
{
public:

    NestedException() {}
    explicit NestedException(const ::std::string&);
    virtual ~NestedException() throw();

    virtual ::std::string ice_name() const;
    virtual NestedException* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string str;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    virtual void __writeImpl(const ::Ice::OutputStreamPtr&) const;
    virtual void __readImpl(const ::Ice::InputStreamPtr&);
};

}

}

namespace Test2
{

namespace Sub2
{

enum NestedEnum2
{
    nestedEnum4,
    nestedEnum5,
    nestedEnum6
};

struct NestedStruct2
{
    bool bo;
    ::Ice::Byte by;
    ::Ice::Short sh;
    ::Ice::Int i;
    ::Ice::Long l;
    ::Ice::Float f;
    ::Ice::Double d;
    ::std::string str;
    ::Test2::Sub2::NestedEnum2 e;

    bool operator==(const NestedStruct2& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(bo != __rhs.bo)
        {
            return false;
        }
        if(by != __rhs.by)
        {
            return false;
        }
        if(sh != __rhs.sh)
        {
            return false;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        if(l != __rhs.l)
        {
            return false;
        }
        if(f != __rhs.f)
        {
            return false;
        }
        if(d != __rhs.d)
        {
            return false;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(e != __rhs.e)
        {
            return false;
        }
        return true;
    }

    bool operator<(const NestedStruct2& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(bo < __rhs.bo)
        {
            return true;
        }
        else if(__rhs.bo < bo)
        {
            return false;
        }
        if(by < __rhs.by)
        {
            return true;
        }
        else if(__rhs.by < by)
        {
            return false;
        }
        if(sh < __rhs.sh)
        {
            return true;
        }
        else if(__rhs.sh < sh)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        if(l < __rhs.l)
        {
            return true;
        }
        else if(__rhs.l < l)
        {
            return false;
        }
        if(f < __rhs.f)
        {
            return true;
        }
        else if(__rhs.f < f)
        {
            return false;
        }
        if(d < __rhs.d)
        {
            return true;
        }
        else if(__rhs.d < d)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(e < __rhs.e)
        {
            return true;
        }
        else if(__rhs.e < e)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const NestedStruct2& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const NestedStruct2& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const NestedStruct2& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const NestedStruct2& __rhs) const
    {
        return !operator<(__rhs);
    }
};

class NestedClassStruct2 : public IceUtil::Shared
{
public:
    
    NestedClassStruct2() {}
    explicit NestedClassStruct2(::Ice::Int __ice_i) :
        i(__ice_i)
    {
    }
    

    ::Ice::Int i;

    bool operator==(const NestedClassStruct2& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        return true;
    }

    bool operator<(const NestedClassStruct2& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const NestedClassStruct2& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const NestedClassStruct2& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const NestedClassStruct2& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const NestedClassStruct2& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::IceUtil::Handle< ::Test2::Sub2::NestedClassStruct2> NestedClassStruct2Ptr;

class NestedException2 : public ::Ice::UserException
{
public:

    NestedException2() {}
    explicit NestedException2(const ::std::string&);
    virtual ~NestedException2() throw();

    virtual ::std::string ice_name() const;
    virtual NestedException2* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string str;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    virtual void __writeImpl(const ::Ice::OutputStreamPtr&) const;
    virtual void __readImpl(const ::Ice::InputStreamPtr&);
};

}

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::SmallStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 32;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::SmallStruct, S>
{
    static void write(S* __os, const ::Test::SmallStruct& v)
    {
        __os->write(v.bo);
        __os->write(v.by);
        __os->write(v.sh);
        __os->write(v.i);
        __os->write(v.l);
        __os->write(v.f);
        __os->write(v.d);
        __os->write(v.str);
        __os->write(v.e);
        __os->write(v.p);
    }
};

template<class S>
struct StreamReader< ::Test::SmallStruct, S>
{
    static void read(S* __is, ::Test::SmallStruct& v)
    {
        __is->read(v.bo);
        __is->read(v.by);
        __is->read(v.sh);
        __is->read(v.i);
        __is->read(v.l);
        __is->read(v.f);
        __is->read(v.d);
        __is->read(v.str);
        __is->read(v.e);
        __is->read(v.p);
    }
};

template<>
struct StreamableTraits< ::Test::ClassStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::ClassStructPtr, S>
{
    static void write(S* __os, const ::Test::ClassStructPtr& v)
    {
        __os->write(v->i);
    }
};

template<class S>
struct StreamReader< ::Test::ClassStructPtr, S>
{
    static void read(S* __is, ::Test::ClassStructPtr& v)
    {
        __is->read(v->i);
    }
};

template<>
struct StreamableTraits< ::Test::MyException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::Sub::NestedEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Sub::NestedStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 30;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Sub::NestedStruct, S>
{
    static void write(S* __os, const ::Test::Sub::NestedStruct& v)
    {
        __os->write(v.bo);
        __os->write(v.by);
        __os->write(v.sh);
        __os->write(v.i);
        __os->write(v.l);
        __os->write(v.f);
        __os->write(v.d);
        __os->write(v.str);
        __os->write(v.e);
    }
};

template<class S>
struct StreamReader< ::Test::Sub::NestedStruct, S>
{
    static void read(S* __is, ::Test::Sub::NestedStruct& v)
    {
        __is->read(v.bo);
        __is->read(v.by);
        __is->read(v.sh);
        __is->read(v.i);
        __is->read(v.l);
        __is->read(v.f);
        __is->read(v.d);
        __is->read(v.str);
        __is->read(v.e);
    }
};

template<>
struct StreamableTraits< ::Test::Sub::NestedClassStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::Sub::NestedClassStructPtr, S>
{
    static void write(S* __os, const ::Test::Sub::NestedClassStructPtr& v)
    {
        __os->write(v->i);
    }
};

template<class S>
struct StreamReader< ::Test::Sub::NestedClassStructPtr, S>
{
    static void read(S* __is, ::Test::Sub::NestedClassStructPtr& v)
    {
        __is->read(v->i);
    }
};

template<>
struct StreamableTraits< ::Test::Sub::NestedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test2::Sub2::NestedEnum2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test2::Sub2::NestedStruct2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 30;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test2::Sub2::NestedStruct2, S>
{
    static void write(S* __os, const ::Test2::Sub2::NestedStruct2& v)
    {
        __os->write(v.bo);
        __os->write(v.by);
        __os->write(v.sh);
        __os->write(v.i);
        __os->write(v.l);
        __os->write(v.f);
        __os->write(v.d);
        __os->write(v.str);
        __os->write(v.e);
    }
};

template<class S>
struct StreamReader< ::Test2::Sub2::NestedStruct2, S>
{
    static void read(S* __is, ::Test2::Sub2::NestedStruct2& v)
    {
        __is->read(v.bo);
        __is->read(v.by);
        __is->read(v.sh);
        __is->read(v.i);
        __is->read(v.l);
        __is->read(v.f);
        __is->read(v.d);
        __is->read(v.str);
        __is->read(v.e);
    }
};

template<>
struct StreamableTraits< ::Test2::Sub2::NestedClassStruct2Ptr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test2::Sub2::NestedClassStruct2Ptr, S>
{
    static void write(S* __os, const ::Test2::Sub2::NestedClassStruct2Ptr& v)
    {
        __os->write(v->i);
    }
};

template<class S>
struct StreamReader< ::Test2::Sub2::NestedClassStruct2Ptr, S>
{
    static void read(S* __is, ::Test2::Sub2::NestedClassStruct2Ptr& v)
    {
        __is->read(v->i);
    }
};

template<>
struct StreamableTraits< ::Test2::Sub2::NestedException2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Test
{

}

namespace IceProxy
{

namespace Test
{

class OptionalClass : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_twoway() const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_oneway() const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_batchOneway() const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_datagram() const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalClass> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalClass*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MyClass : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<MyClass> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_secure(bool __secure) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_twoway() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_oneway() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_batchOneway() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_datagram() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_batchDatagram() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_compress(bool __compress) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MyInterface : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<MyInterface> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_secure(bool __secure) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_twoway() const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_oneway() const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_batchOneway() const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_datagram() const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_batchDatagram() const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_compress(bool __compress) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyInterface> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MyInterface*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Test
{

class OptionalClass : virtual public ::IceDelegate::Ice::Object
{
public:
};

class MyClass : virtual public ::IceDelegate::Ice::Object
{
public:
};

class MyInterface : virtual public ::IceDelegate::Ice::Object
{
public:
};

}

}

namespace IceDelegateM
{

namespace Test
{

class OptionalClass : virtual public ::IceDelegate::Test::OptionalClass,
                      virtual public ::IceDelegateM::Ice::Object
{
public:
};

class MyClass : virtual public ::IceDelegate::Test::MyClass,
                virtual public ::IceDelegateM::Ice::Object
{
public:
};

class MyInterface : virtual public ::IceDelegate::Test::MyInterface,
                    virtual public ::IceDelegateM::Ice::Object
{
public:
};

}

}

namespace IceDelegateD
{

namespace Test
{

class OptionalClass : virtual public ::IceDelegate::Test::OptionalClass,
                      virtual public ::IceDelegateD::Ice::Object
{
public:
};

class MyClass : virtual public ::IceDelegate::Test::MyClass,
                virtual public ::IceDelegateD::Ice::Object
{
public:
};

class MyInterface : virtual public ::IceDelegate::Test::MyInterface,
                    virtual public ::IceDelegateD::Ice::Object
{
public:
};

}

}

namespace Test
{

class OptionalClass : virtual public ::Ice::Object
{
public:

    typedef OptionalClassPrx ProxyType;
    typedef OptionalClassPtr PointerType;

    OptionalClass()
    {
    }

    OptionalClass(bool __ice_bo, ::Ice::Byte __ice_by, const IceUtil::Optional< ::Ice::Short>& __ice_sh, const IceUtil::Optional< ::Ice::Int>& __ice_i) :
        bo(__ice_bo),
        by(__ice_by),
        sh(__ice_sh),
        i(__ice_i)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    virtual void __writeImpl(const ::Ice::OutputStreamPtr&) const;
    virtual void __readImpl(const ::Ice::InputStreamPtr&);

public:

    bool bo;

    ::Ice::Byte by;

    IceUtil::Optional< ::Ice::Short> sh;

    IceUtil::Optional< ::Ice::Int> i;

protected:

    virtual ~OptionalClass() {}

    friend class OptionalClass__staticInit;
};

class OptionalClass__staticInit
{
public:

    ::Test::OptionalClass _init;
};

static OptionalClass__staticInit _OptionalClass_init;

inline bool operator==(const OptionalClass& l, const OptionalClass& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalClass& l, const OptionalClass& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MyClass : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef MyClassPrx ProxyType;
    typedef MyClassPtr PointerType;

    MyClass()
    {
    }

    MyClass(const ::Test::MyClassPtr& __ice_c, const ::Ice::ObjectPtr& __ice_o, const ::Test::SmallStruct& __ice_s, const ::Ice::BoolSeq& __ice_seq1, const ::Ice::ByteSeq& __ice_seq2, const ::Ice::ShortSeq& __ice_seq3, const ::Ice::IntSeq& __ice_seq4, const ::Ice::LongSeq& __ice_seq5, const ::Ice::FloatSeq& __ice_seq6, const ::Ice::DoubleSeq& __ice_seq7, const ::Ice::StringSeq& __ice_seq8, const ::Test::MyEnumS& __ice_seq9, const ::Test::MyClassS& __ice_seq10, const ::Test::StringMyClassD& __ice_d) :
        c(__ice_c),
        o(__ice_o),
        s(__ice_s),
        seq1(__ice_seq1),
        seq2(__ice_seq2),
        seq3(__ice_seq3),
        seq4(__ice_seq4),
        seq5(__ice_seq5),
        seq6(__ice_seq6),
        seq7(__ice_seq7),
        seq8(__ice_seq8),
        seq9(__ice_seq9),
        seq10(__ice_seq10),
        d(__ice_d)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    virtual void __writeImpl(const ::Ice::OutputStreamPtr&) const;
    virtual void __readImpl(const ::Ice::InputStreamPtr&);

public:

    ::Test::MyClassPtr c;

    ::Ice::ObjectPtr o;

    ::Test::SmallStruct s;

    ::Ice::BoolSeq seq1;

    ::Ice::ByteSeq seq2;

    ::Ice::ShortSeq seq3;

    ::Ice::IntSeq seq4;

    ::Ice::LongSeq seq5;

    ::Ice::FloatSeq seq6;

    ::Ice::DoubleSeq seq7;

    ::Ice::StringSeq seq8;

    ::Test::MyEnumS seq9;

    ::Test::MyClassS seq10;

    ::Test::StringMyClassD d;

protected:

    virtual ~MyClass() {}
};

inline bool operator==(const MyClass& l, const MyClass& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MyClass& l, const MyClass& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MyInterface : virtual public ::Ice::Object
{
public:

    typedef MyInterfacePrx ProxyType;
    typedef MyInterfacePtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    virtual void __writeImpl(const ::Ice::OutputStreamPtr&) const;
    virtual void __readImpl(const ::Ice::InputStreamPtr&);
};

inline bool operator==(const MyInterface& l, const MyInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MyInterface& l, const MyInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Test
{

}

#endif
