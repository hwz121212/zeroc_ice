// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Test.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

namespace
{

}

namespace
{

}

namespace
{

}

namespace
{

}

namespace
{

const ::std::string __Test__DDD__I__op_name = "op";

const ::std::string __Test__DDD__C__op_name = "op";

}

}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::C* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::C>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::C;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::C::ice_staticId()
{
    return ::Test::C::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::C::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::C);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::C::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::C);
}

::IceProxy::Ice::Object*
IceProxy::Test::C::__newInstance() const
{
    return new C;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::C2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::C2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::C2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::C2::ice_staticId()
{
    return ::Test::C2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::C2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::C2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::C2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::C2);
}

::IceProxy::Ice::Object*
IceProxy::Test::C2::__newInstance() const
{
    return new C2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Leaf* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Leaf>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Leaf;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Leaf::ice_staticId()
{
    return ::Test::Leaf::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Leaf::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Leaf);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Leaf::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Leaf);
}

::IceProxy::Ice::Object*
IceProxy::Test::Leaf::__newInstance() const
{
    return new Leaf;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Node* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Node>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Node;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Node::ice_staticId()
{
    return ::Test::Node::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Node::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Node);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Node::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Node);
}

::IceProxy::Ice::Object*
IceProxy::Test::Node::__newInstance() const
{
    return new Node;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::CTest* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::CTest>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::CTest;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::CTest::ice_staticId()
{
    return ::Test::CTest::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::CTest::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::CTest);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::CTest::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::CTest);
}

::IceProxy::Ice::Object*
IceProxy::Test::CTest::__newInstance() const
{
    return new CTest;
}
::IceProxy::Ice::Object* ::IceProxy::Test::AAA::upCast(::IceProxy::Test::AAA::C* p) { return p; }

void
::IceProxy::Test::AAA::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::C>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::AAA::C;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::AAA::C::ice_staticId()
{
    return ::Test::AAA::C::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::AAA::C::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::AAA::C);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::AAA::C::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::AAA::C);
}

::IceProxy::Ice::Object*
IceProxy::Test::AAA::C::__newInstance() const
{
    return new C;
}
::IceProxy::Ice::Object* ::IceProxy::Test::AAA::upCast(::IceProxy::Test::AAA::B* p) { return p; }

void
::IceProxy::Test::AAA::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::B>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::AAA::B;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::AAA::B::ice_staticId()
{
    return ::Test::AAA::B::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::AAA::B::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::AAA::B);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::AAA::B::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::AAA::B);
}

::IceProxy::Ice::Object*
IceProxy::Test::AAA::B::__newInstance() const
{
    return new B;
}
::IceProxy::Ice::Object* ::IceProxy::Test::CCC::upCast(::IceProxy::Test::CCC::Forward* p) { return p; }

void
::IceProxy::Test::CCC::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::CCC::Forward>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::CCC::Forward;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::CCC::Forward::ice_staticId()
{
    return ::Test::CCC::Forward::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::CCC::Forward::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::CCC::Forward);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::CCC::Forward::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::CCC::Forward);
}

::IceProxy::Ice::Object*
IceProxy::Test::CCC::Forward::__newInstance() const
{
    return new Forward;
}
::IceProxy::Ice::Object* ::IceProxy::Test::DDD::upCast(::IceProxy::Test::DDD::I* p) { return p; }

void
::IceProxy::Test::DDD::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::I>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::DDD::I;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::DDD::I::op(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__DDD__I__op_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::DDD::I* __del = dynamic_cast< ::IceDelegate::Test::DDD::I*>(__delBase.get());
            __del->op(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::DDD::I::begin_op(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__DDD__I__op_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__DDD__I__op_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::DDD::I::end_op(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__DDD__I__op_name);
}

const ::std::string&
IceProxy::Test::DDD::I::ice_staticId()
{
    return ::Test::DDD::I::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::DDD::I::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::DDD::I);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::DDD::I::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::DDD::I);
}

::IceProxy::Ice::Object*
IceProxy::Test::DDD::I::__newInstance() const
{
    return new I;
}
::IceProxy::Ice::Object* ::IceProxy::Test::DDD::upCast(::IceProxy::Test::DDD::C* p) { return p; }

void
::IceProxy::Test::DDD::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::DDD::C;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::DDD::C::op(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__DDD__C__op_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::DDD::C* __del = dynamic_cast< ::IceDelegate::Test::DDD::C*>(__delBase.get());
            __del->op(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::DDD::C::begin_op(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__DDD__C__op_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__DDD__C__op_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::DDD::C::end_op(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__DDD__C__op_name);
}

const ::std::string&
IceProxy::Test::DDD::C::ice_staticId()
{
    return ::Test::DDD::C::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::DDD::C::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::DDD::C);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::DDD::C::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::DDD::C);
}

::IceProxy::Ice::Object*
IceProxy::Test::DDD::C::__newInstance() const
{
    return new C;
}
::IceProxy::Ice::Object* ::IceProxy::Test::DDD::upCast(::IceProxy::Test::DDD::U* p) { return p; }

void
::IceProxy::Test::DDD::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::U>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::DDD::U;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::DDD::U::ice_staticId()
{
    return ::Test::DDD::U::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::DDD::U::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::DDD::U);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::DDD::U::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::DDD::U);
}

::IceProxy::Ice::Object*
IceProxy::Test::DDD::U::__newInstance() const
{
    return new U;
}
::IceProxy::Ice::Object* ::IceProxy::Test::DDD::upCast(::IceProxy::Test::DDD::C2* p) { return p; }

void
::IceProxy::Test::DDD::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::DDD::C2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::DDD::C2::ice_staticId()
{
    return ::Test::DDD::C2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::DDD::C2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::DDD::C2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::DDD::C2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::DDD::C2);
}

::IceProxy::Ice::Object*
IceProxy::Test::DDD::C2::__newInstance() const
{
    return new C2;
}

void
IceDelegateM::Test::DDD::I::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__DDD__I__op_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::DDD::C::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__DDD__C__op_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateD::Test::DDD::I::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::DDD::I* servant = dynamic_cast< ::Test::DDD::I*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__DDD__I__op_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::DDD::C::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::DDD::C* servant = dynamic_cast< ::Test::DDD::C*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__DDD__C__op_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Object* Test::upCast(::Test::C* p) { return p; }
::Ice::ObjectPtr
Test::C::ice_clone() const
{
    ::Ice::Object* __p = new C(*this);
    return __p;
}

namespace
{
const ::std::string __Test__C_ids[2] =
{
    "::Ice::Object",
    "::Test::C"
};

}

bool
Test::C::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__C_ids, __Test__C_ids + 2, _s);
}

::std::vector< ::std::string>
Test::C::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__C_ids[0], &__Test__C_ids[2]);
}

const ::std::string&
Test::C::ice_id(const ::Ice::Current&) const
{
    return __Test__C_ids[1];
}

const ::std::string&
Test::C::ice_staticId()
{
    return __Test__C_ids[1];
}

void
Test::C::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::C::__usesGC()
{
    return true;
}

void
Test::C::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(left)
    {
        ::Test::upCast(left.get())->__addObject(_c);
    }
    if(right)
    {
        ::Test::upCast(right.get())->__addObject(_c);
    }
}

void
Test::C::__gcClear()
{
    if(left)
    {
        if(::Test::upCast(left.get())->__usesGC())
        {
            ::Test::upCast(left.get())->__decRefUnsafe();
            left.__clearHandleUnsafe();
        }
        else
        {
            left = 0;
        }
    }
    if(right)
    {
        if(::Test::upCast(right.get())->__usesGC())
        {
            ::Test::upCast(right.get())->__decRefUnsafe();
            right.__clearHandleUnsafe();
        }
        else
        {
            right = 0;
        }
    }
}

void
Test::C::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(left);
    __os->write(right);
    __os->endWriteSlice();
}

void
Test::C::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(left);
    __is->read(right);
    __is->endReadSlice();
}

namespace
{

class __F__Test__C : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::C::ice_staticId());
        return new ::Test::C;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__C_Ptr = new __F__Test__C;

class __F__Test__C__Init
{
public:

    __F__Test__C__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::C::ice_staticId(), __F__Test__C_Ptr);
    }

    ~__F__Test__C__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::C::ice_staticId());
    }
};

const __F__Test__C__Init __F__Test__C__i;

}

const ::Ice::ObjectFactoryPtr&
Test::C::ice_factory()
{
    return __F__Test__C_Ptr;
}

void 
Test::__patch(CPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::CPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::C::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::C2* p) { return p; }
::Ice::ObjectPtr
Test::C2::ice_clone() const
{
    ::Ice::Object* __p = new C2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__C2_ids[2] =
{
    "::Ice::Object",
    "::Test::C2"
};

}

bool
Test::C2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__C2_ids, __Test__C2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::C2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__C2_ids[0], &__Test__C2_ids[2]);
}

const ::std::string&
Test::C2::ice_id(const ::Ice::Current&) const
{
    return __Test__C2_ids[1];
}

const ::std::string&
Test::C2::ice_staticId()
{
    return __Test__C2_ids[1];
}

void
Test::C2::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::C2::__usesGC()
{
    return true;
}

void
Test::C2::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::Test::S2Seq::const_iterator _i0 = theS2Seq.begin(); _i0 != theS2Seq.end(); ++_i0)
        {
            {
                for(::Test::C2Dict::const_iterator _i2 = (*_i0).theC2Dict.begin(); _i2 != (*_i0).theC2Dict.end(); ++_i2)
                {
                    if((*_i2).second)
                    {
                        ::Test::upCast((*_i2).second.get())->__addObject(_c);
                    }
                }
            }
        }
    }
}

void
Test::C2::__gcClear()
{
    {
        for(::Test::S2Seq::iterator _i0 = theS2Seq.begin(); _i0 != theS2Seq.end(); ++_i0)
        {
            {
                for(::Test::C2Dict::iterator _i2 = (*_i0).theC2Dict.begin(); _i2 != (*_i0).theC2Dict.end(); ++_i2)
                {
                    if((*_i2).second)
                    {
                        if(::Test::upCast((*_i2).second.get())->__usesGC())
                        {
                            ::Test::upCast((*_i2).second.get())->__decRefUnsafe();
                            (*_i2).second.__clearHandleUnsafe();
                        }
                        else
                        {
                            (*_i2).second = 0;
                        }
                    }
                }
            }
        }
    }
}

void
Test::C2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(theS2Seq);
    __os->endWriteSlice();
}

void
Test::C2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(theS2Seq);
    __is->endReadSlice();
}

namespace
{

class __F__Test__C2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::C2::ice_staticId());
        return new ::Test::C2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__C2_Ptr = new __F__Test__C2;

class __F__Test__C2__Init
{
public:

    __F__Test__C2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::C2::ice_staticId(), __F__Test__C2_Ptr);
    }

    ~__F__Test__C2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::C2::ice_staticId());
    }
};

const __F__Test__C2__Init __F__Test__C2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::C2::ice_factory()
{
    return __F__Test__C2_Ptr;
}

void 
Test::__patch(C2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::C2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::C2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Leaf* p) { return p; }
::Ice::ObjectPtr
Test::Leaf::ice_clone() const
{
    ::Ice::Object* __p = new Leaf(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Leaf_ids[2] =
{
    "::Ice::Object",
    "::Test::Leaf"
};

}

bool
Test::Leaf::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Leaf_ids, __Test__Leaf_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Leaf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Leaf_ids[0], &__Test__Leaf_ids[2]);
}

const ::std::string&
Test::Leaf::ice_id(const ::Ice::Current&) const
{
    return __Test__Leaf_ids[1];
}

const ::std::string&
Test::Leaf::ice_staticId()
{
    return __Test__Leaf_ids[1];
}

void
Test::Leaf::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(i);
    __os->endWriteSlice();
}

void
Test::Leaf::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(i);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Leaf : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Leaf::ice_staticId());
        return new ::Test::Leaf;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Leaf_Ptr = new __F__Test__Leaf;

class __F__Test__Leaf__Init
{
public:

    __F__Test__Leaf__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Leaf::ice_staticId(), __F__Test__Leaf_Ptr);
    }

    ~__F__Test__Leaf__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Leaf::ice_staticId());
    }
};

const __F__Test__Leaf__Init __F__Test__Leaf__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Leaf::ice_factory()
{
    return __F__Test__Leaf_Ptr;
}

void 
Test::__patch(LeafPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::LeafPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Leaf::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Node* p) { return p; }
::Ice::ObjectPtr
Test::Node::ice_clone() const
{
    ::Ice::Object* __p = new Node(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Node_ids[2] =
{
    "::Ice::Object",
    "::Test::Node"
};

}

bool
Test::Node::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Node_ids, __Test__Node_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Node::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Node_ids[0], &__Test__Node_ids[2]);
}

const ::std::string&
Test::Node::ice_id(const ::Ice::Current&) const
{
    return __Test__Node_ids[1];
}

const ::std::string&
Test::Node::ice_staticId()
{
    return __Test__Node_ids[1];
}

void
Test::Node::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::Node::__usesGC()
{
    return true;
}

void
Test::Node::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(l)
    {
        ::Test::upCast(l.get())->__addObject(_c);
    }
    if(n)
    {
        ::Test::upCast(n.get())->__addObject(_c);
    }
}

void
Test::Node::__gcClear()
{
    if(l)
    {
        if(::Test::upCast(l.get())->__usesGC())
        {
            ::Test::upCast(l.get())->__decRefUnsafe();
            l.__clearHandleUnsafe();
        }
        else
        {
            l = 0;
        }
    }
    if(n)
    {
        if(::Test::upCast(n.get())->__usesGC())
        {
            ::Test::upCast(n.get())->__decRefUnsafe();
            n.__clearHandleUnsafe();
        }
        else
        {
            n = 0;
        }
    }
}

void
Test::Node::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(l);
    __os->write(n);
    __os->endWriteSlice();
}

void
Test::Node::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(l);
    __is->read(n);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Node : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Node::ice_staticId());
        return new ::Test::Node;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Node_Ptr = new __F__Test__Node;

class __F__Test__Node__Init
{
public:

    __F__Test__Node__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Node::ice_staticId(), __F__Test__Node_Ptr);
    }

    ~__F__Test__Node__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Node::ice_staticId());
    }
};

const __F__Test__Node__Init __F__Test__Node__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Node::ice_factory()
{
    return __F__Test__Node_Ptr;
}

void 
Test::__patch(NodePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::NodePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Node::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::CTest* p) { return p; }
::Ice::ObjectPtr
Test::CTest::ice_clone() const
{
    ::Ice::Object* __p = new CTest(*this);
    return __p;
}

namespace
{
const ::std::string __Test__CTest_ids[2] =
{
    "::Ice::Object",
    "::Test::CTest"
};

}

bool
Test::CTest::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__CTest_ids, __Test__CTest_ids + 2, _s);
}

::std::vector< ::std::string>
Test::CTest::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__CTest_ids[0], &__Test__CTest_ids[2]);
}

const ::std::string&
Test::CTest::ice_id(const ::Ice::Current&) const
{
    return __Test__CTest_ids[1];
}

const ::std::string&
Test::CTest::ice_staticId()
{
    return __Test__CTest_ids[1];
}

void
Test::CTest::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::CTest::__usesGC()
{
    return true;
}

void
Test::CTest::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::Test::CSeq::const_iterator _i0 = theCSeq.begin(); _i0 != theCSeq.end(); ++_i0)
        {
            if((*_i0))
            {
                ::Test::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
    {
        for(::Test::SSeq::const_iterator _i0 = theSSeq.begin(); _i0 != theSSeq.end(); ++_i0)
        {
            if((*_i0).theC)
            {
                ::Test::upCast((*_i0).theC.get())->__addObject(_c);
            }
        }
    }
    {
        for(::Test::C2DictSeq::const_iterator _i0 = theC2DictSeq.begin(); _i0 != theC2DictSeq.end(); ++_i0)
        {
            {
                for(::Test::C2Dict::const_iterator _i1 = (*_i0).begin(); _i1 != (*_i0).end(); ++_i1)
                {
                    if((*_i1).second)
                    {
                        ::Test::upCast((*_i1).second.get())->__addObject(_c);
                    }
                }
            }
        }
    }
    {
        for(::Test::CSeqSeq::const_iterator _i0 = theCSeqSeq.begin(); _i0 != theCSeqSeq.end(); ++_i0)
        {
            {
                for(::Test::CSeq::const_iterator _i1 = (*_i0).begin(); _i1 != (*_i0).end(); ++_i1)
                {
                    if((*_i1))
                    {
                        ::Test::upCast((*_i1).get())->__addObject(_c);
                    }
                }
            }
        }
    }
    if(theS.theC)
    {
        ::Test::upCast(theS.theC.get())->__addObject(_c);
    }
    {
        for(::Test::SSeq::const_iterator _i1 = theA.theSSeq.begin(); _i1 != theA.theSSeq.end(); ++_i1)
        {
            if((*_i1).theC)
            {
                ::Test::upCast((*_i1).theC.get())->__addObject(_c);
            }
        }
    }
    {
        for(::Test::C2Dict::const_iterator _i1 = theS2.theC2Dict.begin(); _i1 != theS2.theC2Dict.end(); ++_i1)
        {
            if((*_i1).second)
            {
                ::Test::upCast((*_i1).second.get())->__addObject(_c);
            }
        }
    }
    if(theB.theS.theC)
    {
        ::Test::upCast(theB.theS.theC.get())->__addObject(_c);
    }
    {
        for(::Test::CDict::const_iterator _i0 = theCDict.begin(); _i0 != theCDict.end(); ++_i0)
        {
            if((*_i0).second)
            {
                ::Test::upCast((*_i0).second.get())->__addObject(_c);
            }
        }
    }
    {
        for(::Test::CSeqDict::const_iterator _i0 = theCSeqDict.begin(); _i0 != theCSeqDict.end(); ++_i0)
        {
            {
                for(::Test::CSeq::const_iterator _i1 = (*_i0).second.begin(); _i1 != (*_i0).second.end(); ++_i1)
                {
                    if((*_i1))
                    {
                        ::Test::upCast((*_i1).get())->__addObject(_c);
                    }
                }
            }
        }
    }
    {
        for(::Test::SDict::const_iterator _i0 = theSDict.begin(); _i0 != theSDict.end(); ++_i0)
        {
            if((*_i0).second.theC)
            {
                ::Test::upCast((*_i0).second.theC.get())->__addObject(_c);
            }
        }
    }
    {
        for(::Test::CDictDict::const_iterator _i0 = theCDictDict.begin(); _i0 != theCDictDict.end(); ++_i0)
        {
            {
                for(::Test::CDict::const_iterator _i1 = (*_i0).second.begin(); _i1 != (*_i0).second.end(); ++_i1)
                {
                    if((*_i1).second)
                    {
                        ::Test::upCast((*_i1).second.get())->__addObject(_c);
                    }
                }
            }
        }
    }
}

void
Test::CTest::__gcClear()
{
    {
        for(::Test::CSeq::iterator _i0 = theCSeq.begin(); _i0 != theCSeq.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::Test::upCast((*_i0).get())->__usesGC())
                {
                    ::Test::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
    {
        for(::Test::SSeq::iterator _i0 = theSSeq.begin(); _i0 != theSSeq.end(); ++_i0)
        {
            if((*_i0).theC)
            {
                if(::Test::upCast((*_i0).theC.get())->__usesGC())
                {
                    ::Test::upCast((*_i0).theC.get())->__decRefUnsafe();
                    (*_i0).theC.__clearHandleUnsafe();
                }
                else
                {
                    (*_i0).theC = 0;
                }
            }
        }
    }
    {
        for(::Test::C2DictSeq::iterator _i0 = theC2DictSeq.begin(); _i0 != theC2DictSeq.end(); ++_i0)
        {
            {
                for(::Test::C2Dict::iterator _i1 = (*_i0).begin(); _i1 != (*_i0).end(); ++_i1)
                {
                    if((*_i1).second)
                    {
                        if(::Test::upCast((*_i1).second.get())->__usesGC())
                        {
                            ::Test::upCast((*_i1).second.get())->__decRefUnsafe();
                            (*_i1).second.__clearHandleUnsafe();
                        }
                        else
                        {
                            (*_i1).second = 0;
                        }
                    }
                }
            }
        }
    }
    {
        for(::Test::CSeqSeq::iterator _i0 = theCSeqSeq.begin(); _i0 != theCSeqSeq.end(); ++_i0)
        {
            {
                for(::Test::CSeq::iterator _i1 = (*_i0).begin(); _i1 != (*_i0).end(); ++_i1)
                {
                    if((*_i1))
                    {
                        if(::Test::upCast((*_i1).get())->__usesGC())
                        {
                            ::Test::upCast((*_i1).get())->__decRefUnsafe();
                            (*_i1).__clearHandleUnsafe();
                        }
                        else
                        {
                            (*_i1) = 0;
                        }
                    }
                }
            }
        }
    }
    if(theS.theC)
    {
        if(::Test::upCast(theS.theC.get())->__usesGC())
        {
            ::Test::upCast(theS.theC.get())->__decRefUnsafe();
            theS.theC.__clearHandleUnsafe();
        }
        else
        {
            theS.theC = 0;
        }
    }
    {
        for(::Test::SSeq::iterator _i1 = theA.theSSeq.begin(); _i1 != theA.theSSeq.end(); ++_i1)
        {
            if((*_i1).theC)
            {
                if(::Test::upCast((*_i1).theC.get())->__usesGC())
                {
                    ::Test::upCast((*_i1).theC.get())->__decRefUnsafe();
                    (*_i1).theC.__clearHandleUnsafe();
                }
                else
                {
                    (*_i1).theC = 0;
                }
            }
        }
    }
    {
        for(::Test::C2Dict::iterator _i1 = theS2.theC2Dict.begin(); _i1 != theS2.theC2Dict.end(); ++_i1)
        {
            if((*_i1).second)
            {
                if(::Test::upCast((*_i1).second.get())->__usesGC())
                {
                    ::Test::upCast((*_i1).second.get())->__decRefUnsafe();
                    (*_i1).second.__clearHandleUnsafe();
                }
                else
                {
                    (*_i1).second = 0;
                }
            }
        }
    }
    if(theB.theS.theC)
    {
        if(::Test::upCast(theB.theS.theC.get())->__usesGC())
        {
            ::Test::upCast(theB.theS.theC.get())->__decRefUnsafe();
            theB.theS.theC.__clearHandleUnsafe();
        }
        else
        {
            theB.theS.theC = 0;
        }
    }
    {
        for(::Test::CDict::iterator _i0 = theCDict.begin(); _i0 != theCDict.end(); ++_i0)
        {
            if((*_i0).second)
            {
                if(::Test::upCast((*_i0).second.get())->__usesGC())
                {
                    ::Test::upCast((*_i0).second.get())->__decRefUnsafe();
                    (*_i0).second.__clearHandleUnsafe();
                }
                else
                {
                    (*_i0).second = 0;
                }
            }
        }
    }
    {
        for(::Test::CSeqDict::iterator _i0 = theCSeqDict.begin(); _i0 != theCSeqDict.end(); ++_i0)
        {
            {
                for(::Test::CSeq::iterator _i1 = (*_i0).second.begin(); _i1 != (*_i0).second.end(); ++_i1)
                {
                    if((*_i1))
                    {
                        if(::Test::upCast((*_i1).get())->__usesGC())
                        {
                            ::Test::upCast((*_i1).get())->__decRefUnsafe();
                            (*_i1).__clearHandleUnsafe();
                        }
                        else
                        {
                            (*_i1) = 0;
                        }
                    }
                }
            }
        }
    }
    {
        for(::Test::SDict::iterator _i0 = theSDict.begin(); _i0 != theSDict.end(); ++_i0)
        {
            if((*_i0).second.theC)
            {
                if(::Test::upCast((*_i0).second.theC.get())->__usesGC())
                {
                    ::Test::upCast((*_i0).second.theC.get())->__decRefUnsafe();
                    (*_i0).second.theC.__clearHandleUnsafe();
                }
                else
                {
                    (*_i0).second.theC = 0;
                }
            }
        }
    }
    {
        for(::Test::CDictDict::iterator _i0 = theCDictDict.begin(); _i0 != theCDictDict.end(); ++_i0)
        {
            {
                for(::Test::CDict::iterator _i1 = (*_i0).second.begin(); _i1 != (*_i0).second.end(); ++_i1)
                {
                    if((*_i1).second)
                    {
                        if(::Test::upCast((*_i1).second.get())->__usesGC())
                        {
                            ::Test::upCast((*_i1).second.get())->__decRefUnsafe();
                            (*_i1).second.__clearHandleUnsafe();
                        }
                        else
                        {
                            (*_i1).second = 0;
                        }
                    }
                }
            }
        }
    }
}

void
Test::CTest::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(theCSeq);
    __os->write(theSSeq);
    __os->write(theC2DictSeq);
    __os->write(theCSeqSeq);
    __os->write(theS);
    __os->write(theA);
    __os->write(theS2);
    __os->write(theB);
    __os->write(theCDict);
    __os->write(theCSeqDict);
    __os->write(theSDict);
    __os->write(theCDictDict);
    __os->endWriteSlice();
}

void
Test::CTest::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(theCSeq);
    __is->read(theSSeq);
    __is->read(theC2DictSeq);
    __is->read(theCSeqSeq);
    __is->read(theS);
    __is->read(theA);
    __is->read(theS2);
    __is->read(theB);
    __is->read(theCDict);
    __is->read(theCSeqDict);
    __is->read(theSDict);
    __is->read(theCDictDict);
    __is->endReadSlice();
}

namespace
{

class __F__Test__CTest : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::CTest::ice_staticId());
        return new ::Test::CTest;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__CTest_Ptr = new __F__Test__CTest;

class __F__Test__CTest__Init
{
public:

    __F__Test__CTest__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::CTest::ice_staticId(), __F__Test__CTest_Ptr);
    }

    ~__F__Test__CTest__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::CTest::ice_staticId());
    }
};

const __F__Test__CTest__Init __F__Test__CTest__i;

}

const ::Ice::ObjectFactoryPtr&
Test::CTest::ice_factory()
{
    return __F__Test__CTest_Ptr;
}

void 
Test::__patch(CTestPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::CTestPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::CTest::ice_staticId(), v);
    }
}

::Ice::Object* Test::AAA::upCast(::Test::AAA::C* p) { return p; }
::Ice::ObjectPtr
Test::AAA::C::ice_clone() const
{
    ::Ice::Object* __p = new C(*this);
    return __p;
}

namespace
{
const ::std::string __Test__AAA__C_ids[2] =
{
    "::Ice::Object",
    "::Test::AAA::C"
};

}

bool
Test::AAA::C::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__AAA__C_ids, __Test__AAA__C_ids + 2, _s);
}

::std::vector< ::std::string>
Test::AAA::C::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__AAA__C_ids[0], &__Test__AAA__C_ids[2]);
}

const ::std::string&
Test::AAA::C::ice_id(const ::Ice::Current&) const
{
    return __Test__AAA__C_ids[1];
}

const ::std::string&
Test::AAA::C::ice_staticId()
{
    return __Test__AAA__C_ids[1];
}

void
Test::AAA::C::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::AAA::C::__usesGC()
{
    return true;
}

void
Test::AAA::C::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(obj1)
    {
        obj1->__addObject(_c);
    }
    if(obj2)
    {
        obj2->__addObject(_c);
    }
    if(b1)
    {
        ::Test::AAA::upCast(b1.get())->__addObject(_c);
    }
    if(b2)
    {
        ::Test::AAA::upCast(b2.get())->__addObject(_c);
    }
    {
        for(::Test::AAA::BSeq::const_iterator _i0 = x.begin(); _i0 != x.end(); ++_i0)
        {
            if((*_i0))
            {
                ::Test::AAA::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
    {
        for(::Test::AAA::BDict::const_iterator _i0 = y.begin(); _i0 != y.end(); ++_i0)
        {
            if((*_i0).second)
            {
                ::Test::AAA::upCast((*_i0).second.get())->__addObject(_c);
            }
        }
    }
    if(z.bMem)
    {
        ::Test::AAA::upCast(z.bMem.get())->__addObject(_c);
    }
}

void
Test::AAA::C::__gcClear()
{
    if(obj1)
    {
        if(obj1->__usesGC())
        {
            obj1->__decRefUnsafe();
            obj1.__clearHandleUnsafe();
        }
        else
        {
            obj1 = 0;
        }
    }
    if(obj2)
    {
        if(obj2->__usesGC())
        {
            obj2->__decRefUnsafe();
            obj2.__clearHandleUnsafe();
        }
        else
        {
            obj2 = 0;
        }
    }
    if(b1)
    {
        if(::Test::AAA::upCast(b1.get())->__usesGC())
        {
            ::Test::AAA::upCast(b1.get())->__decRefUnsafe();
            b1.__clearHandleUnsafe();
        }
        else
        {
            b1 = 0;
        }
    }
    if(b2)
    {
        if(::Test::AAA::upCast(b2.get())->__usesGC())
        {
            ::Test::AAA::upCast(b2.get())->__decRefUnsafe();
            b2.__clearHandleUnsafe();
        }
        else
        {
            b2 = 0;
        }
    }
    {
        for(::Test::AAA::BSeq::iterator _i0 = x.begin(); _i0 != x.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::Test::AAA::upCast((*_i0).get())->__usesGC())
                {
                    ::Test::AAA::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
    {
        for(::Test::AAA::BDict::iterator _i0 = y.begin(); _i0 != y.end(); ++_i0)
        {
            if((*_i0).second)
            {
                if(::Test::AAA::upCast((*_i0).second.get())->__usesGC())
                {
                    ::Test::AAA::upCast((*_i0).second.get())->__decRefUnsafe();
                    (*_i0).second.__clearHandleUnsafe();
                }
                else
                {
                    (*_i0).second = 0;
                }
            }
        }
    }
    if(z.bMem)
    {
        if(::Test::AAA::upCast(z.bMem.get())->__usesGC())
        {
            ::Test::AAA::upCast(z.bMem.get())->__decRefUnsafe();
            z.bMem.__clearHandleUnsafe();
        }
        else
        {
            z.bMem = 0;
        }
    }
}

void
Test::AAA::C::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(obj1);
    __os->write(obj2);
    __os->write(b1);
    __os->write(b2);
    __os->write(x);
    __os->write(y);
    __os->write(z);
    __os->endWriteSlice();
}

void
Test::AAA::C::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(obj1);
    __is->read(obj2);
    __is->read(b1);
    __is->read(b2);
    __is->read(x);
    __is->read(y);
    __is->read(z);
    __is->endReadSlice();
}

namespace
{

class __F__Test__AAA__C : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::AAA::C::ice_staticId());
        return new ::Test::AAA::C;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__AAA__C_Ptr = new __F__Test__AAA__C;

class __F__Test__AAA__C__Init
{
public:

    __F__Test__AAA__C__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::AAA::C::ice_staticId(), __F__Test__AAA__C_Ptr);
    }

    ~__F__Test__AAA__C__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::AAA::C::ice_staticId());
    }
};

const __F__Test__AAA__C__Init __F__Test__AAA__C__i;

}

const ::Ice::ObjectFactoryPtr&
Test::AAA::C::ice_factory()
{
    return __F__Test__AAA__C_Ptr;
}

void 
Test::AAA::__patch(CPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::AAA::CPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::AAA::C::ice_staticId(), v);
    }
}

::Ice::Object* Test::AAA::upCast(::Test::AAA::B* p) { return p; }
::Ice::ObjectPtr
Test::AAA::B::ice_clone() const
{
    ::Ice::Object* __p = new B(*this);
    return __p;
}

namespace
{
const ::std::string __Test__AAA__B_ids[2] =
{
    "::Ice::Object",
    "::Test::AAA::B"
};

}

bool
Test::AAA::B::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__AAA__B_ids, __Test__AAA__B_ids + 2, _s);
}

::std::vector< ::std::string>
Test::AAA::B::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__AAA__B_ids[0], &__Test__AAA__B_ids[2]);
}

const ::std::string&
Test::AAA::B::ice_id(const ::Ice::Current&) const
{
    return __Test__AAA__B_ids[1];
}

const ::std::string&
Test::AAA::B::ice_staticId()
{
    return __Test__AAA__B_ids[1];
}

void
Test::AAA::B::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::AAA::B::__usesGC()
{
    return true;
}

void
Test::AAA::B::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(obj1)
    {
        obj1->__addObject(_c);
    }
    if(obj2)
    {
        obj2->__addObject(_c);
    }
    if(c1)
    {
        ::Test::AAA::upCast(c1.get())->__addObject(_c);
    }
    if(c2)
    {
        ::Test::AAA::upCast(c2.get())->__addObject(_c);
    }
    {
        for(::Test::AAA::CSeq::const_iterator _i0 = x.begin(); _i0 != x.end(); ++_i0)
        {
            if((*_i0))
            {
                ::Test::AAA::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
    {
        for(::Test::AAA::CDict::const_iterator _i0 = y.begin(); _i0 != y.end(); ++_i0)
        {
            if((*_i0).second)
            {
                ::Test::AAA::upCast((*_i0).second.get())->__addObject(_c);
            }
        }
    }
    if(z.cMem)
    {
        ::Test::AAA::upCast(z.cMem.get())->__addObject(_c);
    }
}

void
Test::AAA::B::__gcClear()
{
    if(obj1)
    {
        if(obj1->__usesGC())
        {
            obj1->__decRefUnsafe();
            obj1.__clearHandleUnsafe();
        }
        else
        {
            obj1 = 0;
        }
    }
    if(obj2)
    {
        if(obj2->__usesGC())
        {
            obj2->__decRefUnsafe();
            obj2.__clearHandleUnsafe();
        }
        else
        {
            obj2 = 0;
        }
    }
    if(c1)
    {
        if(::Test::AAA::upCast(c1.get())->__usesGC())
        {
            ::Test::AAA::upCast(c1.get())->__decRefUnsafe();
            c1.__clearHandleUnsafe();
        }
        else
        {
            c1 = 0;
        }
    }
    if(c2)
    {
        if(::Test::AAA::upCast(c2.get())->__usesGC())
        {
            ::Test::AAA::upCast(c2.get())->__decRefUnsafe();
            c2.__clearHandleUnsafe();
        }
        else
        {
            c2 = 0;
        }
    }
    {
        for(::Test::AAA::CSeq::iterator _i0 = x.begin(); _i0 != x.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::Test::AAA::upCast((*_i0).get())->__usesGC())
                {
                    ::Test::AAA::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
    {
        for(::Test::AAA::CDict::iterator _i0 = y.begin(); _i0 != y.end(); ++_i0)
        {
            if((*_i0).second)
            {
                if(::Test::AAA::upCast((*_i0).second.get())->__usesGC())
                {
                    ::Test::AAA::upCast((*_i0).second.get())->__decRefUnsafe();
                    (*_i0).second.__clearHandleUnsafe();
                }
                else
                {
                    (*_i0).second = 0;
                }
            }
        }
    }
    if(z.cMem)
    {
        if(::Test::AAA::upCast(z.cMem.get())->__usesGC())
        {
            ::Test::AAA::upCast(z.cMem.get())->__decRefUnsafe();
            z.cMem.__clearHandleUnsafe();
        }
        else
        {
            z.cMem = 0;
        }
    }
}

void
Test::AAA::B::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(obj1);
    __os->write(obj2);
    __os->write(c1);
    __os->write(c2);
    __os->write(x);
    __os->write(y);
    __os->write(z);
    __os->endWriteSlice();
}

void
Test::AAA::B::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(obj1);
    __is->read(obj2);
    __is->read(c1);
    __is->read(c2);
    __is->read(x);
    __is->read(y);
    __is->read(z);
    __is->endReadSlice();
}

namespace
{

class __F__Test__AAA__B : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::AAA::B::ice_staticId());
        return new ::Test::AAA::B;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__AAA__B_Ptr = new __F__Test__AAA__B;

class __F__Test__AAA__B__Init
{
public:

    __F__Test__AAA__B__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::AAA::B::ice_staticId(), __F__Test__AAA__B_Ptr);
    }

    ~__F__Test__AAA__B__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::AAA::B::ice_staticId());
    }
};

const __F__Test__AAA__B__Init __F__Test__AAA__B__i;

}

const ::Ice::ObjectFactoryPtr&
Test::AAA::B::ice_factory()
{
    return __F__Test__AAA__B_Ptr;
}

void 
Test::AAA::__patch(BPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::AAA::BPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::AAA::B::ice_staticId(), v);
    }
}

::Ice::Object* Test::CCC::upCast(::Test::CCC::Forward* p) { return p; }
::Ice::ObjectPtr
Test::CCC::Forward::ice_clone() const
{
    ::Ice::Object* __p = new Forward(*this);
    return __p;
}

namespace
{
const ::std::string __Test__CCC__Forward_ids[2] =
{
    "::Ice::Object",
    "::Test::CCC::Forward"
};

}

bool
Test::CCC::Forward::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__CCC__Forward_ids, __Test__CCC__Forward_ids + 2, _s);
}

::std::vector< ::std::string>
Test::CCC::Forward::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__CCC__Forward_ids[0], &__Test__CCC__Forward_ids[2]);
}

const ::std::string&
Test::CCC::Forward::ice_id(const ::Ice::Current&) const
{
    return __Test__CCC__Forward_ids[1];
}

const ::std::string&
Test::CCC::Forward::ice_staticId()
{
    return __Test__CCC__Forward_ids[1];
}

void
Test::CCC::Forward::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::CCC::Forward::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__CCC__Forward : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::CCC::Forward::ice_staticId());
        return new ::Test::CCC::Forward;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__CCC__Forward_Ptr = new __F__Test__CCC__Forward;

class __F__Test__CCC__Forward__Init
{
public:

    __F__Test__CCC__Forward__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::CCC::Forward::ice_staticId(), __F__Test__CCC__Forward_Ptr);
    }

    ~__F__Test__CCC__Forward__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::CCC::Forward::ice_staticId());
    }
};

const __F__Test__CCC__Forward__Init __F__Test__CCC__Forward__i;

}

const ::Ice::ObjectFactoryPtr&
Test::CCC::Forward::ice_factory()
{
    return __F__Test__CCC__Forward_Ptr;
}

void 
Test::CCC::__patch(ForwardPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::CCC::ForwardPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::CCC::Forward::ice_staticId(), v);
    }
}

::Ice::Object* Test::DDD::upCast(::Test::DDD::I* p) { return p; }

namespace
{
const ::std::string __Test__DDD__I_ids[2] =
{
    "::Ice::Object",
    "::Test::DDD::I"
};

}

bool
Test::DDD::I::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__DDD__I_ids, __Test__DDD__I_ids + 2, _s);
}

::std::vector< ::std::string>
Test::DDD::I::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__DDD__I_ids[0], &__Test__DDD__I_ids[2]);
}

const ::std::string&
Test::DDD::I::ice_id(const ::Ice::Current&) const
{
    return __Test__DDD__I_ids[1];
}

const ::std::string&
Test::DDD::I::ice_staticId()
{
    return __Test__DDD__I_ids[1];
}

::Ice::DispatchStatus
Test::DDD::I::___op(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    op(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__DDD__I_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

::Ice::DispatchStatus
Test::DDD::I::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__DDD__I_all, __Test__DDD__I_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__DDD__I_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::DDD::I::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::DDD::I::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::DDD::__patch(IPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::DDD::IPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::DDD::I::ice_staticId(), v);
    }
}

::Ice::Object* Test::DDD::upCast(::Test::DDD::C* p) { return p; }
::Ice::ObjectPtr
Test::DDD::C::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__DDD__C_ids[2] =
{
    "::Ice::Object",
    "::Test::DDD::C"
};

}

bool
Test::DDD::C::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__DDD__C_ids, __Test__DDD__C_ids + 2, _s);
}

::std::vector< ::std::string>
Test::DDD::C::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__DDD__C_ids[0], &__Test__DDD__C_ids[2]);
}

const ::std::string&
Test::DDD::C::ice_id(const ::Ice::Current&) const
{
    return __Test__DDD__C_ids[1];
}

const ::std::string&
Test::DDD::C::ice_staticId()
{
    return __Test__DDD__C_ids[1];
}

::Ice::DispatchStatus
Test::DDD::C::___op(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    op(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__DDD__C_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

::Ice::DispatchStatus
Test::DDD::C::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__DDD__C_all, __Test__DDD__C_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__DDD__C_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::DDD::C::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::DDD::C::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::DDD::__patch(CPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::DDD::CPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::DDD::C::ice_staticId(), v);
    }
}

::Ice::Object* Test::DDD::upCast(::Test::DDD::U* p) { return p; }
::Ice::ObjectPtr
Test::DDD::U::ice_clone() const
{
    ::Ice::Object* __p = new U(*this);
    return __p;
}

namespace
{
const ::std::string __Test__DDD__U_ids[2] =
{
    "::Ice::Object",
    "::Test::DDD::U"
};

}

bool
Test::DDD::U::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__DDD__U_ids, __Test__DDD__U_ids + 2, _s);
}

::std::vector< ::std::string>
Test::DDD::U::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__DDD__U_ids[0], &__Test__DDD__U_ids[2]);
}

const ::std::string&
Test::DDD::U::ice_id(const ::Ice::Current&) const
{
    return __Test__DDD__U_ids[1];
}

const ::std::string&
Test::DDD::U::ice_staticId()
{
    return __Test__DDD__U_ids[1];
}

void
Test::DDD::U::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::DDD::U::__usesGC()
{
    return true;
}

void
Test::DDD::U::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(myI)
    {
        ::Test::DDD::upCast(myI.get())->__addObject(_c);
    }
    if(myC)
    {
        ::Test::DDD::upCast(myC.get())->__addObject(_c);
    }
    if(myC2)
    {
        ::Test::DDD::upCast(myC2.get())->__addObject(_c);
    }
}

void
Test::DDD::U::__gcClear()
{
    if(myI)
    {
        if(::Test::DDD::upCast(myI.get())->__usesGC())
        {
            ::Test::DDD::upCast(myI.get())->__decRefUnsafe();
            myI.__clearHandleUnsafe();
        }
        else
        {
            myI = 0;
        }
    }
    if(myC)
    {
        if(::Test::DDD::upCast(myC.get())->__usesGC())
        {
            ::Test::DDD::upCast(myC.get())->__decRefUnsafe();
            myC.__clearHandleUnsafe();
        }
        else
        {
            myC = 0;
        }
    }
    if(myC2)
    {
        if(::Test::DDD::upCast(myC2.get())->__usesGC())
        {
            ::Test::DDD::upCast(myC2.get())->__decRefUnsafe();
            myC2.__clearHandleUnsafe();
        }
        else
        {
            myC2 = 0;
        }
    }
}

void
Test::DDD::U::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(myI);
    __os->write(myIstar);
    __os->write(myC);
    __os->write(myCstar);
    __os->write(myC2);
    __os->write(myC2star);
    __os->endWriteSlice();
}

void
Test::DDD::U::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(myI);
    __is->read(myIstar);
    __is->read(myC);
    __is->read(myCstar);
    __is->read(myC2);
    __is->read(myC2star);
    __is->endReadSlice();
}

namespace
{

class __F__Test__DDD__U : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::DDD::U::ice_staticId());
        return new ::Test::DDD::U;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__DDD__U_Ptr = new __F__Test__DDD__U;

class __F__Test__DDD__U__Init
{
public:

    __F__Test__DDD__U__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::DDD::U::ice_staticId(), __F__Test__DDD__U_Ptr);
    }

    ~__F__Test__DDD__U__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::DDD::U::ice_staticId());
    }
};

const __F__Test__DDD__U__Init __F__Test__DDD__U__i;

}

const ::Ice::ObjectFactoryPtr&
Test::DDD::U::ice_factory()
{
    return __F__Test__DDD__U_Ptr;
}

void 
Test::DDD::__patch(UPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::DDD::UPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::DDD::U::ice_staticId(), v);
    }
}

::Ice::Object* Test::DDD::upCast(::Test::DDD::C2* p) { return p; }
::Ice::ObjectPtr
Test::DDD::C2::ice_clone() const
{
    ::Ice::Object* __p = new C2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__DDD__C2_ids[2] =
{
    "::Ice::Object",
    "::Test::DDD::C2"
};

}

bool
Test::DDD::C2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__DDD__C2_ids, __Test__DDD__C2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::DDD::C2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__DDD__C2_ids[0], &__Test__DDD__C2_ids[2]);
}

const ::std::string&
Test::DDD::C2::ice_id(const ::Ice::Current&) const
{
    return __Test__DDD__C2_ids[1];
}

const ::std::string&
Test::DDD::C2::ice_staticId()
{
    return __Test__DDD__C2_ids[1];
}

void
Test::DDD::C2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::DDD::C2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__DDD__C2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::DDD::C2::ice_staticId());
        return new ::Test::DDD::C2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__DDD__C2_Ptr = new __F__Test__DDD__C2;

class __F__Test__DDD__C2__Init
{
public:

    __F__Test__DDD__C2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::DDD::C2::ice_staticId(), __F__Test__DDD__C2_Ptr);
    }

    ~__F__Test__DDD__C2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::DDD::C2::ice_staticId());
    }
};

const __F__Test__DDD__C2__Init __F__Test__DDD__C2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::DDD::C2::ice_factory()
{
    return __F__Test__DDD__C2_Ptr;
}

void 
Test::DDD::__patch(C2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::DDD::C2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::DDD::C2::ice_staticId(), v);
    }
}
