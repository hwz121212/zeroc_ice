// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::C*);

class C2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::C2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::C2*);

class Leaf;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Leaf>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Leaf*);

class Node;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Node>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Node*);

class CTest;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::CTest>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::CTest*);

namespace AAA
{

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::AAA::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::AAA::C*);

}

namespace AAA
{

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::AAA::B*);

}

namespace CCC
{

class Forward;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::CCC::Forward>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::CCC::Forward*);

}

namespace CCC
{

class Forward;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::CCC::Forward>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::CCC::Forward*);

}

namespace DDD
{

class I;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::I>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::DDD::I*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::DDD::C*);

class C2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::DDD::C2*);

class U;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::U>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::DDD::U*);

}

}

}

namespace Test
{

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::C*);
typedef ::IceInternal::Handle< ::Test::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class C2;
bool operator==(const C2&, const C2&);
bool operator<(const C2&, const C2&);
::Ice::Object* upCast(::Test::C2*);
typedef ::IceInternal::Handle< ::Test::C2> C2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C2> C2Prx;
void __patch(C2Ptr&, const ::Ice::ObjectPtr&);

class Leaf;
bool operator==(const Leaf&, const Leaf&);
bool operator<(const Leaf&, const Leaf&);
::Ice::Object* upCast(::Test::Leaf*);
typedef ::IceInternal::Handle< ::Test::Leaf> LeafPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Leaf> LeafPrx;
void __patch(LeafPtr&, const ::Ice::ObjectPtr&);

class Node;
bool operator==(const Node&, const Node&);
bool operator<(const Node&, const Node&);
::Ice::Object* upCast(::Test::Node*);
typedef ::IceInternal::Handle< ::Test::Node> NodePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Node> NodePrx;
void __patch(NodePtr&, const ::Ice::ObjectPtr&);

class CTest;
bool operator==(const CTest&, const CTest&);
bool operator<(const CTest&, const CTest&);
::Ice::Object* upCast(::Test::CTest*);
typedef ::IceInternal::Handle< ::Test::CTest> CTestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CTest> CTestPrx;
void __patch(CTestPtr&, const ::Ice::ObjectPtr&);

namespace AAA
{

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::AAA::B*);
typedef ::IceInternal::Handle< ::Test::AAA::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::AAA::C*);
typedef ::IceInternal::Handle< ::Test::AAA::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

}

namespace AAA
{

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::AAA::B*);
typedef ::IceInternal::Handle< ::Test::AAA::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

}

namespace CCC
{

class Forward;
bool operator==(const Forward&, const Forward&);
bool operator<(const Forward&, const Forward&);
::Ice::Object* upCast(::Test::CCC::Forward*);
typedef ::IceInternal::Handle< ::Test::CCC::Forward> ForwardPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CCC::Forward> ForwardPrx;
void __patch(ForwardPtr&, const ::Ice::ObjectPtr&);

}

namespace CCC
{

class Forward;
bool operator==(const Forward&, const Forward&);
bool operator<(const Forward&, const Forward&);
::Ice::Object* upCast(::Test::CCC::Forward*);
typedef ::IceInternal::Handle< ::Test::CCC::Forward> ForwardPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CCC::Forward> ForwardPrx;
void __patch(ForwardPtr&, const ::Ice::ObjectPtr&);

}

namespace DDD
{

class I;
bool operator==(const I&, const I&);
bool operator<(const I&, const I&);
::Ice::Object* upCast(::Test::DDD::I*);
typedef ::IceInternal::Handle< ::Test::DDD::I> IPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::I> IPrx;
void __patch(IPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::DDD::C*);
typedef ::IceInternal::Handle< ::Test::DDD::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class C2;
bool operator==(const C2&, const C2&);
bool operator<(const C2&, const C2&);
::Ice::Object* upCast(::Test::DDD::C2*);
typedef ::IceInternal::Handle< ::Test::DDD::C2> C2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C2> C2Prx;
void __patch(C2Ptr&, const ::Ice::ObjectPtr&);

class U;
bool operator==(const U&, const U&);
bool operator<(const U&, const U&);
::Ice::Object* upCast(::Test::DDD::U*);
typedef ::IceInternal::Handle< ::Test::DDD::U> UPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::U> UPrx;
void __patch(UPtr&, const ::Ice::ObjectPtr&);

}

}

namespace Test
{

typedef ::std::vector< ::Test::CPtr> CSeq;

typedef ::std::map< ::Ice::Int, ::Test::CPtr> CDict;

struct S
{
    ::Test::CPtr theC;
};

typedef ::std::vector< ::Test::S> SSeq;

typedef ::std::map< ::Ice::Int, ::Test::C2Ptr> C2Dict;

struct S2
{
    ::Test::C2Dict theC2Dict;
};

typedef ::std::vector< ::Test::S2> S2Seq;

typedef ::std::vector< ::Test::C2Dict> C2DictSeq;

typedef ::std::vector< ::Test::CSeq> CSeqSeq;

struct A
{
    ::Test::SSeq theSSeq;
};

struct B
{
    ::Test::S theS;
};

typedef ::std::map< ::Ice::Int, ::Test::CSeq> CSeqDict;

typedef ::std::map< ::Ice::Int, ::Test::S> SDict;

typedef ::std::map< ::Ice::Int, ::Test::CDict> CDictDict;

namespace AAA
{

typedef ::std::vector< ::Test::AAA::BPtr> BSeq;

typedef ::std::map< ::Ice::Int, ::Test::AAA::BPtr> BDict;

struct BStruct
{
    ::Test::AAA::BPtr bMem;
};

}

namespace AAA
{

typedef ::std::vector< ::Test::AAA::CPtr> CSeq;

typedef ::std::map< ::Ice::Int, ::Test::AAA::CPtr> CDict;

struct CStruct
{
    ::Test::AAA::CPtr cMem;
};

}

namespace CCC
{

typedef ::std::vector< ::Test::CCC::ForwardPrx> ForwardProxySeq;

}

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::S, S>
{
    static void write(S* __os, const ::Test::S& v)
    {
        __os->write(v.theC);
    }
};

template<class S>
struct StreamReader< ::Test::S, S>
{
    static void read(S* __is, ::Test::S& v)
    {
        __is->read(v.theC);
    }
};

template<>
struct StreamableTraits< ::Test::S2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::S2, S>
{
    static void write(S* __os, const ::Test::S2& v)
    {
        __os->write(v.theC2Dict);
    }
};

template<class S>
struct StreamReader< ::Test::S2, S>
{
    static void read(S* __is, ::Test::S2& v)
    {
        __is->read(v.theC2Dict);
    }
};

template<>
struct StreamableTraits< ::Test::A>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::A, S>
{
    static void write(S* __os, const ::Test::A& v)
    {
        __os->write(v.theSSeq);
    }
};

template<class S>
struct StreamReader< ::Test::A, S>
{
    static void read(S* __is, ::Test::A& v)
    {
        __is->read(v.theSSeq);
    }
};

template<>
struct StreamableTraits< ::Test::B>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::B, S>
{
    static void write(S* __os, const ::Test::B& v)
    {
        __os->write(v.theS);
    }
};

template<class S>
struct StreamReader< ::Test::B, S>
{
    static void read(S* __is, ::Test::B& v)
    {
        __is->read(v.theS);
    }
};

template<>
struct StreamableTraits< ::Test::AAA::BStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::AAA::BStruct, S>
{
    static void write(S* __os, const ::Test::AAA::BStruct& v)
    {
        __os->write(v.bMem);
    }
};

template<class S>
struct StreamReader< ::Test::AAA::BStruct, S>
{
    static void read(S* __is, ::Test::AAA::BStruct& v)
    {
        __is->read(v.bMem);
    }
};

template<>
struct StreamableTraits< ::Test::AAA::CStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::AAA::CStruct, S>
{
    static void write(S* __os, const ::Test::AAA::CStruct& v)
    {
        __os->write(v.cMem);
    }
};

template<class S>
struct StreamReader< ::Test::AAA::CStruct, S>
{
    static void read(S* __is, ::Test::AAA::CStruct& v)
    {
        __is->read(v.cMem);
    }
};

}

namespace Test
{

namespace AAA
{

}

namespace AAA
{

}

namespace CCC
{

}

namespace DDD
{

class Callback_I_op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_I_op_Base> Callback_I_opPtr;

class Callback_C_op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_C_op_Base> Callback_C_opPtr;

}

}

namespace IceProxy
{

namespace Test
{

class C : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C2 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<C2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_secure(bool __secure) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_twoway() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_oneway() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_batchOneway() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_datagram() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_batchDatagram() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_compress(bool __compress) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Leaf : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Leaf> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_secure(bool __secure) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_twoway() const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_oneway() const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_batchOneway() const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_datagram() const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_batchDatagram() const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_compress(bool __compress) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Leaf> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Leaf*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Node : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Node> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_secure(bool __secure) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_twoway() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_oneway() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_batchOneway() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_datagram() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_batchDatagram() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_compress(bool __compress) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class CTest : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<CTest> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_secure(bool __secure) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_twoway() const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_oneway() const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_batchOneway() const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_datagram() const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_batchDatagram() const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_compress(bool __compress) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_timeout(int __timeout) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CTest> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<CTest*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

namespace AAA
{

class C : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace AAA
{

class B : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace CCC
{

class Forward : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Forward> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_secure(bool __secure) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_twoway() const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_oneway() const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_batchOneway() const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_datagram() const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_batchDatagram() const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_compress(bool __compress) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Forward> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Forward*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace DDD
{

class I : virtual public ::IceProxy::Ice::Object
{
public:

    void op()
    {
        op(0);
    }
    void op(const ::Ice::Context& __ctx)
    {
        op(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_op()
    {
        return begin_op(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx)
    {
        return begin_op(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::DDD::Callback_I_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Test::DDD::Callback_I_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    void end_op(const ::Ice::AsyncResultPtr&);
    
private:

    void op(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<I> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_secure(bool __secure) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_twoway() const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_oneway() const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_batchOneway() const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_datagram() const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_batchDatagram() const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_compress(bool __compress) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_timeout(int __timeout) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<I> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<I*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Ice::Object
{
public:

    void op()
    {
        op(0);
    }
    void op(const ::Ice::Context& __ctx)
    {
        op(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_op()
    {
        return begin_op(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx)
    {
        return begin_op(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::DDD::Callback_C_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Test::DDD::Callback_C_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    void end_op(const ::Ice::AsyncResultPtr&);
    
private:

    void op(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class U : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<U> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_secure(bool __secure) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_twoway() const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_oneway() const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_batchOneway() const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_datagram() const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_batchDatagram() const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_compress(bool __compress) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_timeout(int __timeout) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<U> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<U*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C2 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<C2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_secure(bool __secure) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_twoway() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_oneway() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_batchOneway() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_datagram() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_batchDatagram() const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_compress(bool __compress) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace Test
{

class C : virtual public ::IceDelegate::Ice::Object
{
public:
};

class C2 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Leaf : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Node : virtual public ::IceDelegate::Ice::Object
{
public:
};

class CTest : virtual public ::IceDelegate::Ice::Object
{
public:
};

namespace AAA
{

class C : virtual public ::IceDelegate::Ice::Object
{
public:
};

}

namespace AAA
{

class B : virtual public ::IceDelegate::Ice::Object
{
public:
};

}

namespace CCC
{

class Forward : virtual public ::IceDelegate::Ice::Object
{
public:
};

}

namespace DDD
{

class I : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void op(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class C : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void op(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class U : virtual public ::IceDelegate::Ice::Object
{
public:
};

class C2 : virtual public ::IceDelegate::Ice::Object
{
public:
};

}

}

}

namespace IceDelegateM
{

namespace Test
{

class C : virtual public ::IceDelegate::Test::C,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class C2 : virtual public ::IceDelegate::Test::C2,
           virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Leaf : virtual public ::IceDelegate::Test::Leaf,
             virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Node : virtual public ::IceDelegate::Test::Node,
             virtual public ::IceDelegateM::Ice::Object
{
public:
};

class CTest : virtual public ::IceDelegate::Test::CTest,
              virtual public ::IceDelegateM::Ice::Object
{
public:
};

namespace AAA
{

class C : virtual public ::IceDelegate::Test::AAA::C,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

}

namespace AAA
{

class B : virtual public ::IceDelegate::Test::AAA::B,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

}

namespace CCC
{

class Forward : virtual public ::IceDelegate::Test::CCC::Forward,
                virtual public ::IceDelegateM::Ice::Object
{
public:
};

}

namespace DDD
{

class I : virtual public ::IceDelegate::Test::DDD::I,
          virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class C : virtual public ::IceDelegate::Test::DDD::C,
          virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class U : virtual public ::IceDelegate::Test::DDD::U,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class C2 : virtual public ::IceDelegate::Test::DDD::C2,
           virtual public ::IceDelegateM::Ice::Object
{
public:
};

}

}

}

namespace IceDelegateD
{

namespace Test
{

class C : virtual public ::IceDelegate::Test::C,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class C2 : virtual public ::IceDelegate::Test::C2,
           virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Leaf : virtual public ::IceDelegate::Test::Leaf,
             virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Node : virtual public ::IceDelegate::Test::Node,
             virtual public ::IceDelegateD::Ice::Object
{
public:
};

class CTest : virtual public ::IceDelegate::Test::CTest,
              virtual public ::IceDelegateD::Ice::Object
{
public:
};

namespace AAA
{

class C : virtual public ::IceDelegate::Test::AAA::C,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

}

namespace AAA
{

class B : virtual public ::IceDelegate::Test::AAA::B,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

}

namespace CCC
{

class Forward : virtual public ::IceDelegate::Test::CCC::Forward,
                virtual public ::IceDelegateD::Ice::Object
{
public:
};

}

namespace DDD
{

class I : virtual public ::IceDelegate::Test::DDD::I,
          virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class C : virtual public ::IceDelegate::Test::DDD::C,
          virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class U : virtual public ::IceDelegate::Test::DDD::U,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class C2 : virtual public ::IceDelegate::Test::DDD::C2,
           virtual public ::IceDelegateD::Ice::Object
{
public:
};

}

}

}

namespace Test
{

class C : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(const ::Test::CPtr& __ice_left, const ::Test::CPtr& __ice_right) :
        left(__ice_left),
        right(__ice_right)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::CPtr left;

    ::Test::CPtr right;

protected:

    virtual ~C() {}

    friend class C__staticInit;
};

class C__staticInit
{
public:

    ::Test::C _init;
};

static C__staticInit _C_init;

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C2 : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef C2Prx ProxyType;
    typedef C2Ptr PointerType;

    C2()
    {
    }

    explicit C2(const ::Test::S2Seq& __ice_theS2Seq) :
        theS2Seq(__ice_theS2Seq)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::S2Seq theS2Seq;

protected:

    virtual ~C2() {}
};

inline bool operator==(const C2& l, const C2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C2& l, const C2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Leaf : virtual public ::Ice::Object
{
public:

    typedef LeafPrx ProxyType;
    typedef LeafPtr PointerType;

    Leaf()
    {
    }

    explicit Leaf(::Ice::Int __ice_i) :
        i(__ice_i)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int i;

protected:

    virtual ~Leaf() {}
};

inline bool operator==(const Leaf& l, const Leaf& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Leaf& l, const Leaf& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Node : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef NodePrx ProxyType;
    typedef NodePtr PointerType;

    Node()
    {
    }

    Node(const ::Test::LeafPtr& __ice_l, const ::Test::NodePtr& __ice_n) :
        l(__ice_l),
        n(__ice_n)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::LeafPtr l;

    ::Test::NodePtr n;

protected:

    virtual ~Node() {}
};

inline bool operator==(const Node& l, const Node& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Node& l, const Node& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class CTest : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef CTestPrx ProxyType;
    typedef CTestPtr PointerType;

    CTest()
    {
    }

    CTest(const ::Test::CSeq& __ice_theCSeq, const ::Test::SSeq& __ice_theSSeq, const ::Test::C2DictSeq& __ice_theC2DictSeq, const ::Test::CSeqSeq& __ice_theCSeqSeq, const ::Test::S& __ice_theS, const ::Test::A& __ice_theA, const ::Test::S2& __ice_theS2, const ::Test::B& __ice_theB, const ::Test::CDict& __ice_theCDict, const ::Test::CSeqDict& __ice_theCSeqDict, const ::Test::SDict& __ice_theSDict, const ::Test::CDictDict& __ice_theCDictDict) :
        theCSeq(__ice_theCSeq),
        theSSeq(__ice_theSSeq),
        theC2DictSeq(__ice_theC2DictSeq),
        theCSeqSeq(__ice_theCSeqSeq),
        theS(__ice_theS),
        theA(__ice_theA),
        theS2(__ice_theS2),
        theB(__ice_theB),
        theCDict(__ice_theCDict),
        theCSeqDict(__ice_theCSeqDict),
        theSDict(__ice_theSDict),
        theCDictDict(__ice_theCDictDict)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::CSeq theCSeq;

    ::Test::SSeq theSSeq;

    ::Test::C2DictSeq theC2DictSeq;

    ::Test::CSeqSeq theCSeqSeq;

    ::Test::S theS;

    ::Test::A theA;

    ::Test::S2 theS2;

    ::Test::B theB;

    ::Test::CDict theCDict;

    ::Test::CSeqDict theCSeqDict;

    ::Test::SDict theSDict;

    ::Test::CDictDict theCDictDict;

protected:

    virtual ~CTest() {}
};

inline bool operator==(const CTest& l, const CTest& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CTest& l, const CTest& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

namespace AAA
{

class C : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(const ::Ice::ObjectPtr& __ice_obj1, const ::Ice::ObjectPtr& __ice_obj2, const ::Test::AAA::BPtr& __ice_b1, const ::Test::AAA::BPtr& __ice_b2, const ::Test::AAA::BSeq& __ice_x, const ::Test::AAA::BDict& __ice_y, const ::Test::AAA::BStruct& __ice_z) :
        obj1(__ice_obj1),
        obj2(__ice_obj2),
        b1(__ice_b1),
        b2(__ice_b2),
        x(__ice_x),
        y(__ice_y),
        z(__ice_z)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::ObjectPtr obj1;

    ::Ice::ObjectPtr obj2;

    ::Test::AAA::BPtr b1;

    ::Test::AAA::BPtr b2;

    ::Test::AAA::BSeq x;

    ::Test::AAA::BDict y;

    ::Test::AAA::BStruct z;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace AAA
{

class B : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(const ::Ice::ObjectPtr& __ice_obj1, const ::Ice::ObjectPtr& __ice_obj2, const ::Test::AAA::CPtr& __ice_c1, const ::Test::AAA::CPtr& __ice_c2, const ::Test::AAA::CSeq& __ice_x, const ::Test::AAA::CDict& __ice_y, const ::Test::AAA::CStruct& __ice_z) :
        obj1(__ice_obj1),
        obj2(__ice_obj2),
        c1(__ice_c1),
        c2(__ice_c2),
        x(__ice_x),
        y(__ice_y),
        z(__ice_z)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::ObjectPtr obj1;

    ::Ice::ObjectPtr obj2;

    ::Test::AAA::CPtr c1;

    ::Test::AAA::CPtr c2;

    ::Test::AAA::CSeq x;

    ::Test::AAA::CDict y;

    ::Test::AAA::CStruct z;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace CCC
{

class Forward : virtual public ::Ice::Object
{
public:

    typedef ForwardPrx ProxyType;
    typedef ForwardPtr PointerType;

    Forward()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~Forward() {}
};

inline bool operator==(const Forward& l, const Forward& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Forward& l, const Forward& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace DDD
{

class I : virtual public ::Ice::Object
{
public:

    typedef IPrx ProxyType;
    typedef IPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const I& l, const I& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const I& l, const I& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : virtual public ::Ice::Object
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class U : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef UPrx ProxyType;
    typedef UPtr PointerType;

    U()
    {
    }

    U(const ::Test::DDD::IPtr& __ice_myI, const ::Test::DDD::IPrx& __ice_myIstar, const ::Test::DDD::CPtr& __ice_myC, const ::Test::DDD::CPrx& __ice_myCstar, const ::Test::DDD::C2Ptr& __ice_myC2, const ::Test::DDD::C2Prx& __ice_myC2star) :
        myI(__ice_myI),
        myIstar(__ice_myIstar),
        myC(__ice_myC),
        myCstar(__ice_myCstar),
        myC2(__ice_myC2),
        myC2star(__ice_myC2star)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::DDD::IPtr myI;

    ::Test::DDD::IPrx myIstar;

    ::Test::DDD::CPtr myC;

    ::Test::DDD::CPrx myCstar;

    ::Test::DDD::C2Ptr myC2;

    ::Test::DDD::C2Prx myC2star;

protected:

    virtual ~U() {}
};

inline bool operator==(const U& l, const U& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const U& l, const U& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C2 : virtual public ::Ice::Object
{
public:

    typedef C2Prx ProxyType;
    typedef C2Ptr PointerType;

    C2()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~C2() {}
};

inline bool operator==(const C2& l, const C2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C2& l, const C2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace Test
{

namespace AAA
{

}

namespace AAA
{

}

namespace CCC
{

}

namespace DDD
{

template<class T>
class CallbackNC_I_op : public Callback_I_op_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_I_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_I_op : public Callback_I_op_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_I_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_C_op : public Callback_C_op_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_C_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_C_opPtr
newCallback_C_op(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_C_op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_C_opPtr
newCallback_C_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_C_op<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_C_opPtr
newCallback_C_op(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_C_op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_C_opPtr
newCallback_C_op(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_C_op<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_C_op : public Callback_C_op_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_C_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_C_opPtr
newCallback_C_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_C_op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_C_opPtr
newCallback_C_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_C_op<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_C_opPtr
newCallback_C_op(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_C_op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_C_opPtr
newCallback_C_op(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_C_op<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif
