// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/Current.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class MyClass;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MyClass*);

class MyDerivedClass;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MyDerivedClass>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MyDerivedClass*);

}

}

namespace Test
{

class MyClass;
bool operator==(const MyClass&, const MyClass&);
bool operator<(const MyClass&, const MyClass&);
::Ice::Object* upCast(::Test::MyClass*);
typedef ::IceInternal::Handle< ::Test::MyClass> MyClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass> MyClassPrx;
void __patch(MyClassPtr&, const ::Ice::ObjectPtr&);

class MyDerivedClass;
bool operator==(const MyDerivedClass&, const MyDerivedClass&);
bool operator<(const MyDerivedClass&, const MyDerivedClass&);
::Ice::Object* upCast(::Test::MyDerivedClass*);
typedef ::IceInternal::Handle< ::Test::MyDerivedClass> MyDerivedClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyDerivedClass> MyDerivedClassPrx;
void __patch(MyDerivedClassPtr&, const ::Ice::ObjectPtr&);

}

namespace Test
{

enum MyEnum
{
    enum1,
    enum2,
    enum3
};

struct AnotherStruct
{
    ::std::string s;

    bool operator==(const AnotherStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(s != __rhs.s)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AnotherStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(s < __rhs.s)
        {
            return true;
        }
        else if(__rhs.s < s)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AnotherStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const AnotherStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const AnotherStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const AnotherStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Structure
{
    ::Test::MyClassPrx p;
    ::Test::MyEnum e;
    ::Test::AnotherStruct s;
};

typedef ::std::vector< ::Ice::Byte> ByteS;

typedef ::std::vector<bool> BoolS;

typedef ::std::vector< ::Ice::Short> ShortS;

typedef ::std::vector< ::Ice::Int> IntS;

typedef ::std::vector< ::Ice::Long> LongS;

typedef ::std::vector< ::Ice::Float> FloatS;

typedef ::std::vector< ::Ice::Double> DoubleS;

typedef ::std::vector< ::std::string> StringS;

typedef ::std::vector< ::Test::MyEnum> MyEnumS;

typedef ::std::vector< ::Test::MyClassPrx> MyClassS;

typedef ::std::vector< ::Test::ByteS> ByteSS;

typedef ::std::vector< ::Test::BoolS> BoolSS;

typedef ::std::vector< ::Test::ShortS> ShortSS;

typedef ::std::vector< ::Test::IntS> IntSS;

typedef ::std::vector< ::Test::LongS> LongSS;

typedef ::std::vector< ::Test::FloatS> FloatSS;

typedef ::std::vector< ::Test::DoubleS> DoubleSS;

typedef ::std::vector< ::Test::StringS> StringSS;

typedef ::std::vector< ::Test::MyEnumS> MyEnumSS;

typedef ::std::vector< ::Test::MyClassS> MyClassSS;

typedef ::std::vector< ::Test::StringSS> StringSSS;

struct MyStruct
{
    ::Ice::Int i;
    ::Ice::Int j;

    bool operator==(const MyStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        if(j != __rhs.j)
        {
            return false;
        }
        return true;
    }

    bool operator<(const MyStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        if(j < __rhs.j)
        {
            return true;
        }
        else if(__rhs.j < j)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const MyStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const MyStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const MyStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const MyStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::map< ::Ice::Byte, bool> ByteBoolD;

typedef ::std::map< ::Ice::Short, ::Ice::Int> ShortIntD;

typedef ::std::map< ::Ice::Long, ::Ice::Float> LongFloatD;

typedef ::std::map< ::std::string, ::std::string> StringStringD;

typedef ::std::map< ::std::string, ::Test::MyEnum> StringMyEnumD;

typedef ::std::map< ::Test::MyEnum, ::std::string> MyEnumStringD;

typedef ::std::map< ::Test::MyStruct, ::Test::MyEnum> MyStructMyEnumD;

class SomeException : public ::Ice::UserException
{
public:

    SomeException() {}
    virtual ~SomeException() throw();

    virtual ::std::string ice_name() const;
    virtual SomeException* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

static SomeException __SomeException_init;

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::AnotherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::AnotherStruct, S>
{
    static void write(S* __os, const ::Test::AnotherStruct& v)
    {
        __os->write(v.s);
    }
};

template<class S>
struct StreamReader< ::Test::AnotherStruct, S>
{
    static void read(S* __is, ::Test::AnotherStruct& v)
    {
        __is->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::Structure>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Structure, S>
{
    static void write(S* __os, const ::Test::Structure& v)
    {
        __os->write(v.p);
        __os->write(v.e);
        __os->write(v.s);
    }
};

template<class S>
struct StreamReader< ::Test::Structure, S>
{
    static void read(S* __is, ::Test::Structure& v)
    {
        __is->read(v.p);
        __is->read(v.e);
        __is->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::MyStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::MyStruct, S>
{
    static void write(S* __os, const ::Test::MyStruct& v)
    {
        __os->write(v.i);
        __os->write(v.j);
    }
};

template<class S>
struct StreamReader< ::Test::MyStruct, S>
{
    static void read(S* __is, ::Test::MyStruct& v)
    {
        __is->read(v.i);
        __is->read(v.j);
    }
};

template<>
struct StreamableTraits< ::Test::SomeException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Test
{

class AMI_MyClass_shutdown : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_shutdown> AMI_MyClass_shutdownPtr;

class AMI_MyClass_delay : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_delay> AMI_MyClass_delayPtr;

class AMI_MyClass_opVoid : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opVoid> AMI_MyClass_opVoidPtr;

class AMI_MyClass_opByte : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Byte, ::Ice::Byte) = 0;

    void __response(::Ice::Byte __ret, ::Ice::Byte p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opByte> AMI_MyClass_opBytePtr;

class AMI_MyClass_opBool : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool, bool) = 0;

    void __response(bool __ret, bool p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opBool> AMI_MyClass_opBoolPtr;

class AMI_MyClass_opShortIntLong : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long) = 0;

    void __response(::Ice::Long __ret, ::Ice::Short p4, ::Ice::Int p5, ::Ice::Long p6)
    {
        ice_response(__ret, p4, p5, p6);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opShortIntLong> AMI_MyClass_opShortIntLongPtr;

class AMI_MyClass_opFloatDouble : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Double, ::Ice::Float, ::Ice::Double) = 0;

    void __response(::Ice::Double __ret, ::Ice::Float p3, ::Ice::Double p4)
    {
        ice_response(__ret, p3, p4);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opFloatDouble> AMI_MyClass_opFloatDoublePtr;

class AMI_MyClass_opString : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::string&, const ::std::string&) = 0;

    void __response(const ::std::string& __ret, const ::std::string& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opString> AMI_MyClass_opStringPtr;

class AMI_MyClass_opMyEnum : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Test::MyEnum, ::Test::MyEnum) = 0;

    void __response(::Test::MyEnum __ret, ::Test::MyEnum p2)
    {
        ice_response(__ret, p2);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opMyEnum> AMI_MyClass_opMyEnumPtr;

class AMI_MyClass_opMyClass : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&) = 0;

    void __response(const ::Test::MyClassPrx& __ret, const ::Test::MyClassPrx& p2, const ::Test::MyClassPrx& p3)
    {
        ice_response(__ret, p2, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opMyClass> AMI_MyClass_opMyClassPtr;

class AMI_MyClass_opStruct : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::Structure&, const ::Test::Structure&) = 0;

    void __response(const ::Test::Structure& __ret, const ::Test::Structure& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opStruct> AMI_MyClass_opStructPtr;

class AMI_MyClass_opByteS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::ByteS&, const ::Test::ByteS&) = 0;

    void __response(const ::Test::ByteS& __ret, const ::Test::ByteS& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opByteS> AMI_MyClass_opByteSPtr;

class AMI_MyClass_opBoolS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::BoolS&, const ::Test::BoolS&) = 0;

    void __response(const ::Test::BoolS& __ret, const ::Test::BoolS& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opBoolS> AMI_MyClass_opBoolSPtr;

class AMI_MyClass_opShortIntLongS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&) = 0;

    void __response(const ::Test::LongS& __ret, const ::Test::ShortS& p4, const ::Test::IntS& p5, const ::Test::LongS& p6)
    {
        ice_response(__ret, p4, p5, p6);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opShortIntLongS> AMI_MyClass_opShortIntLongSPtr;

class AMI_MyClass_opFloatDoubleS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&) = 0;

    void __response(const ::Test::DoubleS& __ret, const ::Test::FloatS& p3, const ::Test::DoubleS& p4)
    {
        ice_response(__ret, p3, p4);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opFloatDoubleS> AMI_MyClass_opFloatDoubleSPtr;

class AMI_MyClass_opStringS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::StringS&, const ::Test::StringS&) = 0;

    void __response(const ::Test::StringS& __ret, const ::Test::StringS& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opStringS> AMI_MyClass_opStringSPtr;

class AMI_MyClass_opByteSS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::ByteSS&, const ::Test::ByteSS&) = 0;

    void __response(const ::Test::ByteSS& __ret, const ::Test::ByteSS& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opByteSS> AMI_MyClass_opByteSSPtr;

class AMI_MyClass_opBoolSS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::BoolSS&, const ::Test::BoolSS&) = 0;

    void __response(const ::Test::BoolSS& __ret, const ::Test::BoolSS& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opBoolSS> AMI_MyClass_opBoolSSPtr;

class AMI_MyClass_opShortIntLongSS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&) = 0;

    void __response(const ::Test::LongSS& __ret, const ::Test::ShortSS& p4, const ::Test::IntSS& p5, const ::Test::LongSS& p6)
    {
        ice_response(__ret, p4, p5, p6);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opShortIntLongSS> AMI_MyClass_opShortIntLongSSPtr;

class AMI_MyClass_opFloatDoubleSS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&) = 0;

    void __response(const ::Test::DoubleSS& __ret, const ::Test::FloatSS& p3, const ::Test::DoubleSS& p4)
    {
        ice_response(__ret, p3, p4);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opFloatDoubleSS> AMI_MyClass_opFloatDoubleSSPtr;

class AMI_MyClass_opStringSS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::StringSS&, const ::Test::StringSS&) = 0;

    void __response(const ::Test::StringSS& __ret, const ::Test::StringSS& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opStringSS> AMI_MyClass_opStringSSPtr;

class AMI_MyClass_opStringSSS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::StringSSS&, const ::Test::StringSSS&) = 0;

    void __response(const ::Test::StringSSS& __ret, const ::Test::StringSSS& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opStringSSS> AMI_MyClass_opStringSSSPtr;

class AMI_MyClass_opByteBoolD : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&) = 0;

    void __response(const ::Test::ByteBoolD& __ret, const ::Test::ByteBoolD& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opByteBoolD> AMI_MyClass_opByteBoolDPtr;

class AMI_MyClass_opShortIntD : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::ShortIntD&, const ::Test::ShortIntD&) = 0;

    void __response(const ::Test::ShortIntD& __ret, const ::Test::ShortIntD& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opShortIntD> AMI_MyClass_opShortIntDPtr;

class AMI_MyClass_opLongFloatD : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::LongFloatD&, const ::Test::LongFloatD&) = 0;

    void __response(const ::Test::LongFloatD& __ret, const ::Test::LongFloatD& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opLongFloatD> AMI_MyClass_opLongFloatDPtr;

class AMI_MyClass_opStringStringD : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::StringStringD&, const ::Test::StringStringD&) = 0;

    void __response(const ::Test::StringStringD& __ret, const ::Test::StringStringD& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opStringStringD> AMI_MyClass_opStringStringDPtr;

class AMI_MyClass_opStringMyEnumD : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&) = 0;

    void __response(const ::Test::StringMyEnumD& __ret, const ::Test::StringMyEnumD& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opStringMyEnumD> AMI_MyClass_opStringMyEnumDPtr;

class AMI_MyClass_opMyEnumStringD : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&) = 0;

    void __response(const ::Test::MyEnumStringD& __ret, const ::Test::MyEnumStringD& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opMyEnumStringD> AMI_MyClass_opMyEnumStringDPtr;

class AMI_MyClass_opMyStructMyEnumD : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&) = 0;

    void __response(const ::Test::MyStructMyEnumD& __ret, const ::Test::MyStructMyEnumD& p3)
    {
        ice_response(__ret, p3);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opMyStructMyEnumD> AMI_MyClass_opMyStructMyEnumDPtr;

class AMI_MyClass_opIntS : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::IntS&) = 0;

    void __response(const ::Test::IntS& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opIntS> AMI_MyClass_opIntSPtr;

class AMI_MyClass_opByteSOneway : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opByteSOneway> AMI_MyClass_opByteSOnewayPtr;

class AMI_MyClass_opContext : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::Context&) = 0;

    void __response(const ::Ice::Context& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opContext> AMI_MyClass_opContextPtr;

class AMI_MyClass_opDoubleMarshaling : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opDoubleMarshaling> AMI_MyClass_opDoubleMarshalingPtr;

class AMI_MyClass_opIdempotent : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opIdempotent> AMI_MyClass_opIdempotentPtr;

class AMI_MyClass_opNonmutating : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyClass_opNonmutating> AMI_MyClass_opNonmutatingPtr;

class AMI_MyDerivedClass_opDerived : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_MyDerivedClass_opDerived> AMI_MyDerivedClass_opDerivedPtr;

}

namespace Test
{

class Callback_MyClass_shutdown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_shutdown_Base> Callback_MyClass_shutdownPtr;

class Callback_MyClass_delay_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_delay_Base> Callback_MyClass_delayPtr;

class Callback_MyClass_opVoid_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opVoid_Base> Callback_MyClass_opVoidPtr;

class Callback_MyClass_opByte_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByte_Base> Callback_MyClass_opBytePtr;

class Callback_MyClass_opBool_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opBool_Base> Callback_MyClass_opBoolPtr;

class Callback_MyClass_opShortIntLong_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntLong_Base> Callback_MyClass_opShortIntLongPtr;

class Callback_MyClass_opFloatDouble_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opFloatDouble_Base> Callback_MyClass_opFloatDoublePtr;

class Callback_MyClass_opString_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opString_Base> Callback_MyClass_opStringPtr;

class Callback_MyClass_opMyEnum_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyEnum_Base> Callback_MyClass_opMyEnumPtr;

class Callback_MyClass_opMyClass_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyClass_Base> Callback_MyClass_opMyClassPtr;

class Callback_MyClass_opStruct_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStruct_Base> Callback_MyClass_opStructPtr;

class Callback_MyClass_opByteS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteS_Base> Callback_MyClass_opByteSPtr;

class Callback_MyClass_opBoolS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opBoolS_Base> Callback_MyClass_opBoolSPtr;

class Callback_MyClass_opShortIntLongS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntLongS_Base> Callback_MyClass_opShortIntLongSPtr;

class Callback_MyClass_opFloatDoubleS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opFloatDoubleS_Base> Callback_MyClass_opFloatDoubleSPtr;

class Callback_MyClass_opStringS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringS_Base> Callback_MyClass_opStringSPtr;

class Callback_MyClass_opByteSS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteSS_Base> Callback_MyClass_opByteSSPtr;

class Callback_MyClass_opBoolSS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opBoolSS_Base> Callback_MyClass_opBoolSSPtr;

class Callback_MyClass_opShortIntLongSS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntLongSS_Base> Callback_MyClass_opShortIntLongSSPtr;

class Callback_MyClass_opFloatDoubleSS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opFloatDoubleSS_Base> Callback_MyClass_opFloatDoubleSSPtr;

class Callback_MyClass_opStringSS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringSS_Base> Callback_MyClass_opStringSSPtr;

class Callback_MyClass_opStringSSS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringSSS_Base> Callback_MyClass_opStringSSSPtr;

class Callback_MyClass_opByteBoolD_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteBoolD_Base> Callback_MyClass_opByteBoolDPtr;

class Callback_MyClass_opShortIntD_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntD_Base> Callback_MyClass_opShortIntDPtr;

class Callback_MyClass_opLongFloatD_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLongFloatD_Base> Callback_MyClass_opLongFloatDPtr;

class Callback_MyClass_opStringStringD_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringStringD_Base> Callback_MyClass_opStringStringDPtr;

class Callback_MyClass_opStringMyEnumD_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringMyEnumD_Base> Callback_MyClass_opStringMyEnumDPtr;

class Callback_MyClass_opMyEnumStringD_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyEnumStringD_Base> Callback_MyClass_opMyEnumStringDPtr;

class Callback_MyClass_opMyStructMyEnumD_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyStructMyEnumD_Base> Callback_MyClass_opMyStructMyEnumDPtr;

class Callback_MyClass_opIntS_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opIntS_Base> Callback_MyClass_opIntSPtr;

class Callback_MyClass_opByteSOneway_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteSOneway_Base> Callback_MyClass_opByteSOnewayPtr;

class Callback_MyClass_opContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opContext_Base> Callback_MyClass_opContextPtr;

class Callback_MyClass_opDoubleMarshaling_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opDoubleMarshaling_Base> Callback_MyClass_opDoubleMarshalingPtr;

class Callback_MyClass_opIdempotent_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opIdempotent_Base> Callback_MyClass_opIdempotentPtr;

class Callback_MyClass_opNonmutating_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opNonmutating_Base> Callback_MyClass_opNonmutatingPtr;

class Callback_MyDerivedClass_opDerived_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyDerivedClass_opDerived_Base> Callback_MyDerivedClass_opDerivedPtr;

}

namespace IceProxy
{

namespace Test
{

class MyClass : virtual public ::IceProxy::Ice::Object
{
public:

    void shutdown()
    {
        shutdown(0);
    }
    void shutdown(const ::Ice::Context& __ctx)
    {
        shutdown(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_shutdown()
    {
        return begin_shutdown(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx)
    {
        return begin_shutdown(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_MyClass_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);
    
private:

    void shutdown(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool shutdown_async(const ::Test::AMI_MyClass_shutdownPtr&);
    bool shutdown_async(const ::Test::AMI_MyClass_shutdownPtr&, const ::Ice::Context&);

    void delay(::Ice::Int ms)
    {
        delay(ms, 0);
    }
    void delay(::Ice::Int ms, const ::Ice::Context& __ctx)
    {
        delay(ms, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_delay(::Ice::Int ms, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_delay(ms, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_delay(::Ice::Int ms, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_delay(ms, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_delay(::Ice::Int ms, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_delay(ms, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_delay(::Ice::Int ms, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_delay(ms, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_delay(::Ice::Int ms)
    {
        return begin_delay(ms, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_delay(::Ice::Int ms, const ::Ice::Context& __ctx)
    {
        return begin_delay(ms, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_delay(::Ice::Int ms, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delay(ms, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delay(::Ice::Int ms, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delay(ms, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delay(::Ice::Int ms, const ::Test::Callback_MyClass_delayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delay(ms, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delay(::Ice::Int ms, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_delayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delay(ms, &__ctx, __del, __cookie);
    }

    void end_delay(const ::Ice::AsyncResultPtr&);
    
private:

    void delay(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_delay(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool delay_async(const ::Test::AMI_MyClass_delayPtr&, ::Ice::Int);
    bool delay_async(const ::Test::AMI_MyClass_delayPtr&, ::Ice::Int, const ::Ice::Context&);

    void opVoid()
    {
        opVoid(0);
    }
    void opVoid(const ::Ice::Context& __ctx)
    {
        opVoid(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVoid(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opVoid(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_opVoid(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVoid(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVoid(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opVoid(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVoid(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVoid(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_opVoid()
    {
        return begin_opVoid(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& __ctx)
    {
        return begin_opVoid(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVoid(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVoid(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Test::Callback_MyClass_opVoidPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVoid(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opVoidPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVoid(&__ctx, __del, __cookie);
    }

    void end_opVoid(const ::Ice::AsyncResultPtr&);
    
private:

    void opVoid(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opVoid_async(const ::Test::AMI_MyClass_opVoidPtr&);
    bool opVoid_async(const ::Test::AMI_MyClass_opVoidPtr&, const ::Ice::Context&);

    ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3)
    {
        return opByte(p1, p2, p3, 0);
    }
    ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3, const ::Ice::Context& __ctx)
    {
        return opByte(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::IceInternal::Function<void (::Ice::Byte, ::Ice::Byte)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByte(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByte(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Byte, ::Ice::Byte)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByte(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByte(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Byte, ::Ice::Byte)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Byte, ::Ice::Byte)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Ice::Byte p3;
                ::Ice::Byte __ret;
                try
                {
                    __ret = __proxy->end_opByte(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Byte, ::Ice::Byte)> _response;
        };
        return begin_opByte(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2)
    {
        return begin_opByte(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& __ctx)
    {
        return begin_opByte(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Test::Callback_MyClass_opBytePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opBytePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::Byte end_opByte(::Ice::Byte& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Byte opByte(::Ice::Byte, ::Ice::Byte, ::Ice::Byte&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte, ::Ice::Byte, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByte_async(const ::Test::AMI_MyClass_opBytePtr&, ::Ice::Byte, ::Ice::Byte);
    bool opByte_async(const ::Test::AMI_MyClass_opBytePtr&, ::Ice::Byte, ::Ice::Byte, const ::Ice::Context&);

    bool opBool(bool p1, bool p2, bool& p3)
    {
        return opBool(p1, p2, p3, 0);
    }
    bool opBool(bool p1, bool p2, bool& p3, const ::Ice::Context& __ctx)
    {
        return opBool(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBool(bool p1, bool p2, const ::IceInternal::Function<void (bool, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBool(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBool(bool p1, bool p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBool(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBool(bool p1, bool p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBool(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBool(bool p1, bool p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBool(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBool(bool p1, bool p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool, bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                bool p3;
                bool __ret;
                try
                {
                    __ret = __proxy->end_opBool(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (bool, bool)> _response;
        };
        return begin_opBool(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2)
    {
        return begin_opBool(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::Context& __ctx)
    {
        return begin_opBool(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Test::Callback_MyClass_opBoolPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opBoolPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, p2, &__ctx, __del, __cookie);
    }

    bool end_opBool(bool& p3, const ::Ice::AsyncResultPtr&);
    
private:

    bool opBool(bool, bool, bool&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBool(bool, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBool_async(const ::Test::AMI_MyClass_opBoolPtr&, bool, bool);
    bool opBool_async(const ::Test::AMI_MyClass_opBoolPtr&, bool, bool, const ::Ice::Context&);

    ::Ice::Long opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, ::Ice::Short& p4, ::Ice::Int& p5, ::Ice::Long& p6)
    {
        return opShortIntLong(p1, p2, p3, p4, p5, p6, 0);
    }
    ::Ice::Long opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, ::Ice::Short& p4, ::Ice::Int& p5, ::Ice::Long& p6, const ::Ice::Context& __ctx)
    {
        return opShortIntLong(p1, p2, p3, p4, p5, p6, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::IceInternal::Function<void (::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntLong(p1, p2, p3, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntLong(p1, p2, p3, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntLong(p1, p2, p3, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntLong(p1, p2, p3, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Ice::Short p4;
                ::Ice::Int p5;
                ::Ice::Long p6;
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_opShortIntLong(p4, p5, p6, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p4, p5, p6);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long)> _response;
        };
        return begin_opShortIntLong(p1, p2, p3, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3)
    {
        return begin_opShortIntLong(p1, p2, p3, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& __ctx)
    {
        return begin_opShortIntLong(p1, p2, p3, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLong(p1, p2, p3, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLong(p1, p2, p3, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Test::Callback_MyClass_opShortIntLongPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLong(p1, p2, p3, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opShortIntLongPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLong(p1, p2, p3, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_opShortIntLong(::Ice::Short& p4, ::Ice::Int& p5, ::Ice::Long& p6, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long opShortIntLong(::Ice::Short, ::Ice::Int, ::Ice::Long, ::Ice::Short&, ::Ice::Int&, ::Ice::Long&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opShortIntLong_async(const ::Test::AMI_MyClass_opShortIntLongPtr&, ::Ice::Short, ::Ice::Int, ::Ice::Long);
    bool opShortIntLong_async(const ::Test::AMI_MyClass_opShortIntLongPtr&, ::Ice::Short, ::Ice::Int, ::Ice::Long, const ::Ice::Context&);

    ::Ice::Double opFloatDouble(::Ice::Float p1, ::Ice::Double p2, ::Ice::Float& p3, ::Ice::Double& p4)
    {
        return opFloatDouble(p1, p2, p3, p4, 0);
    }
    ::Ice::Double opFloatDouble(::Ice::Float p1, ::Ice::Double p2, ::Ice::Float& p3, ::Ice::Double& p4, const ::Ice::Context& __ctx)
    {
        return opFloatDouble(p1, p2, p3, p4, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::IceInternal::Function<void (::Ice::Double, ::Ice::Float, ::Ice::Double)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatDouble(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatDouble(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Double, ::Ice::Float, ::Ice::Double)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatDouble(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatDouble(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Double, ::Ice::Float, ::Ice::Double)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Double, ::Ice::Float, ::Ice::Double)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Ice::Float p3;
                ::Ice::Double p4;
                ::Ice::Double __ret;
                try
                {
                    __ret = __proxy->end_opFloatDouble(p3, p4, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3, p4);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Double, ::Ice::Float, ::Ice::Double)> _response;
        };
        return begin_opFloatDouble(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2)
    {
        return begin_opFloatDouble(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& __ctx)
    {
        return begin_opFloatDouble(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDouble(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDouble(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Test::Callback_MyClass_opFloatDoublePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDouble(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opFloatDoublePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDouble(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::Double end_opFloatDouble(::Ice::Float& p3, ::Ice::Double& p4, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Double opFloatDouble(::Ice::Float, ::Ice::Double, ::Ice::Float&, ::Ice::Double&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float, ::Ice::Double, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opFloatDouble_async(const ::Test::AMI_MyClass_opFloatDoublePtr&, ::Ice::Float, ::Ice::Double);
    bool opFloatDouble_async(const ::Test::AMI_MyClass_opFloatDoublePtr&, ::Ice::Float, ::Ice::Double, const ::Ice::Context&);

    ::std::string opString(const ::std::string& p1, const ::std::string& p2, ::std::string& p3)
    {
        return opString(p1, p2, p3, 0);
    }
    ::std::string opString(const ::std::string& p1, const ::std::string& p2, ::std::string& p3, const ::Ice::Context& __ctx)
    {
        return opString(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opString(const ::std::string& p1, const ::std::string& p2, const ::IceInternal::Function<void (const ::std::string&, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opString(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opString(const ::std::string& p1, const ::std::string& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opString(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opString(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opString(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&, const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::std::string p3;
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_opString(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&, const ::std::string&)> _response;
        };
        return begin_opString(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2)
    {
        return begin_opString(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& __ctx)
    {
        return begin_opString(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Test::Callback_MyClass_opStringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opStringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, p2, &__ctx, __del, __cookie);
    }

    ::std::string end_opString(::std::string& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string opString(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opString(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opString_async(const ::Test::AMI_MyClass_opStringPtr&, const ::std::string&, const ::std::string&);
    bool opString_async(const ::Test::AMI_MyClass_opStringPtr&, const ::std::string&, const ::std::string&, const ::Ice::Context&);

    ::Test::MyEnum opMyEnum(::Test::MyEnum p1, ::Test::MyEnum& p2)
    {
        return opMyEnum(p1, p2, 0);
    }
    ::Test::MyEnum opMyEnum(::Test::MyEnum p1, ::Test::MyEnum& p2, const ::Ice::Context& __ctx)
    {
        return opMyEnum(p1, p2, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opMyEnum(::Test::MyEnum p1, const ::IceInternal::Function<void (::Test::MyEnum, ::Test::MyEnum)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyEnum(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnum(::Test::MyEnum p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyEnum(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Test::MyEnum, ::Test::MyEnum)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyEnum(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyEnum(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Test::MyEnum, ::Test::MyEnum)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Test::MyEnum, ::Test::MyEnum)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::MyEnum p2;
                ::Test::MyEnum __ret;
                try
                {
                    __ret = __proxy->end_opMyEnum(p2, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p2);
                }
            }
        
        private:
            
            ::std::function<void (::Test::MyEnum, ::Test::MyEnum)> _response;
        };
        return begin_opMyEnum(p1, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1)
    {
        return begin_opMyEnum(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& __ctx)
    {
        return begin_opMyEnum(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Test::Callback_MyClass_opMyEnumPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opMyEnumPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, &__ctx, __del, __cookie);
    }

    ::Test::MyEnum end_opMyEnum(::Test::MyEnum& p2, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MyEnum opMyEnum(::Test::MyEnum, ::Test::MyEnum&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opMyEnum_async(const ::Test::AMI_MyClass_opMyEnumPtr&, ::Test::MyEnum);
    bool opMyEnum_async(const ::Test::AMI_MyClass_opMyEnumPtr&, ::Test::MyEnum, const ::Ice::Context&);

    ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx& p1, ::Test::MyClassPrx& p2, ::Test::MyClassPrx& p3)
    {
        return opMyClass(p1, p2, p3, 0);
    }
    ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx& p1, ::Test::MyClassPrx& p2, ::Test::MyClassPrx& p3, const ::Ice::Context& __ctx)
    {
        return opMyClass(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opMyClass(const ::Test::MyClassPrx& p1, const ::IceInternal::Function<void (const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyClass(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyClass(const ::Test::MyClassPrx& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyClass(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyClass(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyClass(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::MyClassPrx p2;
                ::Test::MyClassPrx p3;
                ::Test::MyClassPrx __ret;
                try
                {
                    __ret = __proxy->end_opMyClass(p2, p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p2, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&)> _response;
        };
        return begin_opMyClass(p1, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1)
    {
        return begin_opMyClass(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& __ctx)
    {
        return begin_opMyClass(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyClass(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyClass(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Test::Callback_MyClass_opMyClassPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyClass(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opMyClassPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyClass(p1, &__ctx, __del, __cookie);
    }

    ::Test::MyClassPrx end_opMyClass(::Test::MyClassPrx& p2, ::Test::MyClassPrx& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx&, ::Test::MyClassPrx&, ::Test::MyClassPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opMyClass_async(const ::Test::AMI_MyClass_opMyClassPtr&, const ::Test::MyClassPrx&);
    bool opMyClass_async(const ::Test::AMI_MyClass_opMyClassPtr&, const ::Test::MyClassPrx&, const ::Ice::Context&);

    ::Test::Structure opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, ::Test::Structure& p3)
    {
        return opStruct(p1, p2, p3, 0);
    }
    ::Test::Structure opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, ::Test::Structure& p3, const ::Ice::Context& __ctx)
    {
        return opStruct(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::IceInternal::Function<void (const ::Test::Structure&, const ::Test::Structure&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStruct(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStruct(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::Structure&, const ::Test::Structure&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStruct(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStruct(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::Structure&, const ::Test::Structure&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::Structure&, const ::Test::Structure&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::Structure p3;
                ::Test::Structure __ret;
                try
                {
                    __ret = __proxy->end_opStruct(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::Structure&, const ::Test::Structure&)> _response;
        };
        return begin_opStruct(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2)
    {
        return begin_opStruct(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& __ctx)
    {
        return begin_opStruct(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStruct(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStruct(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Test::Callback_MyClass_opStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStruct(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStruct(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::Structure end_opStruct(::Test::Structure& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::Structure opStruct(const ::Test::Structure&, const ::Test::Structure&, ::Test::Structure&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure&, const ::Test::Structure&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStruct_async(const ::Test::AMI_MyClass_opStructPtr&, const ::Test::Structure&, const ::Test::Structure&);
    bool opStruct_async(const ::Test::AMI_MyClass_opStructPtr&, const ::Test::Structure&, const ::Test::Structure&, const ::Ice::Context&);

    ::Test::ByteS opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, ::Test::ByteS& p3)
    {
        return opByteS(p1, p2, p3, 0);
    }
    ::Test::ByteS opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, ::Test::ByteS& p3, const ::Ice::Context& __ctx)
    {
        return opByteS(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::IceInternal::Function<void (const ::Test::ByteS&, const ::Test::ByteS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ByteS&, const ::Test::ByteS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ByteS&, const ::Test::ByteS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ByteS&, const ::Test::ByteS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::ByteS p3;
                ::Test::ByteS __ret;
                try
                {
                    __ret = __proxy->end_opByteS(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ByteS&, const ::Test::ByteS&)> _response;
        };
        return begin_opByteS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2)
    {
        return begin_opByteS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opByteS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Test::Callback_MyClass_opByteSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opByteSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::ByteS end_opByteS(::Test::ByteS& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ByteS opByteS(const ::Test::ByteS&, const ::Test::ByteS&, ::Test::ByteS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS&, const ::Test::ByteS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteS_async(const ::Test::AMI_MyClass_opByteSPtr&, const ::Test::ByteS&, const ::Test::ByteS&);
    bool opByteS_async(const ::Test::AMI_MyClass_opByteSPtr&, const ::Test::ByteS&, const ::Test::ByteS&, const ::Ice::Context&);

    ::Test::BoolS opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, ::Test::BoolS& p3)
    {
        return opBoolS(p1, p2, p3, 0);
    }
    ::Test::BoolS opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, ::Test::BoolS& p3, const ::Ice::Context& __ctx)
    {
        return opBoolS(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::IceInternal::Function<void (const ::Test::BoolS&, const ::Test::BoolS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BoolS&, const ::Test::BoolS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BoolS&, const ::Test::BoolS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BoolS&, const ::Test::BoolS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::BoolS p3;
                ::Test::BoolS __ret;
                try
                {
                    __ret = __proxy->end_opBoolS(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BoolS&, const ::Test::BoolS&)> _response;
        };
        return begin_opBoolS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2)
    {
        return begin_opBoolS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opBoolS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Test::Callback_MyClass_opBoolSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opBoolSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::BoolS end_opBoolS(::Test::BoolS& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolS opBoolS(const ::Test::BoolS&, const ::Test::BoolS&, ::Test::BoolS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS&, const ::Test::BoolS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolS_async(const ::Test::AMI_MyClass_opBoolSPtr&, const ::Test::BoolS&, const ::Test::BoolS&);
    bool opBoolS_async(const ::Test::AMI_MyClass_opBoolSPtr&, const ::Test::BoolS&, const ::Test::BoolS&, const ::Ice::Context&);

    ::Test::LongS opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, ::Test::ShortS& p4, ::Test::IntS& p5, ::Test::LongS& p6)
    {
        return opShortIntLongS(p1, p2, p3, p4, p5, p6, 0);
    }
    ::Test::LongS opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, ::Test::ShortS& p4, ::Test::IntS& p5, ::Test::LongS& p6, const ::Ice::Context& __ctx)
    {
        return opShortIntLongS(p1, p2, p3, p4, p5, p6, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::IceInternal::Function<void (const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntLongS(p1, p2, p3, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntLongS(p1, p2, p3, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntLongS(p1, p2, p3, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntLongS(p1, p2, p3, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::ShortS p4;
                ::Test::IntS p5;
                ::Test::LongS p6;
                ::Test::LongS __ret;
                try
                {
                    __ret = __proxy->end_opShortIntLongS(p4, p5, p6, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p4, p5, p6);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&)> _response;
        };
        return begin_opShortIntLongS(p1, p2, p3, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3)
    {
        return begin_opShortIntLongS(p1, p2, p3, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& __ctx)
    {
        return begin_opShortIntLongS(p1, p2, p3, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongS(p1, p2, p3, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongS(p1, p2, p3, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Test::Callback_MyClass_opShortIntLongSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongS(p1, p2, p3, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opShortIntLongSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongS(p1, p2, p3, &__ctx, __del, __cookie);
    }

    ::Test::LongS end_opShortIntLongS(::Test::ShortS& p4, ::Test::IntS& p5, ::Test::LongS& p6, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::LongS opShortIntLongS(const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, ::Test::ShortS&, ::Test::IntS&, ::Test::LongS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opShortIntLongS_async(const ::Test::AMI_MyClass_opShortIntLongSPtr&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&);
    bool opShortIntLongS_async(const ::Test::AMI_MyClass_opShortIntLongSPtr&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, const ::Ice::Context&);

    ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, ::Test::FloatS& p3, ::Test::DoubleS& p4)
    {
        return opFloatDoubleS(p1, p2, p3, p4, 0);
    }
    ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, ::Test::FloatS& p3, ::Test::DoubleS& p4, const ::Ice::Context& __ctx)
    {
        return opFloatDoubleS(p1, p2, p3, p4, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::IceInternal::Function<void (const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatDoubleS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatDoubleS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatDoubleS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatDoubleS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::FloatS p3;
                ::Test::DoubleS p4;
                ::Test::DoubleS __ret;
                try
                {
                    __ret = __proxy->end_opFloatDoubleS(p3, p4, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3, p4);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&)> _response;
        };
        return begin_opFloatDoubleS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2)
    {
        return begin_opFloatDoubleS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opFloatDoubleS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Test::Callback_MyClass_opFloatDoubleSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opFloatDoubleSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::DoubleS end_opFloatDoubleS(::Test::FloatS& p3, ::Test::DoubleS& p4, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS&, const ::Test::DoubleS&, ::Test::FloatS&, ::Test::DoubleS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS&, const ::Test::DoubleS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opFloatDoubleS_async(const ::Test::AMI_MyClass_opFloatDoubleSPtr&, const ::Test::FloatS&, const ::Test::DoubleS&);
    bool opFloatDoubleS_async(const ::Test::AMI_MyClass_opFloatDoubleSPtr&, const ::Test::FloatS&, const ::Test::DoubleS&, const ::Ice::Context&);

    ::Test::StringS opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, ::Test::StringS& p3)
    {
        return opStringS(p1, p2, p3, 0);
    }
    ::Test::StringS opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, ::Test::StringS& p3, const ::Ice::Context& __ctx)
    {
        return opStringS(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::IceInternal::Function<void (const ::Test::StringS&, const ::Test::StringS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::StringS&, const ::Test::StringS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::StringS&, const ::Test::StringS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::StringS&, const ::Test::StringS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::StringS p3;
                ::Test::StringS __ret;
                try
                {
                    __ret = __proxy->end_opStringS(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::StringS&, const ::Test::StringS&)> _response;
        };
        return begin_opStringS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2)
    {
        return begin_opStringS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opStringS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Test::Callback_MyClass_opStringSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opStringSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::StringS end_opStringS(::Test::StringS& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::StringS opStringS(const ::Test::StringS&, const ::Test::StringS&, ::Test::StringS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS&, const ::Test::StringS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringS_async(const ::Test::AMI_MyClass_opStringSPtr&, const ::Test::StringS&, const ::Test::StringS&);
    bool opStringS_async(const ::Test::AMI_MyClass_opStringSPtr&, const ::Test::StringS&, const ::Test::StringS&, const ::Ice::Context&);

    ::Test::ByteSS opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, ::Test::ByteSS& p3)
    {
        return opByteSS(p1, p2, p3, 0);
    }
    ::Test::ByteSS opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, ::Test::ByteSS& p3, const ::Ice::Context& __ctx)
    {
        return opByteSS(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::IceInternal::Function<void (const ::Test::ByteSS&, const ::Test::ByteSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteSS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ByteSS&, const ::Test::ByteSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteSS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ByteSS&, const ::Test::ByteSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ByteSS&, const ::Test::ByteSS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::ByteSS p3;
                ::Test::ByteSS __ret;
                try
                {
                    __ret = __proxy->end_opByteSS(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ByteSS&, const ::Test::ByteSS&)> _response;
        };
        return begin_opByteSS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2)
    {
        return begin_opByteSS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opByteSS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Test::Callback_MyClass_opByteSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opByteSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::ByteSS end_opByteSS(::Test::ByteSS& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ByteSS opByteSS(const ::Test::ByteSS&, const ::Test::ByteSS&, ::Test::ByteSS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS&, const ::Test::ByteSS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteSS_async(const ::Test::AMI_MyClass_opByteSSPtr&, const ::Test::ByteSS&, const ::Test::ByteSS&);
    bool opByteSS_async(const ::Test::AMI_MyClass_opByteSSPtr&, const ::Test::ByteSS&, const ::Test::ByteSS&, const ::Ice::Context&);

    ::Test::BoolSS opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, ::Test::BoolSS& p3)
    {
        return opBoolSS(p1, p2, p3, 0);
    }
    ::Test::BoolSS opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, ::Test::BoolSS& p3, const ::Ice::Context& __ctx)
    {
        return opBoolSS(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::IceInternal::Function<void (const ::Test::BoolSS&, const ::Test::BoolSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolSS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolSS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BoolSS&, const ::Test::BoolSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolSS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolSS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BoolSS&, const ::Test::BoolSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BoolSS&, const ::Test::BoolSS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::BoolSS p3;
                ::Test::BoolSS __ret;
                try
                {
                    __ret = __proxy->end_opBoolSS(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BoolSS&, const ::Test::BoolSS&)> _response;
        };
        return begin_opBoolSS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2)
    {
        return begin_opBoolSS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opBoolSS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Test::Callback_MyClass_opBoolSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opBoolSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::BoolSS end_opBoolSS(::Test::BoolSS& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolSS opBoolSS(const ::Test::BoolSS&, const ::Test::BoolSS&, ::Test::BoolSS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS&, const ::Test::BoolSS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolSS_async(const ::Test::AMI_MyClass_opBoolSSPtr&, const ::Test::BoolSS&, const ::Test::BoolSS&);
    bool opBoolSS_async(const ::Test::AMI_MyClass_opBoolSSPtr&, const ::Test::BoolSS&, const ::Test::BoolSS&, const ::Ice::Context&);

    ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, ::Test::ShortSS& p4, ::Test::IntSS& p5, ::Test::LongSS& p6)
    {
        return opShortIntLongSS(p1, p2, p3, p4, p5, p6, 0);
    }
    ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, ::Test::ShortSS& p4, ::Test::IntSS& p5, ::Test::LongSS& p6, const ::Ice::Context& __ctx)
    {
        return opShortIntLongSS(p1, p2, p3, p4, p5, p6, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::IceInternal::Function<void (const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntLongSS(p1, p2, p3, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntLongSS(p1, p2, p3, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntLongSS(p1, p2, p3, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntLongSS(p1, p2, p3, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::ShortSS p4;
                ::Test::IntSS p5;
                ::Test::LongSS p6;
                ::Test::LongSS __ret;
                try
                {
                    __ret = __proxy->end_opShortIntLongSS(p4, p5, p6, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p4, p5, p6);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&)> _response;
        };
        return begin_opShortIntLongSS(p1, p2, p3, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3)
    {
        return begin_opShortIntLongSS(p1, p2, p3, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& __ctx)
    {
        return begin_opShortIntLongSS(p1, p2, p3, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongSS(p1, p2, p3, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongSS(p1, p2, p3, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Test::Callback_MyClass_opShortIntLongSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongSS(p1, p2, p3, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opShortIntLongSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntLongSS(p1, p2, p3, &__ctx, __del, __cookie);
    }

    ::Test::LongSS end_opShortIntLongSS(::Test::ShortSS& p4, ::Test::IntSS& p5, ::Test::LongSS& p6, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, ::Test::ShortSS&, ::Test::IntSS&, ::Test::LongSS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opShortIntLongSS_async(const ::Test::AMI_MyClass_opShortIntLongSSPtr&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&);
    bool opShortIntLongSS_async(const ::Test::AMI_MyClass_opShortIntLongSSPtr&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, const ::Ice::Context&);

    ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, ::Test::FloatSS& p3, ::Test::DoubleSS& p4)
    {
        return opFloatDoubleSS(p1, p2, p3, p4, 0);
    }
    ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, ::Test::FloatSS& p3, ::Test::DoubleSS& p4, const ::Ice::Context& __ctx)
    {
        return opFloatDoubleSS(p1, p2, p3, p4, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::IceInternal::Function<void (const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatDoubleSS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatDoubleSS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatDoubleSS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatDoubleSS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::FloatSS p3;
                ::Test::DoubleSS p4;
                ::Test::DoubleSS __ret;
                try
                {
                    __ret = __proxy->end_opFloatDoubleSS(p3, p4, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3, p4);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&)> _response;
        };
        return begin_opFloatDoubleSS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2)
    {
        return begin_opFloatDoubleSS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opFloatDoubleSS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Test::Callback_MyClass_opFloatDoubleSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opFloatDoubleSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatDoubleSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::DoubleSS end_opFloatDoubleSS(::Test::FloatSS& p3, ::Test::DoubleSS& p4, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS&, const ::Test::DoubleSS&, ::Test::FloatSS&, ::Test::DoubleSS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS&, const ::Test::DoubleSS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opFloatDoubleSS_async(const ::Test::AMI_MyClass_opFloatDoubleSSPtr&, const ::Test::FloatSS&, const ::Test::DoubleSS&);
    bool opFloatDoubleSS_async(const ::Test::AMI_MyClass_opFloatDoubleSSPtr&, const ::Test::FloatSS&, const ::Test::DoubleSS&, const ::Ice::Context&);

    ::Test::StringSS opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, ::Test::StringSS& p3)
    {
        return opStringSS(p1, p2, p3, 0);
    }
    ::Test::StringSS opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, ::Test::StringSS& p3, const ::Ice::Context& __ctx)
    {
        return opStringSS(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::IceInternal::Function<void (const ::Test::StringSS&, const ::Test::StringSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::StringSS&, const ::Test::StringSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::StringSS&, const ::Test::StringSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::StringSS&, const ::Test::StringSS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::StringSS p3;
                ::Test::StringSS __ret;
                try
                {
                    __ret = __proxy->end_opStringSS(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::StringSS&, const ::Test::StringSS&)> _response;
        };
        return begin_opStringSS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2)
    {
        return begin_opStringSS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opStringSS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Test::Callback_MyClass_opStringSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opStringSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::StringSS end_opStringSS(::Test::StringSS& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::StringSS opStringSS(const ::Test::StringSS&, const ::Test::StringSS&, ::Test::StringSS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS&, const ::Test::StringSS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringSS_async(const ::Test::AMI_MyClass_opStringSSPtr&, const ::Test::StringSS&, const ::Test::StringSS&);
    bool opStringSS_async(const ::Test::AMI_MyClass_opStringSSPtr&, const ::Test::StringSS&, const ::Test::StringSS&, const ::Ice::Context&);

    ::Test::StringSSS opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, ::Test::StringSSS& p3)
    {
        return opStringSSS(p1, p2, p3, 0);
    }
    ::Test::StringSSS opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, ::Test::StringSSS& p3, const ::Ice::Context& __ctx)
    {
        return opStringSSS(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::IceInternal::Function<void (const ::Test::StringSSS&, const ::Test::StringSSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSSS(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSSS(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::StringSSS&, const ::Test::StringSSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSSS(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSSS(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::StringSSS&, const ::Test::StringSSS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::StringSSS&, const ::Test::StringSSS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::StringSSS p3;
                ::Test::StringSSS __ret;
                try
                {
                    __ret = __proxy->end_opStringSSS(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::StringSSS&, const ::Test::StringSSS&)> _response;
        };
        return begin_opStringSSS(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2)
    {
        return begin_opStringSSS(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opStringSSS(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Test::Callback_MyClass_opStringSSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSSS(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opStringSSSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSSS(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::StringSSS end_opStringSSS(::Test::StringSSS& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::StringSSS opStringSSS(const ::Test::StringSSS&, const ::Test::StringSSS&, ::Test::StringSSS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS&, const ::Test::StringSSS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringSSS_async(const ::Test::AMI_MyClass_opStringSSSPtr&, const ::Test::StringSSS&, const ::Test::StringSSS&);
    bool opStringSSS_async(const ::Test::AMI_MyClass_opStringSSSPtr&, const ::Test::StringSSS&, const ::Test::StringSSS&, const ::Ice::Context&);

    ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, ::Test::ByteBoolD& p3)
    {
        return opByteBoolD(p1, p2, p3, 0);
    }
    ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, ::Test::ByteBoolD& p3, const ::Ice::Context& __ctx)
    {
        return opByteBoolD(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::IceInternal::Function<void (const ::Test::ByteBoolD&, const ::Test::ByteBoolD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteBoolD(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteBoolD(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ByteBoolD&, const ::Test::ByteBoolD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteBoolD(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteBoolD(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ByteBoolD&, const ::Test::ByteBoolD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ByteBoolD&, const ::Test::ByteBoolD&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::ByteBoolD p3;
                ::Test::ByteBoolD __ret;
                try
                {
                    __ret = __proxy->end_opByteBoolD(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ByteBoolD&, const ::Test::ByteBoolD&)> _response;
        };
        return begin_opByteBoolD(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2)
    {
        return begin_opByteBoolD(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& __ctx)
    {
        return begin_opByteBoolD(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteBoolD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteBoolD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Test::Callback_MyClass_opByteBoolDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteBoolD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opByteBoolDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteBoolD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::ByteBoolD end_opByteBoolD(::Test::ByteBoolD& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, ::Test::ByteBoolD&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteBoolD_async(const ::Test::AMI_MyClass_opByteBoolDPtr&, const ::Test::ByteBoolD&, const ::Test::ByteBoolD&);
    bool opByteBoolD_async(const ::Test::AMI_MyClass_opByteBoolDPtr&, const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, const ::Ice::Context&);

    ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, ::Test::ShortIntD& p3)
    {
        return opShortIntD(p1, p2, p3, 0);
    }
    ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, ::Test::ShortIntD& p3, const ::Ice::Context& __ctx)
    {
        return opShortIntD(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::IceInternal::Function<void (const ::Test::ShortIntD&, const ::Test::ShortIntD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntD(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntD(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ShortIntD&, const ::Test::ShortIntD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortIntD(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortIntD(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ShortIntD&, const ::Test::ShortIntD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ShortIntD&, const ::Test::ShortIntD&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::ShortIntD p3;
                ::Test::ShortIntD __ret;
                try
                {
                    __ret = __proxy->end_opShortIntD(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ShortIntD&, const ::Test::ShortIntD&)> _response;
        };
        return begin_opShortIntD(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2)
    {
        return begin_opShortIntD(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& __ctx)
    {
        return begin_opShortIntD(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Test::Callback_MyClass_opShortIntDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opShortIntDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortIntD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::ShortIntD end_opShortIntD(::Test::ShortIntD& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD&, const ::Test::ShortIntD&, ::Test::ShortIntD&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD&, const ::Test::ShortIntD&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opShortIntD_async(const ::Test::AMI_MyClass_opShortIntDPtr&, const ::Test::ShortIntD&, const ::Test::ShortIntD&);
    bool opShortIntD_async(const ::Test::AMI_MyClass_opShortIntDPtr&, const ::Test::ShortIntD&, const ::Test::ShortIntD&, const ::Ice::Context&);

    ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, ::Test::LongFloatD& p3)
    {
        return opLongFloatD(p1, p2, p3, 0);
    }
    ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, ::Test::LongFloatD& p3, const ::Ice::Context& __ctx)
    {
        return opLongFloatD(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::IceInternal::Function<void (const ::Test::LongFloatD&, const ::Test::LongFloatD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opLongFloatD(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opLongFloatD(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::LongFloatD&, const ::Test::LongFloatD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opLongFloatD(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opLongFloatD(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::LongFloatD&, const ::Test::LongFloatD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::LongFloatD&, const ::Test::LongFloatD&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::LongFloatD p3;
                ::Test::LongFloatD __ret;
                try
                {
                    __ret = __proxy->end_opLongFloatD(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::LongFloatD&, const ::Test::LongFloatD&)> _response;
        };
        return begin_opLongFloatD(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2)
    {
        return begin_opLongFloatD(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& __ctx)
    {
        return begin_opLongFloatD(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongFloatD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongFloatD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Test::Callback_MyClass_opLongFloatDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongFloatD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opLongFloatDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongFloatD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::LongFloatD end_opLongFloatD(::Test::LongFloatD& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD&, const ::Test::LongFloatD&, ::Test::LongFloatD&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD&, const ::Test::LongFloatD&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opLongFloatD_async(const ::Test::AMI_MyClass_opLongFloatDPtr&, const ::Test::LongFloatD&, const ::Test::LongFloatD&);
    bool opLongFloatD_async(const ::Test::AMI_MyClass_opLongFloatDPtr&, const ::Test::LongFloatD&, const ::Test::LongFloatD&, const ::Ice::Context&);

    ::Test::StringStringD opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, ::Test::StringStringD& p3)
    {
        return opStringStringD(p1, p2, p3, 0);
    }
    ::Test::StringStringD opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, ::Test::StringStringD& p3, const ::Ice::Context& __ctx)
    {
        return opStringStringD(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::IceInternal::Function<void (const ::Test::StringStringD&, const ::Test::StringStringD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringStringD(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringStringD(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::StringStringD&, const ::Test::StringStringD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringStringD(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringStringD(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::StringStringD&, const ::Test::StringStringD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::StringStringD&, const ::Test::StringStringD&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::StringStringD p3;
                ::Test::StringStringD __ret;
                try
                {
                    __ret = __proxy->end_opStringStringD(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::StringStringD&, const ::Test::StringStringD&)> _response;
        };
        return begin_opStringStringD(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2)
    {
        return begin_opStringStringD(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& __ctx)
    {
        return begin_opStringStringD(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Test::Callback_MyClass_opStringStringDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opStringStringDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::StringStringD end_opStringStringD(::Test::StringStringD& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::StringStringD opStringStringD(const ::Test::StringStringD&, const ::Test::StringStringD&, ::Test::StringStringD&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD&, const ::Test::StringStringD&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringStringD_async(const ::Test::AMI_MyClass_opStringStringDPtr&, const ::Test::StringStringD&, const ::Test::StringStringD&);
    bool opStringStringD_async(const ::Test::AMI_MyClass_opStringStringDPtr&, const ::Test::StringStringD&, const ::Test::StringStringD&, const ::Ice::Context&);

    ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, ::Test::StringMyEnumD& p3)
    {
        return opStringMyEnumD(p1, p2, p3, 0);
    }
    ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, ::Test::StringMyEnumD& p3, const ::Ice::Context& __ctx)
    {
        return opStringMyEnumD(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::IceInternal::Function<void (const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringMyEnumD(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringMyEnumD(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringMyEnumD(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringMyEnumD(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::StringMyEnumD p3;
                ::Test::StringMyEnumD __ret;
                try
                {
                    __ret = __proxy->end_opStringMyEnumD(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&)> _response;
        };
        return begin_opStringMyEnumD(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2)
    {
        return begin_opStringMyEnumD(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& __ctx)
    {
        return begin_opStringMyEnumD(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringMyEnumD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringMyEnumD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Test::Callback_MyClass_opStringMyEnumDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringMyEnumD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opStringMyEnumDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringMyEnumD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::StringMyEnumD end_opStringMyEnumD(::Test::StringMyEnumD& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, ::Test::StringMyEnumD&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringMyEnumD_async(const ::Test::AMI_MyClass_opStringMyEnumDPtr&, const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&);
    bool opStringMyEnumD_async(const ::Test::AMI_MyClass_opStringMyEnumDPtr&, const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, const ::Ice::Context&);

    ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, ::Test::MyEnumStringD& p3)
    {
        return opMyEnumStringD(p1, p2, p3, 0);
    }
    ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, ::Test::MyEnumStringD& p3, const ::Ice::Context& __ctx)
    {
        return opMyEnumStringD(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::IceInternal::Function<void (const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyEnumStringD(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyEnumStringD(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyEnumStringD(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyEnumStringD(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::MyEnumStringD p3;
                ::Test::MyEnumStringD __ret;
                try
                {
                    __ret = __proxy->end_opMyEnumStringD(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&)> _response;
        };
        return begin_opMyEnumStringD(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2)
    {
        return begin_opMyEnumStringD(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& __ctx)
    {
        return begin_opMyEnumStringD(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnumStringD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnumStringD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Test::Callback_MyClass_opMyEnumStringDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnumStringD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opMyEnumStringDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnumStringD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::MyEnumStringD end_opMyEnumStringD(::Test::MyEnumStringD& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, ::Test::MyEnumStringD&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opMyEnumStringD_async(const ::Test::AMI_MyClass_opMyEnumStringDPtr&, const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&);
    bool opMyEnumStringD_async(const ::Test::AMI_MyClass_opMyEnumStringDPtr&, const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, const ::Ice::Context&);

    ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, ::Test::MyStructMyEnumD& p3)
    {
        return opMyStructMyEnumD(p1, p2, p3, 0);
    }
    ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, ::Test::MyStructMyEnumD& p3, const ::Ice::Context& __ctx)
    {
        return opMyStructMyEnumD(p1, p2, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::IceInternal::Function<void (const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyStructMyEnumD(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyStructMyEnumD(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyStructMyEnumD(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyStructMyEnumD(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::MyStructMyEnumD p3;
                ::Test::MyStructMyEnumD __ret;
                try
                {
                    __ret = __proxy->end_opMyStructMyEnumD(p3, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p3);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&)> _response;
        };
        return begin_opMyStructMyEnumD(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2)
    {
        return begin_opMyStructMyEnumD(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& __ctx)
    {
        return begin_opMyStructMyEnumD(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyStructMyEnumD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyStructMyEnumD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Test::Callback_MyClass_opMyStructMyEnumDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyStructMyEnumD(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opMyStructMyEnumDPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyStructMyEnumD(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::MyStructMyEnumD end_opMyStructMyEnumD(::Test::MyStructMyEnumD& p3, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, ::Test::MyStructMyEnumD&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opMyStructMyEnumD_async(const ::Test::AMI_MyClass_opMyStructMyEnumDPtr&, const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&);
    bool opMyStructMyEnumD_async(const ::Test::AMI_MyClass_opMyStructMyEnumDPtr&, const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, const ::Ice::Context&);

    ::Test::IntS opIntS(const ::Test::IntS& s)
    {
        return opIntS(s, 0);
    }
    ::Test::IntS opIntS(const ::Test::IntS& s, const ::Ice::Context& __ctx)
    {
        return opIntS(s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opIntS(const ::Test::IntS& s, const ::IceInternal::Function<void (const ::Test::IntS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntS(s, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntS(const ::Test::IntS& s, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntS(s, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::IntS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntS(s, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntS(s, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opIntS(const ::Test::IntS& s, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::IntS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::IntS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Test::IntS __ret;
                try
                {
                    __ret = __proxy->end_opIntS(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::IntS&)> _response;
        };
        return begin_opIntS(s, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s)
    {
        return begin_opIntS(s, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& __ctx)
    {
        return begin_opIntS(s, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntS(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntS(s, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Test::Callback_MyClass_opIntSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntS(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opIntSPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntS(s, &__ctx, __del, __cookie);
    }

    ::Test::IntS end_opIntS(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::IntS opIntS(const ::Test::IntS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opIntS_async(const ::Test::AMI_MyClass_opIntSPtr&, const ::Test::IntS&);
    bool opIntS_async(const ::Test::AMI_MyClass_opIntSPtr&, const ::Test::IntS&, const ::Ice::Context&);

    void opByteSOneway(const ::Test::ByteS& s)
    {
        opByteSOneway(s, 0);
    }
    void opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& __ctx)
    {
        opByteSOneway(s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteSOneway(const ::Test::ByteS& s, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opByteSOneway(s, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_opByteSOneway(const ::Test::ByteS& s, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSOneway(s, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opByteSOneway(s, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSOneway(s, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s)
    {
        return begin_opByteSOneway(s, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& __ctx)
    {
        return begin_opByteSOneway(s, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSOneway(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSOneway(s, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Test::Callback_MyClass_opByteSOnewayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSOneway(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opByteSOnewayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSOneway(s, &__ctx, __del, __cookie);
    }

    void end_opByteSOneway(const ::Ice::AsyncResultPtr&);
    
private:

    void opByteSOneway(const ::Test::ByteS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteSOneway_async(const ::Test::AMI_MyClass_opByteSOnewayPtr&, const ::Test::ByteS&);
    bool opByteSOneway_async(const ::Test::AMI_MyClass_opByteSOnewayPtr&, const ::Test::ByteS&, const ::Ice::Context&);

    ::Ice::Context opContext()
    {
        return opContext(0);
    }
    ::Ice::Context opContext(const ::Ice::Context& __ctx)
    {
        return opContext(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opContext(const ::IceInternal::Function<void (const ::Ice::Context&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opContext(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opContext(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opContext(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opContext(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::Context&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opContext(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opContext(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opContext(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opContext(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::Context&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::Context&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
                ::Ice::Context __ret;
                try
                {
                    __ret = __proxy->end_opContext(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::Context&)> _response;
        };
        return begin_opContext(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opContext()
    {
        return begin_opContext(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::Context& __ctx)
    {
        return begin_opContext(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opContext(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opContext(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Test::Callback_MyClass_opContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opContext(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opContext(&__ctx, __del, __cookie);
    }

    ::Ice::Context end_opContext(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Context opContext(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opContext_async(const ::Test::AMI_MyClass_opContextPtr&);
    bool opContext_async(const ::Test::AMI_MyClass_opContextPtr&, const ::Ice::Context&);

    void opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2)
    {
        opDoubleMarshaling(p1, p2, 0);
    }
    void opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx)
    {
        opDoubleMarshaling(p1, p2, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opDoubleMarshaling(p1, p2, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDoubleMarshaling(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opDoubleMarshaling(p1, p2, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDoubleMarshaling(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2)
    {
        return begin_opDoubleMarshaling(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx)
    {
        return begin_opDoubleMarshaling(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleMarshaling(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleMarshaling(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Test::Callback_MyClass_opDoubleMarshalingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleMarshaling(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opDoubleMarshalingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleMarshaling(p1, p2, &__ctx, __del, __cookie);
    }

    void end_opDoubleMarshaling(const ::Ice::AsyncResultPtr&);
    
private:

    void opDoubleMarshaling(::Ice::Double, const ::Test::DoubleS&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double, const ::Test::DoubleS&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opDoubleMarshaling_async(const ::Test::AMI_MyClass_opDoubleMarshalingPtr&, ::Ice::Double, const ::Test::DoubleS&);
    bool opDoubleMarshaling_async(const ::Test::AMI_MyClass_opDoubleMarshalingPtr&, ::Ice::Double, const ::Test::DoubleS&, const ::Ice::Context&);

    void opIdempotent()
    {
        opIdempotent(0);
    }
    void opIdempotent(const ::Ice::Context& __ctx)
    {
        opIdempotent(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opIdempotent(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opIdempotent(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_opIdempotent(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIdempotent(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opIdempotent(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opIdempotent(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opIdempotent(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIdempotent(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_opIdempotent()
    {
        return begin_opIdempotent(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::Context& __ctx)
    {
        return begin_opIdempotent(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIdempotent(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIdempotent(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Test::Callback_MyClass_opIdempotentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIdempotent(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opIdempotentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIdempotent(&__ctx, __del, __cookie);
    }

    void end_opIdempotent(const ::Ice::AsyncResultPtr&);
    
private:

    void opIdempotent(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opIdempotent_async(const ::Test::AMI_MyClass_opIdempotentPtr&);
    bool opIdempotent_async(const ::Test::AMI_MyClass_opIdempotentPtr&, const ::Ice::Context&);

    void opNonmutating()
    {
        opNonmutating(0);
    }
    void opNonmutating(const ::Ice::Context& __ctx)
    {
        opNonmutating(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opNonmutating(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opNonmutating(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_opNonmutating(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opNonmutating(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opNonmutating(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opNonmutating(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opNonmutating(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opNonmutating(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_opNonmutating()
    {
        return begin_opNonmutating(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::Context& __ctx)
    {
        return begin_opNonmutating(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opNonmutating(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opNonmutating(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Test::Callback_MyClass_opNonmutatingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opNonmutating(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::Context& __ctx, const ::Test::Callback_MyClass_opNonmutatingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opNonmutating(&__ctx, __del, __cookie);
    }

    void end_opNonmutating(const ::Ice::AsyncResultPtr&);
    
private:

    void opNonmutating(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opNonmutating_async(const ::Test::AMI_MyClass_opNonmutatingPtr&);
    bool opNonmutating_async(const ::Test::AMI_MyClass_opNonmutatingPtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<MyClass> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_secure(bool __secure) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_twoway() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_oneway() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_batchOneway() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_datagram() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_batchDatagram() const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_compress(bool __compress) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyClass> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MyClass*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MyDerivedClass : virtual public ::IceProxy::Test::MyClass
{
public:

    void opDerived()
    {
        opDerived(0);
    }
    void opDerived(const ::Ice::Context& __ctx)
    {
        opDerived(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opDerived(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opDerived(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_opDerived(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDerived(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDerived(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opDerived(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDerived(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDerived(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_opDerived()
    {
        return begin_opDerived(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::Context& __ctx)
    {
        return begin_opDerived(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerived(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerived(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Test::Callback_MyDerivedClass_opDerivedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerived(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::Context& __ctx, const ::Test::Callback_MyDerivedClass_opDerivedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerived(&__ctx, __del, __cookie);
    }

    void end_opDerived(const ::Ice::AsyncResultPtr&);
    
private:

    void opDerived(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opDerived_async(const ::Test::AMI_MyDerivedClass_opDerivedPtr&);
    bool opDerived_async(const ::Test::AMI_MyDerivedClass_opDerivedPtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_secure(bool __secure) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_twoway() const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_oneway() const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_batchOneway() const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_datagram() const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_batchDatagram() const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_compress(bool __compress) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MyDerivedClass> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MyDerivedClass*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Test
{

class MyClass : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void delay(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void opVoid(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Byte opByte(::Ice::Byte, ::Ice::Byte, ::Ice::Byte&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool opBool(bool, bool, bool&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long opShortIntLong(::Ice::Short, ::Ice::Int, ::Ice::Long, ::Ice::Short&, ::Ice::Int&, ::Ice::Long&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Double opFloatDouble(::Ice::Float, ::Ice::Double, ::Ice::Float&, ::Ice::Double&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string opString(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MyEnum opMyEnum(::Test::MyEnum, ::Test::MyEnum&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx&, ::Test::MyClassPrx&, ::Test::MyClassPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::Structure opStruct(const ::Test::Structure&, const ::Test::Structure&, ::Test::Structure&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ByteS opByteS(const ::Test::ByteS&, const ::Test::ByteS&, ::Test::ByteS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolS opBoolS(const ::Test::BoolS&, const ::Test::BoolS&, ::Test::BoolS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::LongS opShortIntLongS(const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, ::Test::ShortS&, ::Test::IntS&, ::Test::LongS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS&, const ::Test::DoubleS&, ::Test::FloatS&, ::Test::DoubleS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::StringS opStringS(const ::Test::StringS&, const ::Test::StringS&, ::Test::StringS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ByteSS opByteSS(const ::Test::ByteSS&, const ::Test::ByteSS&, ::Test::ByteSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolSS opBoolSS(const ::Test::BoolSS&, const ::Test::BoolSS&, ::Test::BoolSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, ::Test::ShortSS&, ::Test::IntSS&, ::Test::LongSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS&, const ::Test::DoubleSS&, ::Test::FloatSS&, ::Test::DoubleSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::StringSS opStringSS(const ::Test::StringSS&, const ::Test::StringSS&, ::Test::StringSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::StringSSS opStringSSS(const ::Test::StringSSS&, const ::Test::StringSSS&, ::Test::StringSSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, ::Test::ByteBoolD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD&, const ::Test::ShortIntD&, ::Test::ShortIntD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD&, const ::Test::LongFloatD&, ::Test::LongFloatD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::StringStringD opStringStringD(const ::Test::StringStringD&, const ::Test::StringStringD&, ::Test::StringStringD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, ::Test::StringMyEnumD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, ::Test::MyEnumStringD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, ::Test::MyStructMyEnumD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::IntS opIntS(const ::Test::IntS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void opByteSOneway(const ::Test::ByteS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Context opContext(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void opDoubleMarshaling(::Ice::Double, const ::Test::DoubleS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void opIdempotent(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void opNonmutating(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class MyDerivedClass : virtual public ::IceDelegate::Test::MyClass
{
public:

    virtual void opDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

namespace IceDelegateM
{

namespace Test
{

class MyClass : virtual public ::IceDelegate::Test::MyClass,
                virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void delay(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opVoid(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Byte opByte(::Ice::Byte, ::Ice::Byte, ::Ice::Byte&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool opBool(bool, bool, bool&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long opShortIntLong(::Ice::Short, ::Ice::Int, ::Ice::Long, ::Ice::Short&, ::Ice::Int&, ::Ice::Long&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Double opFloatDouble(::Ice::Float, ::Ice::Double, ::Ice::Float&, ::Ice::Double&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string opString(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyEnum opMyEnum(::Test::MyEnum, ::Test::MyEnum&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx&, ::Test::MyClassPrx&, ::Test::MyClassPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::Structure opStruct(const ::Test::Structure&, const ::Test::Structure&, ::Test::Structure&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteS opByteS(const ::Test::ByteS&, const ::Test::ByteS&, ::Test::ByteS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolS opBoolS(const ::Test::BoolS&, const ::Test::BoolS&, ::Test::BoolS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::LongS opShortIntLongS(const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, ::Test::ShortS&, ::Test::IntS&, ::Test::LongS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS&, const ::Test::DoubleS&, ::Test::FloatS&, ::Test::DoubleS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringS opStringS(const ::Test::StringS&, const ::Test::StringS&, ::Test::StringS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteSS opByteSS(const ::Test::ByteSS&, const ::Test::ByteSS&, ::Test::ByteSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSS opBoolSS(const ::Test::BoolSS&, const ::Test::BoolSS&, ::Test::BoolSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, ::Test::ShortSS&, ::Test::IntSS&, ::Test::LongSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS&, const ::Test::DoubleSS&, ::Test::FloatSS&, ::Test::DoubleSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringSS opStringSS(const ::Test::StringSS&, const ::Test::StringSS&, ::Test::StringSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringSSS opStringSSS(const ::Test::StringSSS&, const ::Test::StringSSS&, ::Test::StringSSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, ::Test::ByteBoolD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD&, const ::Test::ShortIntD&, ::Test::ShortIntD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD&, const ::Test::LongFloatD&, ::Test::LongFloatD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringStringD opStringStringD(const ::Test::StringStringD&, const ::Test::StringStringD&, ::Test::StringStringD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, ::Test::StringMyEnumD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, ::Test::MyEnumStringD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, ::Test::MyStructMyEnumD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::IntS opIntS(const ::Test::IntS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opByteSOneway(const ::Test::ByteS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Context opContext(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opDoubleMarshaling(::Ice::Double, const ::Test::DoubleS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opIdempotent(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opNonmutating(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class MyDerivedClass : virtual public ::IceDelegate::Test::MyDerivedClass,
                       virtual public ::IceDelegateM::Test::MyClass
{
public:

    virtual void opDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceDelegateD
{

namespace Test
{

class MyClass : virtual public ::IceDelegate::Test::MyClass,
                virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void delay(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opVoid(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Byte opByte(::Ice::Byte, ::Ice::Byte, ::Ice::Byte&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool opBool(bool, bool, bool&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long opShortIntLong(::Ice::Short, ::Ice::Int, ::Ice::Long, ::Ice::Short&, ::Ice::Int&, ::Ice::Long&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Double opFloatDouble(::Ice::Float, ::Ice::Double, ::Ice::Float&, ::Ice::Double&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string opString(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyEnum opMyEnum(::Test::MyEnum, ::Test::MyEnum&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx&, ::Test::MyClassPrx&, ::Test::MyClassPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::Structure opStruct(const ::Test::Structure&, const ::Test::Structure&, ::Test::Structure&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteS opByteS(const ::Test::ByteS&, const ::Test::ByteS&, ::Test::ByteS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolS opBoolS(const ::Test::BoolS&, const ::Test::BoolS&, ::Test::BoolS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::LongS opShortIntLongS(const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, ::Test::ShortS&, ::Test::IntS&, ::Test::LongS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS&, const ::Test::DoubleS&, ::Test::FloatS&, ::Test::DoubleS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringS opStringS(const ::Test::StringS&, const ::Test::StringS&, ::Test::StringS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteSS opByteSS(const ::Test::ByteSS&, const ::Test::ByteSS&, ::Test::ByteSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSS opBoolSS(const ::Test::BoolSS&, const ::Test::BoolSS&, ::Test::BoolSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, ::Test::ShortSS&, ::Test::IntSS&, ::Test::LongSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS&, const ::Test::DoubleSS&, ::Test::FloatSS&, ::Test::DoubleSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringSS opStringSS(const ::Test::StringSS&, const ::Test::StringSS&, ::Test::StringSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringSSS opStringSSS(const ::Test::StringSSS&, const ::Test::StringSSS&, ::Test::StringSSS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, ::Test::ByteBoolD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD&, const ::Test::ShortIntD&, ::Test::ShortIntD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD&, const ::Test::LongFloatD&, ::Test::LongFloatD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringStringD opStringStringD(const ::Test::StringStringD&, const ::Test::StringStringD&, ::Test::StringStringD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, ::Test::StringMyEnumD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, ::Test::MyEnumStringD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, ::Test::MyStructMyEnumD&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::IntS opIntS(const ::Test::IntS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opByteSOneway(const ::Test::ByteS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Context opContext(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opDoubleMarshaling(::Ice::Double, const ::Test::DoubleS&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opIdempotent(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opNonmutating(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class MyDerivedClass : virtual public ::IceDelegate::Test::MyDerivedClass,
                       virtual public ::IceDelegateD::Test::MyClass
{
public:

    virtual void opDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace Test
{

class MyClass : virtual public ::Ice::Object
{
public:

    typedef MyClassPrx ProxyType;
    typedef MyClassPtr PointerType;

    MyClass()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void delay(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___delay(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opVoid(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVoid(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Byte opByte(::Ice::Byte, ::Ice::Byte, ::Ice::Byte&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByte(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool opBool(bool, bool, bool&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBool(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Long opShortIntLong(::Ice::Short, ::Ice::Int, ::Ice::Long, ::Ice::Short&, ::Ice::Int&, ::Ice::Long&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opShortIntLong(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Double opFloatDouble(::Ice::Float, ::Ice::Double, ::Ice::Float&, ::Ice::Double&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFloatDouble(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string opString(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opString(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MyEnum opMyEnum(::Test::MyEnum, ::Test::MyEnum&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx&, ::Test::MyClassPrx&, ::Test::MyClassPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opMyClass(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::Structure opStruct(const ::Test::Structure&, const ::Test::Structure&, ::Test::Structure&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStruct(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ByteS opByteS(const ::Test::ByteS&, const ::Test::ByteS&, ::Test::ByteS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolS opBoolS(const ::Test::BoolS&, const ::Test::BoolS&, ::Test::BoolS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::LongS opShortIntLongS(const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, ::Test::ShortS&, ::Test::IntS&, ::Test::LongS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opShortIntLongS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS&, const ::Test::DoubleS&, ::Test::FloatS&, ::Test::DoubleS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFloatDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::StringS opStringS(const ::Test::StringS&, const ::Test::StringS&, ::Test::StringS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ByteSS opByteSS(const ::Test::ByteSS&, const ::Test::ByteSS&, ::Test::ByteSS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteSS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolSS opBoolSS(const ::Test::BoolSS&, const ::Test::BoolSS&, ::Test::BoolSS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolSS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, ::Test::ShortSS&, ::Test::IntSS&, ::Test::LongSS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opShortIntLongSS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS&, const ::Test::DoubleSS&, ::Test::FloatSS&, ::Test::DoubleSS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFloatDoubleSS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::StringSS opStringSS(const ::Test::StringSS&, const ::Test::StringSS&, ::Test::StringSS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringSS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::StringSSS opStringSSS(const ::Test::StringSSS&, const ::Test::StringSSS&, ::Test::StringSSS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringSSS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, ::Test::ByteBoolD&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteBoolD(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD&, const ::Test::ShortIntD&, ::Test::ShortIntD&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opShortIntD(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD&, const ::Test::LongFloatD&, ::Test::LongFloatD&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opLongFloatD(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::StringStringD opStringStringD(const ::Test::StringStringD&, const ::Test::StringStringD&, ::Test::StringStringD&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringStringD(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, ::Test::StringMyEnumD&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, ::Test::MyEnumStringD&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opMyEnumStringD(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, ::Test::MyStructMyEnumD&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opMyStructMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::IntS opIntS(const ::Test::IntS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opIntS(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opByteSOneway(const ::Test::ByteS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteSOneway(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Context opContext(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opDoubleMarshaling(::Ice::Double, const ::Test::DoubleS&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opDoubleMarshaling(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opIdempotent(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opNonmutating(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opNonmutating(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const MyClass& l, const MyClass& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MyClass& l, const MyClass& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MyDerivedClass : public ::Test::MyClass
{
public:

    typedef MyDerivedClassPrx ProxyType;
    typedef MyDerivedClassPtr PointerType;

    MyDerivedClass()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void opDerived(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opDerived(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MyClass::__writeImpl;
    using ::Test::MyClass::__readImpl;
    #endif
};

inline bool operator==(const MyDerivedClass& l, const MyDerivedClass& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MyDerivedClass& l, const MyDerivedClass& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Test
{

template<class T>
class CallbackNC_MyClass_shutdown : public Callback_MyClass_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_shutdown : public Callback_MyClass_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_delay : public Callback_MyClass_delay_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_delay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyClass_delayPtr
newCallback_MyClass_delay(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_delay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_delayPtr
newCallback_MyClass_delay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_delay<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyClass_delayPtr
newCallback_MyClass_delay(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_delay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_delayPtr
newCallback_MyClass_delay(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_delay<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_delay : public Callback_MyClass_delay_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_delay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyClass_delayPtr
newCallback_MyClass_delay(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_delay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_delayPtr
newCallback_MyClass_delay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_delay<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_delayPtr
newCallback_MyClass_delay(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_delay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_delayPtr
newCallback_MyClass_delay(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_delay<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opVoid : public Callback_MyClass_opVoid_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opVoid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opVoid : public Callback_MyClass_opVoid_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opVoid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opByte : public Callback_MyClass_opByte_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Byte, ::Ice::Byte);

    CallbackNC_MyClass_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Byte p3;
        ::Ice::Byte __ret;
        try
        {
            __ret = __proxy->end_opByte(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByte<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(T* instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByte<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opByte : public Callback_MyClass_opByte_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Byte, ::Ice::Byte, const CT&);

    Callback_MyClass_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Byte p3;
        ::Ice::Byte __ret;
        try
        {
            __ret = __proxy->end_opByte(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByte<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(T* instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByte<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opBool : public Callback_MyClass_opBool_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, bool);

    CallbackNC_MyClass_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        bool p3;
        bool __ret;
        try
        {
            __ret = __proxy->end_opBool(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBool<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(T* instance, void (T::*cb)(bool, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBool<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opBool : public Callback_MyClass_opBool_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, bool, const CT&);

    Callback_MyClass_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        bool p3;
        bool __ret;
        try
        {
            __ret = __proxy->end_opBool(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBool<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(T* instance, void (T::*cb)(bool, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBool<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opShortIntLong : public Callback_MyClass_opShortIntLong_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long);

    CallbackNC_MyClass_opShortIntLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Short p4;
        ::Ice::Int p5;
        ::Ice::Long p6;
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_opShortIntLong(p4, p5, p6, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p4, p5, p6);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLong<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(T* instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLong<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opShortIntLong : public Callback_MyClass_opShortIntLong_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long, const CT&);

    Callback_MyClass_opShortIntLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Short p4;
        ::Ice::Int p5;
        ::Ice::Long p6;
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_opShortIntLong(p4, p5, p6, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p4, p5, p6, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLong<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(T* instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLong<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opFloatDouble : public Callback_MyClass_opFloatDouble_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Double, ::Ice::Float, ::Ice::Double);

    CallbackNC_MyClass_opFloatDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float p3;
        ::Ice::Double p4;
        ::Ice::Double __ret;
        try
        {
            __ret = __proxy->end_opFloatDouble(p3, p4, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3, p4);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDouble<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(T* instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDouble<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opFloatDouble : public Callback_MyClass_opFloatDouble_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Double, ::Ice::Float, ::Ice::Double, const CT&);

    Callback_MyClass_opFloatDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float p3;
        ::Ice::Double p4;
        ::Ice::Double __ret;
        try
        {
            __ret = __proxy->end_opFloatDouble(p3, p4, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, p4, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDouble<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(T* instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDouble<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opString : public Callback_MyClass_opString_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&);

    CallbackNC_MyClass_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::std::string p3;
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_opString(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opString<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opString<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opString : public Callback_MyClass_opString_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&, const CT&);

    Callback_MyClass_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::std::string p3;
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_opString(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opString<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opString<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opMyEnum : public Callback_MyClass_opMyEnum_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Test::MyEnum, ::Test::MyEnum);

    CallbackNC_MyClass_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyEnum p2;
        ::Test::MyEnum __ret;
        try
        {
            __ret = __proxy->end_opMyEnum(p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p2);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(::Test::MyEnum, ::Test::MyEnum), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnum<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(T* instance, void (T::*cb)(::Test::MyEnum, ::Test::MyEnum), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnum<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opMyEnum : public Callback_MyClass_opMyEnum_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Test::MyEnum, ::Test::MyEnum, const CT&);

    Callback_MyClass_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyEnum p2;
        ::Test::MyEnum __ret;
        try
        {
            __ret = __proxy->end_opMyEnum(p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p2, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(::Test::MyEnum, ::Test::MyEnum, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(T* instance, void (T::*cb)(::Test::MyEnum, ::Test::MyEnum, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opMyClass : public Callback_MyClass_opMyClass_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&);

    CallbackNC_MyClass_opMyClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyClassPrx p2;
        ::Test::MyClassPrx p3;
        ::Test::MyClassPrx __ret;
        try
        {
            __ret = __proxy->end_opMyClass(p2, p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p2, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyClass<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(T* instance, void (T::*cb)(const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyClass<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opMyClass : public Callback_MyClass_opMyClass_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const CT&);

    Callback_MyClass_opMyClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyClassPrx p2;
        ::Test::MyClassPrx p3;
        ::Test::MyClassPrx __ret;
        try
        {
            __ret = __proxy->end_opMyClass(p2, p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p2, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyClass<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(T* instance, void (T::*cb)(const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const ::Test::MyClassPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyClass<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opStruct : public Callback_MyClass_opStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::Structure&, const ::Test::Structure&);

    CallbackNC_MyClass_opStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::Structure p3;
        ::Test::Structure __ret;
        try
        {
            __ret = __proxy->end_opStruct(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::Structure&, const ::Test::Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStruct<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(T* instance, void (T::*cb)(const ::Test::Structure&, const ::Test::Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStruct<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opStruct : public Callback_MyClass_opStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::Structure&, const ::Test::Structure&, const CT&);

    Callback_MyClass_opStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::Structure p3;
        ::Test::Structure __ret;
        try
        {
            __ret = __proxy->end_opStruct(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::Structure&, const ::Test::Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(T* instance, void (T::*cb)(const ::Test::Structure&, const ::Test::Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opByteS : public Callback_MyClass_opByteS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ByteS&, const ::Test::ByteS&);

    CallbackNC_MyClass_opByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteS p3;
        ::Test::ByteS __ret;
        try
        {
            __ret = __proxy->end_opByteS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteS&, const ::Test::ByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(T* instance, void (T::*cb)(const ::Test::ByteS&, const ::Test::ByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opByteS : public Callback_MyClass_opByteS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ByteS&, const ::Test::ByteS&, const CT&);

    Callback_MyClass_opByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteS p3;
        ::Test::ByteS __ret;
        try
        {
            __ret = __proxy->end_opByteS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteS&, const ::Test::ByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(T* instance, void (T::*cb)(const ::Test::ByteS&, const ::Test::ByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opBoolS : public Callback_MyClass_opBoolS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BoolS&, const ::Test::BoolS&);

    CallbackNC_MyClass_opBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolS p3;
        ::Test::BoolS __ret;
        try
        {
            __ret = __proxy->end_opBoolS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolS&, const ::Test::BoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(T* instance, void (T::*cb)(const ::Test::BoolS&, const ::Test::BoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opBoolS : public Callback_MyClass_opBoolS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BoolS&, const ::Test::BoolS&, const CT&);

    Callback_MyClass_opBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolS p3;
        ::Test::BoolS __ret;
        try
        {
            __ret = __proxy->end_opBoolS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolS&, const ::Test::BoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(T* instance, void (T::*cb)(const ::Test::BoolS&, const ::Test::BoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opShortIntLongS : public Callback_MyClass_opShortIntLongS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&);

    CallbackNC_MyClass_opShortIntLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortS p4;
        ::Test::IntS p5;
        ::Test::LongS p6;
        ::Test::LongS __ret;
        try
        {
            __ret = __proxy->end_opShortIntLongS(p4, p5, p6, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p4, p5, p6);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(T* instance, void (T::*cb)(const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opShortIntLongS : public Callback_MyClass_opShortIntLongS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, const CT&);

    Callback_MyClass_opShortIntLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortS p4;
        ::Test::IntS p5;
        ::Test::LongS p6;
        ::Test::LongS __ret;
        try
        {
            __ret = __proxy->end_opShortIntLongS(p4, p5, p6, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p4, p5, p6, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(T* instance, void (T::*cb)(const ::Test::LongS&, const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opFloatDoubleS : public Callback_MyClass_opFloatDoubleS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&);

    CallbackNC_MyClass_opFloatDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::FloatS p3;
        ::Test::DoubleS p4;
        ::Test::DoubleS __ret;
        try
        {
            __ret = __proxy->end_opFloatDoubleS(p3, p4, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3, p4);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(T* instance, void (T::*cb)(const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opFloatDoubleS : public Callback_MyClass_opFloatDoubleS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&, const CT&);

    Callback_MyClass_opFloatDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::FloatS p3;
        ::Test::DoubleS p4;
        ::Test::DoubleS __ret;
        try
        {
            __ret = __proxy->end_opFloatDoubleS(p3, p4, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, p4, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(T* instance, void (T::*cb)(const ::Test::DoubleS&, const ::Test::FloatS&, const ::Test::DoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opStringS : public Callback_MyClass_opStringS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::StringS&, const ::Test::StringS&);

    CallbackNC_MyClass_opStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringS p3;
        ::Test::StringS __ret;
        try
        {
            __ret = __proxy->end_opStringS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringS&, const ::Test::StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(T* instance, void (T::*cb)(const ::Test::StringS&, const ::Test::StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opStringS : public Callback_MyClass_opStringS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::StringS&, const ::Test::StringS&, const CT&);

    Callback_MyClass_opStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringS p3;
        ::Test::StringS __ret;
        try
        {
            __ret = __proxy->end_opStringS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringS&, const ::Test::StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(T* instance, void (T::*cb)(const ::Test::StringS&, const ::Test::StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opByteSS : public Callback_MyClass_opByteSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ByteSS&, const ::Test::ByteSS&);

    CallbackNC_MyClass_opByteSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteSS p3;
        ::Test::ByteSS __ret;
        try
        {
            __ret = __proxy->end_opByteSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteSS&, const ::Test::ByteSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(T* instance, void (T::*cb)(const ::Test::ByteSS&, const ::Test::ByteSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opByteSS : public Callback_MyClass_opByteSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ByteSS&, const ::Test::ByteSS&, const CT&);

    Callback_MyClass_opByteSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteSS p3;
        ::Test::ByteSS __ret;
        try
        {
            __ret = __proxy->end_opByteSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteSS&, const ::Test::ByteSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(T* instance, void (T::*cb)(const ::Test::ByteSS&, const ::Test::ByteSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opBoolSS : public Callback_MyClass_opBoolSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BoolSS&, const ::Test::BoolSS&);

    CallbackNC_MyClass_opBoolSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolSS p3;
        ::Test::BoolSS __ret;
        try
        {
            __ret = __proxy->end_opBoolSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolSS&, const ::Test::BoolSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolSS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(T* instance, void (T::*cb)(const ::Test::BoolSS&, const ::Test::BoolSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolSS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opBoolSS : public Callback_MyClass_opBoolSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BoolSS&, const ::Test::BoolSS&, const CT&);

    Callback_MyClass_opBoolSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolSS p3;
        ::Test::BoolSS __ret;
        try
        {
            __ret = __proxy->end_opBoolSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolSS&, const ::Test::BoolSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(T* instance, void (T::*cb)(const ::Test::BoolSS&, const ::Test::BoolSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opShortIntLongSS : public Callback_MyClass_opShortIntLongSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&);

    CallbackNC_MyClass_opShortIntLongSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortSS p4;
        ::Test::IntSS p5;
        ::Test::LongSS p6;
        ::Test::LongSS __ret;
        try
        {
            __ret = __proxy->end_opShortIntLongSS(p4, p5, p6, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p4, p5, p6);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongSS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(T* instance, void (T::*cb)(const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongSS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opShortIntLongSS : public Callback_MyClass_opShortIntLongSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, const CT&);

    Callback_MyClass_opShortIntLongSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortSS p4;
        ::Test::IntSS p5;
        ::Test::LongSS p6;
        ::Test::LongSS __ret;
        try
        {
            __ret = __proxy->end_opShortIntLongSS(p4, p5, p6, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p4, p5, p6, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(T* instance, void (T::*cb)(const ::Test::LongSS&, const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opFloatDoubleSS : public Callback_MyClass_opFloatDoubleSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&);

    CallbackNC_MyClass_opFloatDoubleSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::FloatSS p3;
        ::Test::DoubleSS p4;
        ::Test::DoubleSS __ret;
        try
        {
            __ret = __proxy->end_opFloatDoubleSS(p3, p4, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3, p4);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleSS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(T* instance, void (T::*cb)(const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleSS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opFloatDoubleSS : public Callback_MyClass_opFloatDoubleSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&, const CT&);

    Callback_MyClass_opFloatDoubleSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::FloatSS p3;
        ::Test::DoubleSS p4;
        ::Test::DoubleSS __ret;
        try
        {
            __ret = __proxy->end_opFloatDoubleSS(p3, p4, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, p4, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(T* instance, void (T::*cb)(const ::Test::DoubleSS&, const ::Test::FloatSS&, const ::Test::DoubleSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opStringSS : public Callback_MyClass_opStringSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::StringSS&, const ::Test::StringSS&);

    CallbackNC_MyClass_opStringSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringSS p3;
        ::Test::StringSS __ret;
        try
        {
            __ret = __proxy->end_opStringSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringSS&, const ::Test::StringSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(T* instance, void (T::*cb)(const ::Test::StringSS&, const ::Test::StringSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opStringSS : public Callback_MyClass_opStringSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::StringSS&, const ::Test::StringSS&, const CT&);

    Callback_MyClass_opStringSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringSS p3;
        ::Test::StringSS __ret;
        try
        {
            __ret = __proxy->end_opStringSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringSS&, const ::Test::StringSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(T* instance, void (T::*cb)(const ::Test::StringSS&, const ::Test::StringSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opStringSSS : public Callback_MyClass_opStringSSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::StringSSS&, const ::Test::StringSSS&);

    CallbackNC_MyClass_opStringSSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringSSS p3;
        ::Test::StringSSS __ret;
        try
        {
            __ret = __proxy->end_opStringSSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringSSS&, const ::Test::StringSSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSSS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(T* instance, void (T::*cb)(const ::Test::StringSSS&, const ::Test::StringSSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSSS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opStringSSS : public Callback_MyClass_opStringSSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::StringSSS&, const ::Test::StringSSS&, const CT&);

    Callback_MyClass_opStringSSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringSSS p3;
        ::Test::StringSSS __ret;
        try
        {
            __ret = __proxy->end_opStringSSS(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringSSS&, const ::Test::StringSSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(T* instance, void (T::*cb)(const ::Test::StringSSS&, const ::Test::StringSSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSSS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opByteBoolD : public Callback_MyClass_opByteBoolD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&);

    CallbackNC_MyClass_opByteBoolD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteBoolD p3;
        ::Test::ByteBoolD __ret;
        try
        {
            __ret = __proxy->end_opByteBoolD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(T* instance, void (T::*cb)(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opByteBoolD : public Callback_MyClass_opByteBoolD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, const CT&);

    Callback_MyClass_opByteBoolD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteBoolD p3;
        ::Test::ByteBoolD __ret;
        try
        {
            __ret = __proxy->end_opByteBoolD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(T* instance, void (T::*cb)(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opShortIntD : public Callback_MyClass_opShortIntD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ShortIntD&, const ::Test::ShortIntD&);

    CallbackNC_MyClass_opShortIntD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortIntD p3;
        ::Test::ShortIntD __ret;
        try
        {
            __ret = __proxy->end_opShortIntD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ShortIntD&, const ::Test::ShortIntD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntD<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(T* instance, void (T::*cb)(const ::Test::ShortIntD&, const ::Test::ShortIntD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntD<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opShortIntD : public Callback_MyClass_opShortIntD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ShortIntD&, const ::Test::ShortIntD&, const CT&);

    Callback_MyClass_opShortIntD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortIntD p3;
        ::Test::ShortIntD __ret;
        try
        {
            __ret = __proxy->end_opShortIntD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ShortIntD&, const ::Test::ShortIntD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntD<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(T* instance, void (T::*cb)(const ::Test::ShortIntD&, const ::Test::ShortIntD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntD<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opLongFloatD : public Callback_MyClass_opLongFloatD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::LongFloatD&, const ::Test::LongFloatD&);

    CallbackNC_MyClass_opLongFloatD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::LongFloatD p3;
        ::Test::LongFloatD __ret;
        try
        {
            __ret = __proxy->end_opLongFloatD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::LongFloatD&, const ::Test::LongFloatD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongFloatD<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(T* instance, void (T::*cb)(const ::Test::LongFloatD&, const ::Test::LongFloatD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongFloatD<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opLongFloatD : public Callback_MyClass_opLongFloatD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::LongFloatD&, const ::Test::LongFloatD&, const CT&);

    Callback_MyClass_opLongFloatD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::LongFloatD p3;
        ::Test::LongFloatD __ret;
        try
        {
            __ret = __proxy->end_opLongFloatD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::LongFloatD&, const ::Test::LongFloatD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongFloatD<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(T* instance, void (T::*cb)(const ::Test::LongFloatD&, const ::Test::LongFloatD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongFloatD<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opStringStringD : public Callback_MyClass_opStringStringD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::StringStringD&, const ::Test::StringStringD&);

    CallbackNC_MyClass_opStringStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringStringD p3;
        ::Test::StringStringD __ret;
        try
        {
            __ret = __proxy->end_opStringStringD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringStringD&, const ::Test::StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringD<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(T* instance, void (T::*cb)(const ::Test::StringStringD&, const ::Test::StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringD<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opStringStringD : public Callback_MyClass_opStringStringD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::StringStringD&, const ::Test::StringStringD&, const CT&);

    Callback_MyClass_opStringStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringStringD p3;
        ::Test::StringStringD __ret;
        try
        {
            __ret = __proxy->end_opStringStringD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringStringD&, const ::Test::StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringD<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(T* instance, void (T::*cb)(const ::Test::StringStringD&, const ::Test::StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringD<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opStringMyEnumD : public Callback_MyClass_opStringMyEnumD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&);

    CallbackNC_MyClass_opStringMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringMyEnumD p3;
        ::Test::StringMyEnumD __ret;
        try
        {
            __ret = __proxy->end_opStringMyEnumD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringMyEnumD<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(T* instance, void (T::*cb)(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringMyEnumD<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opStringMyEnumD : public Callback_MyClass_opStringMyEnumD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, const CT&);

    Callback_MyClass_opStringMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::StringMyEnumD p3;
        ::Test::StringMyEnumD __ret;
        try
        {
            __ret = __proxy->end_opStringMyEnumD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(T* instance, void (T::*cb)(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opMyEnumStringD : public Callback_MyClass_opMyEnumStringD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&);

    CallbackNC_MyClass_opMyEnumStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyEnumStringD p3;
        ::Test::MyEnumStringD __ret;
        try
        {
            __ret = __proxy->end_opMyEnumStringD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumStringD<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(T* instance, void (T::*cb)(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumStringD<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opMyEnumStringD : public Callback_MyClass_opMyEnumStringD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, const CT&);

    Callback_MyClass_opMyEnumStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyEnumStringD p3;
        ::Test::MyEnumStringD __ret;
        try
        {
            __ret = __proxy->end_opMyEnumStringD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumStringD<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(T* instance, void (T::*cb)(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumStringD<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opMyStructMyEnumD : public Callback_MyClass_opMyStructMyEnumD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&);

    CallbackNC_MyClass_opMyStructMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyStructMyEnumD p3;
        ::Test::MyStructMyEnumD __ret;
        try
        {
            __ret = __proxy->end_opMyStructMyEnumD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p3);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyStructMyEnumD<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(T* instance, void (T::*cb)(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyStructMyEnumD<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opMyStructMyEnumD : public Callback_MyClass_opMyStructMyEnumD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, const CT&);

    Callback_MyClass_opMyStructMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::MyStructMyEnumD p3;
        ::Test::MyStructMyEnumD __ret;
        try
        {
            __ret = __proxy->end_opMyStructMyEnumD(p3, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyStructMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(T* instance, void (T::*cb)(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyStructMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opIntS : public Callback_MyClass_opIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::IntS&);

    CallbackNC_MyClass_opIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::IntS __ret;
        try
        {
            __ret = __proxy->end_opIntS(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::IntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIntS<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(T* instance, void (T::*cb)(const ::Test::IntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIntS<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opIntS : public Callback_MyClass_opIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::IntS&, const CT&);

    Callback_MyClass_opIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Test::IntS __ret;
        try
        {
            __ret = __proxy->end_opIntS(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::IntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIntS<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(T* instance, void (T::*cb)(const ::Test::IntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIntS<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opByteSOneway : public Callback_MyClass_opByteSOneway_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opByteSOneway(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opByteSOneway : public Callback_MyClass_opByteSOneway_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opByteSOneway(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opContext : public Callback_MyClass_opContext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::Context&);

    CallbackNC_MyClass_opContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Context __ret;
        try
        {
            __ret = __proxy->end_opContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::Context&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(T* instance, void (T::*cb)(const ::Ice::Context&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opContext<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opContext : public Callback_MyClass_opContext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::Context&, const CT&);

    Callback_MyClass_opContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MyClassPrx __proxy = ::Test::MyClassPrx::uncheckedCast(__result->getProxy());
        ::Ice::Context __ret;
        try
        {
            __ret = __proxy->end_opContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::Context&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(T* instance, void (T::*cb)(const ::Ice::Context&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opDoubleMarshaling : public Callback_MyClass_opDoubleMarshaling_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opDoubleMarshaling(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opDoubleMarshaling : public Callback_MyClass_opDoubleMarshaling_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opDoubleMarshaling(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opIdempotent : public Callback_MyClass_opIdempotent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opIdempotent : public Callback_MyClass_opIdempotent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MyClass_opNonmutating : public Callback_MyClass_opNonmutating_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opNonmutating(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyClass_opNonmutating : public Callback_MyClass_opNonmutating_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opNonmutating(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MyDerivedClass_opDerived : public Callback_MyDerivedClass_opDerived_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyDerivedClass_opDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MyDerivedClass_opDerived : public Callback_MyDerivedClass_opDerived_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyDerivedClass_opDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, 0, excb, sentcb);
}

}

#endif
