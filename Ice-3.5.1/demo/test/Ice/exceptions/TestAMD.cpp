// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <TestAMD.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Test__Thrower__shutdown_name = "shutdown";

const ::std::string __Test__Thrower__supportsUndeclaredExceptions_name = "supportsUndeclaredExceptions";

const ::std::string __Test__Thrower__supportsAssertException_name = "supportsAssertException";

const ::std::string __Test__Thrower__throwAasA_name = "throwAasA";

const ::std::string __Test__Thrower__throwAorDasAorD_name = "throwAorDasAorD";

const ::std::string __Test__Thrower__throwBasA_name = "throwBasA";

const ::std::string __Test__Thrower__throwCasA_name = "throwCasA";

const ::std::string __Test__Thrower__throwBasB_name = "throwBasB";

const ::std::string __Test__Thrower__throwCasB_name = "throwCasB";

const ::std::string __Test__Thrower__throwCasC_name = "throwCasC";

const ::std::string __Test__Thrower__throwModA_name = "throwModA";

const ::std::string __Test__Thrower__throwUndeclaredA_name = "throwUndeclaredA";

const ::std::string __Test__Thrower__throwUndeclaredB_name = "throwUndeclaredB";

const ::std::string __Test__Thrower__throwUndeclaredC_name = "throwUndeclaredC";

const ::std::string __Test__Thrower__throwLocalException_name = "throwLocalException";

const ::std::string __Test__Thrower__throwNonIceException_name = "throwNonIceException";

const ::std::string __Test__Thrower__throwAssertException_name = "throwAssertException";

const ::std::string __Test__Thrower__throwMemoryLimitException_name = "throwMemoryLimitException";

const ::std::string __Test__Thrower__throwLocalExceptionIdempotent_name = "throwLocalExceptionIdempotent";

const ::std::string __Test__Thrower__throwAfterResponse_name = "throwAfterResponse";

const ::std::string __Test__Thrower__throwAfterException_name = "throwAfterException";

const ::std::string __Test__Thrower__throwE_name = "throwE";

const ::std::string __Test__Thrower__throwF_name = "throwF";

const ::std::string __Test__Thrower__throwG_name = "throwG";

const ::std::string __Test__Thrower__throwH_name = "throwH";

const ::std::string __Test__WrongOperation__noSuchOperation_name = "noSuchOperation";

}

namespace
{

const char* __Test__A_name = "Test::A";

struct __F__Test__A : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::A();
    }
};

class __F__Test__A__Init
{
public:

    __F__Test__A__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::A", new __F__Test__A);
    }

    ~__F__Test__A__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::A");
    }
};

const __F__Test__A__Init __F__Test__A__i;

}

Test::A::A(::Ice::Int __ice_aMem) :
    ::Ice::UserException(),
    aMem(__ice_aMem)
{
}

Test::A::~A() throw()
{
}

::std::string
Test::A::ice_name() const
{
    return __Test__A_name;
}

Test::A*
Test::A::ice_clone() const
{
    return new A(*this);
}

void
Test::A::ice_throw() const
{
    throw *this;
}

void
Test::A::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::A", -1, true);
    __os->write(aMem);
    __os->endWriteSlice();
}

void
Test::A::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(aMem);
    __is->endReadSlice();
}

namespace
{

const char* __Test__B_name = "Test::B";

struct __F__Test__B : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::B();
    }
};

class __F__Test__B__Init
{
public:

    __F__Test__B__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::B", new __F__Test__B);
    }

    ~__F__Test__B__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::B");
    }
};

const __F__Test__B__Init __F__Test__B__i;

}

Test::B::B(::Ice::Int __ice_aMem, ::Ice::Int __ice_bMem) :
    ::Test::A(__ice_aMem),
    bMem(__ice_bMem)
{
}

Test::B::~B() throw()
{
}

::std::string
Test::B::ice_name() const
{
    return __Test__B_name;
}

Test::B*
Test::B::ice_clone() const
{
    return new B(*this);
}

void
Test::B::ice_throw() const
{
    throw *this;
}

void
Test::B::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::B", -1, false);
    __os->write(bMem);
    __os->endWriteSlice();
    ::Test::A::__writeImpl(__os);
}

void
Test::B::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(bMem);
    __is->endReadSlice();
    ::Test::A::__readImpl(__is);
}

namespace
{

const char* __Test__C_name = "Test::C";

struct __F__Test__C : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::C();
    }
};

class __F__Test__C__Init
{
public:

    __F__Test__C__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::C", new __F__Test__C);
    }

    ~__F__Test__C__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::C");
    }
};

const __F__Test__C__Init __F__Test__C__i;

}

Test::C::C(::Ice::Int __ice_aMem, ::Ice::Int __ice_bMem, ::Ice::Int __ice_cMem) :
    ::Test::B(__ice_aMem, __ice_bMem),
    cMem(__ice_cMem)
{
}

Test::C::~C() throw()
{
}

::std::string
Test::C::ice_name() const
{
    return __Test__C_name;
}

Test::C*
Test::C::ice_clone() const
{
    return new C(*this);
}

void
Test::C::ice_throw() const
{
    throw *this;
}

void
Test::C::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::C", -1, false);
    __os->write(cMem);
    __os->endWriteSlice();
    ::Test::B::__writeImpl(__os);
}

void
Test::C::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(cMem);
    __is->endReadSlice();
    ::Test::B::__readImpl(__is);
}

namespace
{

const char* __Test__D_name = "Test::D";

struct __F__Test__D : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::D();
    }
};

class __F__Test__D__Init
{
public:

    __F__Test__D__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::D", new __F__Test__D);
    }

    ~__F__Test__D__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::D");
    }
};

const __F__Test__D__Init __F__Test__D__i;

}

Test::D::D(::Ice::Int __ice_dMem) :
    ::Ice::UserException(),
    dMem(__ice_dMem)
{
}

Test::D::~D() throw()
{
}

::std::string
Test::D::ice_name() const
{
    return __Test__D_name;
}

Test::D*
Test::D::ice_clone() const
{
    return new D(*this);
}

void
Test::D::ice_throw() const
{
    throw *this;
}

void
Test::D::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::D", -1, true);
    __os->write(dMem);
    __os->endWriteSlice();
}

void
Test::D::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(dMem);
    __is->endReadSlice();
}

namespace
{

const char* __Test__E_name = "Test::E";

struct __F__Test__E : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::E();
    }
};

class __F__Test__E__Init
{
public:

    __F__Test__E__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::E", new __F__Test__E);
    }

    ~__F__Test__E__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::E");
    }
};

const __F__Test__E__Init __F__Test__E__i;

}

Test::E::E(const ::std::string& __ice_data) :
    ::Ice::UserException(),
    data(__ice_data)
{
}

Test::E::~E() throw()
{
}

::std::string
Test::E::ice_name() const
{
    return __Test__E_name;
}

Test::E*
Test::E::ice_clone() const
{
    return new E(*this);
}

void
Test::E::ice_throw() const
{
    throw *this;
}

void
Test::E::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::E", -1, true);
    __os->write(data);
    __os->endWriteSlice();
}

void
Test::E::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(data);
    __is->endReadSlice();
}

namespace
{

const char* __Test__F_name = "Test::F";

struct __F__Test__F : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::F();
    }
};

class __F__Test__F__Init
{
public:

    __F__Test__F__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::F", new __F__Test__F);
    }

    ~__F__Test__F__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::F");
    }
};

const __F__Test__F__Init __F__Test__F__i;

}

Test::F::F(const ::std::string& __ice_data) :
    ::Ice::UserException(),
    data(__ice_data)
{
}

Test::F::~F() throw()
{
}

::std::string
Test::F::ice_name() const
{
    return __Test__F_name;
}

Test::F*
Test::F::ice_clone() const
{
    return new F(*this);
}

void
Test::F::ice_throw() const
{
    throw *this;
}

void
Test::F::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::F", -1, true);
    __os->write(data);
    __os->endWriteSlice();
}

void
Test::F::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(data);
    __is->endReadSlice();
}

namespace
{

const char* __Test__G_name = "Test::G";

}

Test::G::G(const char* __file, int __line) :
    ::Ice::LocalException(__file, __line)
{
}

Test::G::G(const char* __file, int __line, const ::std::string& __ice_data) :
    ::Ice::LocalException(__file, __line),
    data(__ice_data)
{
}

Test::G::~G() throw()
{
}

::std::string
Test::G::ice_name() const
{
    return __Test__G_name;
}

Test::G*
Test::G::ice_clone() const
{
    return new G(*this);
}

void
Test::G::ice_throw() const
{
    throw *this;
}

namespace
{

const char* __Test__H_name = "Test::H";

}

Test::H::H(const char* __file, int __line) :
    ::Ice::LocalException(__file, __line)
{
}

Test::H::H(const char* __file, int __line, const ::std::string& __ice_data) :
    ::Ice::LocalException(__file, __line),
    data(__ice_data)
{
}

Test::H::~H() throw()
{
}

::std::string
Test::H::ice_name() const
{
    return __Test__H_name;
}

Test::H*
Test::H::ice_clone() const
{
    return new H(*this);
}

void
Test::H::ice_throw() const
{
    throw *this;
}

namespace
{

const char* __Test__Mod__A_name = "Test::Mod::A";

struct __F__Test__Mod__A : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Mod::A();
    }
};

class __F__Test__Mod__A__Init
{
public:

    __F__Test__Mod__A__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Mod::A", new __F__Test__Mod__A);
    }

    ~__F__Test__Mod__A__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Mod::A");
    }
};

const __F__Test__Mod__A__Init __F__Test__Mod__A__i;

}

Test::Mod::A::A(::Ice::Int __ice_aMem, ::Ice::Int __ice_a2Mem) :
    ::Test::A(__ice_aMem),
    a2Mem(__ice_a2Mem)
{
}

Test::Mod::A::~A() throw()
{
}

::std::string
Test::Mod::A::ice_name() const
{
    return __Test__Mod__A_name;
}

Test::Mod::A*
Test::Mod::A::ice_clone() const
{
    return new A(*this);
}

void
Test::Mod::A::ice_throw() const
{
    throw *this;
}

void
Test::Mod::A::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Mod::A", -1, false);
    __os->write(a2Mem);
    __os->endWriteSlice();
    ::Test::A::__writeImpl(__os);
}

void
Test::Mod::A::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(a2Mem);
    __is->endReadSlice();
    ::Test::A::__readImpl(__is);
}

namespace Ice
{
}

IceAsync::Test::AMD_Thrower_shutdown::AMD_Thrower_shutdown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_shutdown::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_supportsUndeclaredExceptions::AMD_Thrower_supportsUndeclaredExceptions(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_supportsUndeclaredExceptions::ice_response(bool __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_Thrower_supportsAssertException::AMD_Thrower_supportsAssertException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_supportsAssertException::ice_response(bool __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwAasA::AMD_Thrower_throwAasA(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwAasA::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwAasA::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::A* __ex = dynamic_cast<const ::Test::A*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwAorDasAorD::AMD_Thrower_throwAorDasAorD(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwAorDasAorD::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwAorDasAorD::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::A* __ex = dynamic_cast<const ::Test::A*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Test::D* __ex = dynamic_cast<const ::Test::D*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwBasA::AMD_Thrower_throwBasA(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwBasA::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwBasA::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::A* __ex = dynamic_cast<const ::Test::A*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwCasA::AMD_Thrower_throwCasA(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwCasA::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwCasA::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::A* __ex = dynamic_cast<const ::Test::A*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwBasB::AMD_Thrower_throwBasB(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwBasB::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwBasB::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::B* __ex = dynamic_cast<const ::Test::B*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwCasB::AMD_Thrower_throwCasB(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwCasB::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwCasB::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::B* __ex = dynamic_cast<const ::Test::B*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwCasC::AMD_Thrower_throwCasC(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwCasC::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwCasC::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::C* __ex = dynamic_cast<const ::Test::C*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwModA::AMD_Thrower_throwModA(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwModA::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwModA::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Mod::A* __ex = dynamic_cast<const ::Test::Mod::A*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwUndeclaredA::AMD_Thrower_throwUndeclaredA(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwUndeclaredA::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwUndeclaredB::AMD_Thrower_throwUndeclaredB(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwUndeclaredB::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwUndeclaredC::AMD_Thrower_throwUndeclaredC(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwUndeclaredC::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwLocalException::AMD_Thrower_throwLocalException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwLocalException::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwNonIceException::AMD_Thrower_throwNonIceException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwNonIceException::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwAssertException::AMD_Thrower_throwAssertException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwAssertException::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwMemoryLimitException::AMD_Thrower_throwMemoryLimitException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwMemoryLimitException::ice_response(const ::Ice::ByteSeq& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwLocalExceptionIdempotent::AMD_Thrower_throwLocalExceptionIdempotent(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwLocalExceptionIdempotent::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwAfterResponse::AMD_Thrower_throwAfterResponse(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwAfterResponse::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwAfterException::AMD_Thrower_throwAfterException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwAfterException::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwAfterException::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::A* __ex = dynamic_cast<const ::Test::A*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwE::AMD_Thrower_throwE(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwE::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwE::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::E* __ex = dynamic_cast<const ::Test::E*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwF::AMD_Thrower_throwF(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwF::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_Thrower_throwF::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::F* __ex = dynamic_cast<const ::Test::F*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_Thrower_throwG::AMD_Thrower_throwG(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwG::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_Thrower_throwH::AMD_Thrower_throwH(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_Thrower_throwH::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_WrongOperation_noSuchOperation::AMD_WrongOperation_noSuchOperation(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_WrongOperation_noSuchOperation::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Empty* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Empty>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Empty;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Empty::ice_staticId()
{
    return ::Test::Empty::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Empty::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Empty);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Empty::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Empty);
}

::IceProxy::Ice::Object*
IceProxy::Test::Empty::__newInstance() const
{
    return new Empty;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Thrower* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Thrower>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Thrower;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::Thrower::shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__shutdown_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__shutdown_name);
}

bool
IceProxy::Test::Thrower::shutdown_async(const ::Test::AMI_Thrower_shutdownPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_shutdown(__cb, &::Test::AMI_Thrower_shutdown::__response, &::Test::AMI_Thrower_shutdown::__exception, &::Test::AMI_Thrower_shutdown::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_shutdown(__cb, &::Test::AMI_Thrower_shutdown::__response, &::Test::AMI_Thrower_shutdown::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_shutdown(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::shutdown_async(const ::Test::AMI_Thrower_shutdownPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_shutdown(__cb, &::Test::AMI_Thrower_shutdown::__response, &::Test::AMI_Thrower_shutdown::__exception, &::Test::AMI_Thrower_shutdown::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_shutdown(__cb, &::Test::AMI_Thrower_shutdown::__response, &::Test::AMI_Thrower_shutdown::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_shutdown(&__ctx, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::supportsUndeclaredExceptions(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__supportsUndeclaredExceptions_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__supportsUndeclaredExceptions_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            return __del->supportsUndeclaredExceptions(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__supportsUndeclaredExceptions_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__supportsUndeclaredExceptions_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__supportsUndeclaredExceptions_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Test::Thrower::end_supportsUndeclaredExceptions(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__supportsUndeclaredExceptions_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::supportsUndeclaredExceptions_async(const ::Test::AMI_Thrower_supportsUndeclaredExceptionsPtr& __cb)
{
    ::Test::Callback_Thrower_supportsUndeclaredExceptionsPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_supportsUndeclaredExceptions(__cb, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__response, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__exception, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_supportsUndeclaredExceptions(__cb, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__response, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__supportsUndeclaredExceptions_name);
        __ar = begin_supportsUndeclaredExceptions(0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__supportsUndeclaredExceptions_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::supportsUndeclaredExceptions_async(const ::Test::AMI_Thrower_supportsUndeclaredExceptionsPtr& __cb, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_supportsUndeclaredExceptionsPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_supportsUndeclaredExceptions(__cb, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__response, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__exception, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_supportsUndeclaredExceptions(__cb, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__response, &::Test::AMI_Thrower_supportsUndeclaredExceptions::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__supportsUndeclaredExceptions_name);
        __ar = begin_supportsUndeclaredExceptions(&__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__supportsUndeclaredExceptions_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::supportsAssertException(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__supportsAssertException_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__supportsAssertException_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            return __del->supportsAssertException(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_supportsAssertException(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__supportsAssertException_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__supportsAssertException_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__supportsAssertException_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Test::Thrower::end_supportsAssertException(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__supportsAssertException_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::supportsAssertException_async(const ::Test::AMI_Thrower_supportsAssertExceptionPtr& __cb)
{
    ::Test::Callback_Thrower_supportsAssertExceptionPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_supportsAssertException(__cb, &::Test::AMI_Thrower_supportsAssertException::__response, &::Test::AMI_Thrower_supportsAssertException::__exception, &::Test::AMI_Thrower_supportsAssertException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_supportsAssertException(__cb, &::Test::AMI_Thrower_supportsAssertException::__response, &::Test::AMI_Thrower_supportsAssertException::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__supportsAssertException_name);
        __ar = begin_supportsAssertException(0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__supportsAssertException_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::supportsAssertException_async(const ::Test::AMI_Thrower_supportsAssertExceptionPtr& __cb, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_supportsAssertExceptionPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_supportsAssertException(__cb, &::Test::AMI_Thrower_supportsAssertException::__response, &::Test::AMI_Thrower_supportsAssertException::__exception, &::Test::AMI_Thrower_supportsAssertException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_supportsAssertException(__cb, &::Test::AMI_Thrower_supportsAssertException::__response, &::Test::AMI_Thrower_supportsAssertException::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__supportsAssertException_name);
        __ar = begin_supportsAssertException(&__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__supportsAssertException_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwAasA(::Ice::Int a, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwAasA_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwAasA_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwAasA(a, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwAasA(::Ice::Int a, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwAasA_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAasA_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwAasA_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwAasA(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwAasA_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwAasA_async(const ::Test::AMI_Thrower_throwAasAPtr& __cb, ::Ice::Int a)
{
    ::Test::Callback_Thrower_throwAasAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAasA(__cb, &::Test::AMI_Thrower_throwAasA::__response, &::Test::AMI_Thrower_throwAasA::__exception, &::Test::AMI_Thrower_throwAasA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAasA(__cb, &::Test::AMI_Thrower_throwAasA::__response, &::Test::AMI_Thrower_throwAasA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwAasA_name);
        __ar = begin_throwAasA(a, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAasA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwAasA_async(const ::Test::AMI_Thrower_throwAasAPtr& __cb, ::Ice::Int a, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwAasAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAasA(__cb, &::Test::AMI_Thrower_throwAasA::__response, &::Test::AMI_Thrower_throwAasA::__exception, &::Test::AMI_Thrower_throwAasA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAasA(__cb, &::Test::AMI_Thrower_throwAasA::__response, &::Test::AMI_Thrower_throwAasA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwAasA_name);
        __ar = begin_throwAasA(a, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAasA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwAorDasAorD(::Ice::Int a, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwAorDasAorD_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwAorDasAorD_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwAorDasAorD(a, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwAorDasAorD(::Ice::Int a, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwAorDasAorD_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAorDasAorD_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwAorDasAorD_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwAorDasAorD(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwAorDasAorD_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Test::D&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwAorDasAorD_async(const ::Test::AMI_Thrower_throwAorDasAorDPtr& __cb, ::Ice::Int a)
{
    ::Test::Callback_Thrower_throwAorDasAorDPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAorDasAorD(__cb, &::Test::AMI_Thrower_throwAorDasAorD::__response, &::Test::AMI_Thrower_throwAorDasAorD::__exception, &::Test::AMI_Thrower_throwAorDasAorD::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAorDasAorD(__cb, &::Test::AMI_Thrower_throwAorDasAorD::__response, &::Test::AMI_Thrower_throwAorDasAorD::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwAorDasAorD_name);
        __ar = begin_throwAorDasAorD(a, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAorDasAorD_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwAorDasAorD_async(const ::Test::AMI_Thrower_throwAorDasAorDPtr& __cb, ::Ice::Int a, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwAorDasAorDPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAorDasAorD(__cb, &::Test::AMI_Thrower_throwAorDasAorD::__response, &::Test::AMI_Thrower_throwAorDasAorD::__exception, &::Test::AMI_Thrower_throwAorDasAorD::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAorDasAorD(__cb, &::Test::AMI_Thrower_throwAorDasAorD::__response, &::Test::AMI_Thrower_throwAorDasAorD::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwAorDasAorD_name);
        __ar = begin_throwAorDasAorD(a, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAorDasAorD_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwBasA_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwBasA_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwBasA(a, b, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwBasA_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwBasA_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwBasA_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwBasA(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwBasA_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwBasA_async(const ::Test::AMI_Thrower_throwBasAPtr& __cb, ::Ice::Int a, ::Ice::Int b)
{
    ::Test::Callback_Thrower_throwBasAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwBasA(__cb, &::Test::AMI_Thrower_throwBasA::__response, &::Test::AMI_Thrower_throwBasA::__exception, &::Test::AMI_Thrower_throwBasA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwBasA(__cb, &::Test::AMI_Thrower_throwBasA::__response, &::Test::AMI_Thrower_throwBasA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwBasA_name);
        __ar = begin_throwBasA(a, b, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwBasA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwBasA_async(const ::Test::AMI_Thrower_throwBasAPtr& __cb, ::Ice::Int a, ::Ice::Int b, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwBasAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwBasA(__cb, &::Test::AMI_Thrower_throwBasA::__response, &::Test::AMI_Thrower_throwBasA::__exception, &::Test::AMI_Thrower_throwBasA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwBasA(__cb, &::Test::AMI_Thrower_throwBasA::__response, &::Test::AMI_Thrower_throwBasA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwBasA_name);
        __ar = begin_throwBasA(a, b, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwBasA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwCasA_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwCasA_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwCasA(a, b, c, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwCasA_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasA_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwCasA_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwCasA(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwCasA_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwCasA_async(const ::Test::AMI_Thrower_throwCasAPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c)
{
    ::Test::Callback_Thrower_throwCasAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwCasA(__cb, &::Test::AMI_Thrower_throwCasA::__response, &::Test::AMI_Thrower_throwCasA::__exception, &::Test::AMI_Thrower_throwCasA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwCasA(__cb, &::Test::AMI_Thrower_throwCasA::__response, &::Test::AMI_Thrower_throwCasA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwCasA_name);
        __ar = begin_throwCasA(a, b, c, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwCasA_async(const ::Test::AMI_Thrower_throwCasAPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwCasAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwCasA(__cb, &::Test::AMI_Thrower_throwCasA::__response, &::Test::AMI_Thrower_throwCasA::__exception, &::Test::AMI_Thrower_throwCasA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwCasA(__cb, &::Test::AMI_Thrower_throwCasA::__response, &::Test::AMI_Thrower_throwCasA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwCasA_name);
        __ar = begin_throwCasA(a, b, c, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwBasB_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwBasB_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwBasB(a, b, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwBasB_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwBasB_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwBasB_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwBasB(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwBasB_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::B&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwBasB_async(const ::Test::AMI_Thrower_throwBasBPtr& __cb, ::Ice::Int a, ::Ice::Int b)
{
    ::Test::Callback_Thrower_throwBasBPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwBasB(__cb, &::Test::AMI_Thrower_throwBasB::__response, &::Test::AMI_Thrower_throwBasB::__exception, &::Test::AMI_Thrower_throwBasB::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwBasB(__cb, &::Test::AMI_Thrower_throwBasB::__response, &::Test::AMI_Thrower_throwBasB::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwBasB_name);
        __ar = begin_throwBasB(a, b, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwBasB_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwBasB_async(const ::Test::AMI_Thrower_throwBasBPtr& __cb, ::Ice::Int a, ::Ice::Int b, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwBasBPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwBasB(__cb, &::Test::AMI_Thrower_throwBasB::__response, &::Test::AMI_Thrower_throwBasB::__exception, &::Test::AMI_Thrower_throwBasB::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwBasB(__cb, &::Test::AMI_Thrower_throwBasB::__response, &::Test::AMI_Thrower_throwBasB::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwBasB_name);
        __ar = begin_throwBasB(a, b, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwBasB_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwCasB_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwCasB_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwCasB(a, b, c, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwCasB_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasB_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwCasB_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwCasB(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwCasB_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::B&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwCasB_async(const ::Test::AMI_Thrower_throwCasBPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c)
{
    ::Test::Callback_Thrower_throwCasBPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwCasB(__cb, &::Test::AMI_Thrower_throwCasB::__response, &::Test::AMI_Thrower_throwCasB::__exception, &::Test::AMI_Thrower_throwCasB::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwCasB(__cb, &::Test::AMI_Thrower_throwCasB::__response, &::Test::AMI_Thrower_throwCasB::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwCasB_name);
        __ar = begin_throwCasB(a, b, c, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasB_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwCasB_async(const ::Test::AMI_Thrower_throwCasBPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwCasBPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwCasB(__cb, &::Test::AMI_Thrower_throwCasB::__response, &::Test::AMI_Thrower_throwCasB::__exception, &::Test::AMI_Thrower_throwCasB::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwCasB(__cb, &::Test::AMI_Thrower_throwCasB::__response, &::Test::AMI_Thrower_throwCasB::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwCasB_name);
        __ar = begin_throwCasB(a, b, c, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasB_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwCasC_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwCasC_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwCasC(a, b, c, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwCasC_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasC_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwCasC_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwCasC(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwCasC_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::C&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwCasC_async(const ::Test::AMI_Thrower_throwCasCPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c)
{
    ::Test::Callback_Thrower_throwCasCPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwCasC(__cb, &::Test::AMI_Thrower_throwCasC::__response, &::Test::AMI_Thrower_throwCasC::__exception, &::Test::AMI_Thrower_throwCasC::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwCasC(__cb, &::Test::AMI_Thrower_throwCasC::__response, &::Test::AMI_Thrower_throwCasC::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwCasC_name);
        __ar = begin_throwCasC(a, b, c, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasC_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwCasC_async(const ::Test::AMI_Thrower_throwCasCPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwCasCPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwCasC(__cb, &::Test::AMI_Thrower_throwCasC::__response, &::Test::AMI_Thrower_throwCasC::__exception, &::Test::AMI_Thrower_throwCasC::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwCasC(__cb, &::Test::AMI_Thrower_throwCasC::__response, &::Test::AMI_Thrower_throwCasC::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwCasC_name);
        __ar = begin_throwCasC(a, b, c, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwCasC_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwModA_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwModA_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwModA(a, a2, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwModA_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwModA_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwModA_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(a2);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwModA(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwModA_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Mod::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwModA_async(const ::Test::AMI_Thrower_throwModAPtr& __cb, ::Ice::Int a, ::Ice::Int a2)
{
    ::Test::Callback_Thrower_throwModAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwModA(__cb, &::Test::AMI_Thrower_throwModA::__response, &::Test::AMI_Thrower_throwModA::__exception, &::Test::AMI_Thrower_throwModA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwModA(__cb, &::Test::AMI_Thrower_throwModA::__response, &::Test::AMI_Thrower_throwModA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwModA_name);
        __ar = begin_throwModA(a, a2, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwModA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwModA_async(const ::Test::AMI_Thrower_throwModAPtr& __cb, ::Ice::Int a, ::Ice::Int a2, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwModAPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwModA(__cb, &::Test::AMI_Thrower_throwModA::__response, &::Test::AMI_Thrower_throwModA::__exception, &::Test::AMI_Thrower_throwModA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwModA(__cb, &::Test::AMI_Thrower_throwModA::__response, &::Test::AMI_Thrower_throwModA::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwModA_name);
        __ar = begin_throwModA(a, a2, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwModA_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwUndeclaredA(::Ice::Int a, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwUndeclaredA_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwUndeclaredA(a, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwUndeclaredA(::Ice::Int a, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwUndeclaredA_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwUndeclaredA_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwUndeclaredA(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwUndeclaredA_name);
}

bool
IceProxy::Test::Thrower::throwUndeclaredA_async(const ::Test::AMI_Thrower_throwUndeclaredAPtr& __cb, ::Ice::Int a)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredA(__cb, &::Test::AMI_Thrower_throwUndeclaredA::__response, &::Test::AMI_Thrower_throwUndeclaredA::__exception, &::Test::AMI_Thrower_throwUndeclaredA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredA(__cb, &::Test::AMI_Thrower_throwUndeclaredA::__response, &::Test::AMI_Thrower_throwUndeclaredA::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwUndeclaredA(a, 0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwUndeclaredA_async(const ::Test::AMI_Thrower_throwUndeclaredAPtr& __cb, ::Ice::Int a, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredA(__cb, &::Test::AMI_Thrower_throwUndeclaredA::__response, &::Test::AMI_Thrower_throwUndeclaredA::__exception, &::Test::AMI_Thrower_throwUndeclaredA::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredA(__cb, &::Test::AMI_Thrower_throwUndeclaredA::__response, &::Test::AMI_Thrower_throwUndeclaredA::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwUndeclaredA(a, &__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwUndeclaredB_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwUndeclaredB(a, b, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwUndeclaredB_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwUndeclaredB_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwUndeclaredB(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwUndeclaredB_name);
}

bool
IceProxy::Test::Thrower::throwUndeclaredB_async(const ::Test::AMI_Thrower_throwUndeclaredBPtr& __cb, ::Ice::Int a, ::Ice::Int b)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredB(__cb, &::Test::AMI_Thrower_throwUndeclaredB::__response, &::Test::AMI_Thrower_throwUndeclaredB::__exception, &::Test::AMI_Thrower_throwUndeclaredB::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredB(__cb, &::Test::AMI_Thrower_throwUndeclaredB::__response, &::Test::AMI_Thrower_throwUndeclaredB::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwUndeclaredB(a, b, 0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwUndeclaredB_async(const ::Test::AMI_Thrower_throwUndeclaredBPtr& __cb, ::Ice::Int a, ::Ice::Int b, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredB(__cb, &::Test::AMI_Thrower_throwUndeclaredB::__response, &::Test::AMI_Thrower_throwUndeclaredB::__exception, &::Test::AMI_Thrower_throwUndeclaredB::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredB(__cb, &::Test::AMI_Thrower_throwUndeclaredB::__response, &::Test::AMI_Thrower_throwUndeclaredB::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwUndeclaredB(a, b, &__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwUndeclaredC_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwUndeclaredC(a, b, c, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwUndeclaredC_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwUndeclaredC_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwUndeclaredC(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwUndeclaredC_name);
}

bool
IceProxy::Test::Thrower::throwUndeclaredC_async(const ::Test::AMI_Thrower_throwUndeclaredCPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredC(__cb, &::Test::AMI_Thrower_throwUndeclaredC::__response, &::Test::AMI_Thrower_throwUndeclaredC::__exception, &::Test::AMI_Thrower_throwUndeclaredC::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredC(__cb, &::Test::AMI_Thrower_throwUndeclaredC::__response, &::Test::AMI_Thrower_throwUndeclaredC::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwUndeclaredC(a, b, c, 0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwUndeclaredC_async(const ::Test::AMI_Thrower_throwUndeclaredCPtr& __cb, ::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredC(__cb, &::Test::AMI_Thrower_throwUndeclaredC::__response, &::Test::AMI_Thrower_throwUndeclaredC::__exception, &::Test::AMI_Thrower_throwUndeclaredC::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwUndeclaredC(__cb, &::Test::AMI_Thrower_throwUndeclaredC::__response, &::Test::AMI_Thrower_throwUndeclaredC::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwUndeclaredC(a, b, c, &__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwLocalException(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwLocalException_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwLocalException(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwLocalException(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwLocalException_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwLocalException_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwLocalException(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwLocalException_name);
}

bool
IceProxy::Test::Thrower::throwLocalException_async(const ::Test::AMI_Thrower_throwLocalExceptionPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwLocalException(__cb, &::Test::AMI_Thrower_throwLocalException::__response, &::Test::AMI_Thrower_throwLocalException::__exception, &::Test::AMI_Thrower_throwLocalException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwLocalException(__cb, &::Test::AMI_Thrower_throwLocalException::__response, &::Test::AMI_Thrower_throwLocalException::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwLocalException(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwLocalException_async(const ::Test::AMI_Thrower_throwLocalExceptionPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwLocalException(__cb, &::Test::AMI_Thrower_throwLocalException::__response, &::Test::AMI_Thrower_throwLocalException::__exception, &::Test::AMI_Thrower_throwLocalException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwLocalException(__cb, &::Test::AMI_Thrower_throwLocalException::__response, &::Test::AMI_Thrower_throwLocalException::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwLocalException(&__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwNonIceException(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwNonIceException_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwNonIceException(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwNonIceException(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwNonIceException_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwNonIceException_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwNonIceException(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwNonIceException_name);
}

bool
IceProxy::Test::Thrower::throwNonIceException_async(const ::Test::AMI_Thrower_throwNonIceExceptionPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwNonIceException(__cb, &::Test::AMI_Thrower_throwNonIceException::__response, &::Test::AMI_Thrower_throwNonIceException::__exception, &::Test::AMI_Thrower_throwNonIceException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwNonIceException(__cb, &::Test::AMI_Thrower_throwNonIceException::__response, &::Test::AMI_Thrower_throwNonIceException::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwNonIceException(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwNonIceException_async(const ::Test::AMI_Thrower_throwNonIceExceptionPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwNonIceException(__cb, &::Test::AMI_Thrower_throwNonIceException::__response, &::Test::AMI_Thrower_throwNonIceException::__exception, &::Test::AMI_Thrower_throwNonIceException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwNonIceException(__cb, &::Test::AMI_Thrower_throwNonIceException::__response, &::Test::AMI_Thrower_throwNonIceException::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwNonIceException(&__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwAssertException(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwAssertException_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwAssertException(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwAssertException(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAssertException_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwAssertException_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwAssertException(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwAssertException_name);
}

bool
IceProxy::Test::Thrower::throwAssertException_async(const ::Test::AMI_Thrower_throwAssertExceptionPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAssertException(__cb, &::Test::AMI_Thrower_throwAssertException::__response, &::Test::AMI_Thrower_throwAssertException::__exception, &::Test::AMI_Thrower_throwAssertException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAssertException(__cb, &::Test::AMI_Thrower_throwAssertException::__response, &::Test::AMI_Thrower_throwAssertException::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwAssertException(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwAssertException_async(const ::Test::AMI_Thrower_throwAssertExceptionPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAssertException(__cb, &::Test::AMI_Thrower_throwAssertException::__response, &::Test::AMI_Thrower_throwAssertException::__exception, &::Test::AMI_Thrower_throwAssertException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAssertException(__cb, &::Test::AMI_Thrower_throwAssertException::__response, &::Test::AMI_Thrower_throwAssertException::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwAssertException(&__ctx, __del);
    return __ar->sentSynchronously();
}

::Ice::ByteSeq
IceProxy::Test::Thrower::throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwMemoryLimitException_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwMemoryLimitException_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            return __del->throwMemoryLimitException(seq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwMemoryLimitException_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwMemoryLimitException_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwMemoryLimitException_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(seq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::ByteSeq
IceProxy::Test::Thrower::end_throwMemoryLimitException(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwMemoryLimitException_name);
    ::Ice::ByteSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwMemoryLimitException_async(const ::Test::AMI_Thrower_throwMemoryLimitExceptionPtr& __cb, const ::Ice::ByteSeq& seq)
{
    ::Test::Callback_Thrower_throwMemoryLimitExceptionPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwMemoryLimitException(__cb, &::Test::AMI_Thrower_throwMemoryLimitException::__response, &::Test::AMI_Thrower_throwMemoryLimitException::__exception, &::Test::AMI_Thrower_throwMemoryLimitException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwMemoryLimitException(__cb, &::Test::AMI_Thrower_throwMemoryLimitException::__response, &::Test::AMI_Thrower_throwMemoryLimitException::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwMemoryLimitException_name);
        __ar = begin_throwMemoryLimitException(seq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwMemoryLimitException_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwMemoryLimitException_async(const ::Test::AMI_Thrower_throwMemoryLimitExceptionPtr& __cb, const ::Ice::ByteSeq& seq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwMemoryLimitExceptionPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwMemoryLimitException(__cb, &::Test::AMI_Thrower_throwMemoryLimitException::__response, &::Test::AMI_Thrower_throwMemoryLimitException::__exception, &::Test::AMI_Thrower_throwMemoryLimitException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwMemoryLimitException(__cb, &::Test::AMI_Thrower_throwMemoryLimitException::__response, &::Test::AMI_Thrower_throwMemoryLimitException::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwMemoryLimitException_name);
        __ar = begin_throwMemoryLimitException(seq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwMemoryLimitException_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwLocalExceptionIdempotent(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwLocalExceptionIdempotent_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwLocalExceptionIdempotent(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwLocalExceptionIdempotent_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwLocalExceptionIdempotent_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwLocalExceptionIdempotent(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwLocalExceptionIdempotent_name);
}

bool
IceProxy::Test::Thrower::throwLocalExceptionIdempotent_async(const ::Test::AMI_Thrower_throwLocalExceptionIdempotentPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwLocalExceptionIdempotent(__cb, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__response, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__exception, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwLocalExceptionIdempotent(__cb, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__response, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwLocalExceptionIdempotent(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwLocalExceptionIdempotent_async(const ::Test::AMI_Thrower_throwLocalExceptionIdempotentPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwLocalExceptionIdempotent(__cb, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__response, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__exception, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwLocalExceptionIdempotent(__cb, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__response, &::Test::AMI_Thrower_throwLocalExceptionIdempotent::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwLocalExceptionIdempotent(&__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwAfterResponse(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwAfterResponse_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwAfterResponse(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwAfterResponse(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAfterResponse_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwAfterResponse_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwAfterResponse(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwAfterResponse_name);
}

bool
IceProxy::Test::Thrower::throwAfterResponse_async(const ::Test::AMI_Thrower_throwAfterResponsePtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAfterResponse(__cb, &::Test::AMI_Thrower_throwAfterResponse::__response, &::Test::AMI_Thrower_throwAfterResponse::__exception, &::Test::AMI_Thrower_throwAfterResponse::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAfterResponse(__cb, &::Test::AMI_Thrower_throwAfterResponse::__response, &::Test::AMI_Thrower_throwAfterResponse::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwAfterResponse(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwAfterResponse_async(const ::Test::AMI_Thrower_throwAfterResponsePtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAfterResponse(__cb, &::Test::AMI_Thrower_throwAfterResponse::__response, &::Test::AMI_Thrower_throwAfterResponse::__exception, &::Test::AMI_Thrower_throwAfterResponse::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAfterResponse(__cb, &::Test::AMI_Thrower_throwAfterResponse::__response, &::Test::AMI_Thrower_throwAfterResponse::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwAfterResponse(&__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwAfterException(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwAfterException_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwAfterException_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwAfterException(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwAfterException(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwAfterException_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAfterException_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwAfterException_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwAfterException(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwAfterException_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwAfterException_async(const ::Test::AMI_Thrower_throwAfterExceptionPtr& __cb)
{
    ::Test::Callback_Thrower_throwAfterExceptionPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAfterException(__cb, &::Test::AMI_Thrower_throwAfterException::__response, &::Test::AMI_Thrower_throwAfterException::__exception, &::Test::AMI_Thrower_throwAfterException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAfterException(__cb, &::Test::AMI_Thrower_throwAfterException::__response, &::Test::AMI_Thrower_throwAfterException::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwAfterException_name);
        __ar = begin_throwAfterException(0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAfterException_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwAfterException_async(const ::Test::AMI_Thrower_throwAfterExceptionPtr& __cb, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwAfterExceptionPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwAfterException(__cb, &::Test::AMI_Thrower_throwAfterException::__response, &::Test::AMI_Thrower_throwAfterException::__exception, &::Test::AMI_Thrower_throwAfterException::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwAfterException(__cb, &::Test::AMI_Thrower_throwAfterException::__response, &::Test::AMI_Thrower_throwAfterException::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwAfterException_name);
        __ar = begin_throwAfterException(&__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwAfterException_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwE(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwE_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwE_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwE(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwE(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwE_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwE_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwE_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwE(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwE_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::E&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwE_async(const ::Test::AMI_Thrower_throwEPtr& __cb)
{
    ::Test::Callback_Thrower_throwEPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwE(__cb, &::Test::AMI_Thrower_throwE::__response, &::Test::AMI_Thrower_throwE::__exception, &::Test::AMI_Thrower_throwE::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwE(__cb, &::Test::AMI_Thrower_throwE::__response, &::Test::AMI_Thrower_throwE::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwE_name);
        __ar = begin_throwE(0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwE_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwE_async(const ::Test::AMI_Thrower_throwEPtr& __cb, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwEPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwE(__cb, &::Test::AMI_Thrower_throwE::__response, &::Test::AMI_Thrower_throwE::__exception, &::Test::AMI_Thrower_throwE::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwE(__cb, &::Test::AMI_Thrower_throwE::__response, &::Test::AMI_Thrower_throwE::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwE_name);
        __ar = begin_throwE(&__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwE_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwF(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwF_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Thrower__throwF_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwF(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwF(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Thrower__throwF_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwF_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwF_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwF(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Thrower__throwF_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::F&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::Thrower::throwF_async(const ::Test::AMI_Thrower_throwFPtr& __cb)
{
    ::Test::Callback_Thrower_throwFPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwF(__cb, &::Test::AMI_Thrower_throwF::__response, &::Test::AMI_Thrower_throwF::__exception, &::Test::AMI_Thrower_throwF::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwF(__cb, &::Test::AMI_Thrower_throwF::__response, &::Test::AMI_Thrower_throwF::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwF_name);
        __ar = begin_throwF(0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwF_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwF_async(const ::Test::AMI_Thrower_throwFPtr& __cb, const ::Ice::Context& __ctx)
{
    ::Test::Callback_Thrower_throwFPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwF(__cb, &::Test::AMI_Thrower_throwF::__response, &::Test::AMI_Thrower_throwF::__exception, &::Test::AMI_Thrower_throwF::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwF(__cb, &::Test::AMI_Thrower_throwF::__response, &::Test::AMI_Thrower_throwF::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__Thrower__throwF_name);
        __ar = begin_throwF(&__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwF_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwG(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwG_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwG(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwG(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwG_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwG_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwG(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwG_name);
}

bool
IceProxy::Test::Thrower::throwG_async(const ::Test::AMI_Thrower_throwGPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwG(__cb, &::Test::AMI_Thrower_throwG::__response, &::Test::AMI_Thrower_throwG::__exception, &::Test::AMI_Thrower_throwG::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwG(__cb, &::Test::AMI_Thrower_throwG::__response, &::Test::AMI_Thrower_throwG::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwG(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwG_async(const ::Test::AMI_Thrower_throwGPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwG(__cb, &::Test::AMI_Thrower_throwG::__response, &::Test::AMI_Thrower_throwG::__exception, &::Test::AMI_Thrower_throwG::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwG(__cb, &::Test::AMI_Thrower_throwG::__response, &::Test::AMI_Thrower_throwG::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwG(&__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::Test::Thrower::throwH(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Thrower__throwH_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Thrower* __del = dynamic_cast< ::IceDelegate::Test::Thrower*>(__delBase.get());
            __del->throwH(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Thrower::begin_throwH(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Thrower__throwH_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Thrower__throwH_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Thrower::end_throwH(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Thrower__throwH_name);
}

bool
IceProxy::Test::Thrower::throwH_async(const ::Test::AMI_Thrower_throwHPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwH(__cb, &::Test::AMI_Thrower_throwH::__response, &::Test::AMI_Thrower_throwH::__exception, &::Test::AMI_Thrower_throwH::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwH(__cb, &::Test::AMI_Thrower_throwH::__response, &::Test::AMI_Thrower_throwH::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwH(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::Thrower::throwH_async(const ::Test::AMI_Thrower_throwHPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_Thrower_throwH(__cb, &::Test::AMI_Thrower_throwH::__response, &::Test::AMI_Thrower_throwH::__exception, &::Test::AMI_Thrower_throwH::__sent);
    }
    else
    {
         __del = ::Test::newCallback_Thrower_throwH(__cb, &::Test::AMI_Thrower_throwH::__response, &::Test::AMI_Thrower_throwH::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_throwH(&__ctx, __del);
    return __ar->sentSynchronously();
}

const ::std::string&
IceProxy::Test::Thrower::ice_staticId()
{
    return ::Test::Thrower::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Thrower::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Thrower);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Thrower::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Thrower);
}

::IceProxy::Ice::Object*
IceProxy::Test::Thrower::__newInstance() const
{
    return new Thrower;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::WrongOperation* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::WrongOperation>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::WrongOperation;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::WrongOperation::noSuchOperation(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__WrongOperation__noSuchOperation_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::WrongOperation* __del = dynamic_cast< ::IceDelegate::Test::WrongOperation*>(__delBase.get());
            __del->noSuchOperation(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::WrongOperation::begin_noSuchOperation(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__WrongOperation__noSuchOperation_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__WrongOperation__noSuchOperation_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::WrongOperation::end_noSuchOperation(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__WrongOperation__noSuchOperation_name);
}

bool
IceProxy::Test::WrongOperation::noSuchOperation_async(const ::Test::AMI_WrongOperation_noSuchOperationPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_WrongOperation_noSuchOperation(__cb, &::Test::AMI_WrongOperation_noSuchOperation::__response, &::Test::AMI_WrongOperation_noSuchOperation::__exception, &::Test::AMI_WrongOperation_noSuchOperation::__sent);
    }
    else
    {
         __del = ::Test::newCallback_WrongOperation_noSuchOperation(__cb, &::Test::AMI_WrongOperation_noSuchOperation::__response, &::Test::AMI_WrongOperation_noSuchOperation::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_noSuchOperation(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::WrongOperation::noSuchOperation_async(const ::Test::AMI_WrongOperation_noSuchOperationPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_WrongOperation_noSuchOperation(__cb, &::Test::AMI_WrongOperation_noSuchOperation::__response, &::Test::AMI_WrongOperation_noSuchOperation::__exception, &::Test::AMI_WrongOperation_noSuchOperation::__sent);
    }
    else
    {
         __del = ::Test::newCallback_WrongOperation_noSuchOperation(__cb, &::Test::AMI_WrongOperation_noSuchOperation::__response, &::Test::AMI_WrongOperation_noSuchOperation::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_noSuchOperation(&__ctx, __del);
    return __ar->sentSynchronously();
}

const ::std::string&
IceProxy::Test::WrongOperation::ice_staticId()
{
    return ::Test::WrongOperation::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::WrongOperation::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::WrongOperation);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::WrongOperation::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::WrongOperation);
}

::IceProxy::Ice::Object*
IceProxy::Test::WrongOperation::__newInstance() const
{
    return new WrongOperation;
}

void
IceDelegateM::Test::Thrower::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__shutdown_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::Test::Thrower::supportsUndeclaredExceptions(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__supportsUndeclaredExceptions_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::Test::Thrower::supportsAssertException(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__supportsAssertException_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwAasA(::Ice::Int a, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwAasA_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwAorDasAorD(::Ice::Int a, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwAorDasAorD_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Test::D&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwBasA_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwCasA_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwBasB_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::B&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwCasB_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::B&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwCasC_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::C&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwModA_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(a2);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Mod::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwUndeclaredA(::Ice::Int a, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwUndeclaredA_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwUndeclaredB_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwUndeclaredC_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(a);
        __os->write(b);
        __os->write(c);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwLocalException(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwLocalException_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwNonIceException(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwNonIceException_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwAssertException(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwAssertException_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::ByteSeq
IceDelegateM::Test::Thrower::throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwMemoryLimitException_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::ByteSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwLocalExceptionIdempotent(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwLocalExceptionIdempotent_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwAfterResponse(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwAfterResponse_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwAfterException(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwAfterException_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::A&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwE(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwE_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::E&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwF(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwF_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::F&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Thrower::throwG(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwG_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Thrower::throwH(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Thrower__throwH_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::WrongOperation::noSuchOperation(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__WrongOperation__noSuchOperation_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateD::Test::Thrower::shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

bool
IceDelegateD::Test::Thrower::supportsUndeclaredExceptions(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return bool(); // to avoid a warning with some compilers;
}

bool
IceDelegateD::Test::Thrower::supportsAssertException(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return bool(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::Thrower::throwAasA(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwAorDasAorD(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwBasA(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwCasA(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwBasB(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwCasB(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwCasC(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwModA(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwUndeclaredA(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwUndeclaredB(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwUndeclaredC(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwLocalException(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwNonIceException(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwAssertException(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::ByteSeq
IceDelegateD::Test::Thrower::throwMemoryLimitException(const ::Ice::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::ByteSeq(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::Thrower::throwLocalExceptionIdempotent(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwAfterResponse(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwAfterException(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwE(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwF(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwG(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::Thrower::throwH(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::WrongOperation::noSuchOperation(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Object* Test::upCast(::Test::Empty* p) { return p; }

namespace
{
const ::std::string __Test__Empty_ids[2] =
{
    "::Ice::Object",
    "::Test::Empty"
};

}

bool
Test::Empty::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Empty_ids, __Test__Empty_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Empty::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Empty_ids[0], &__Test__Empty_ids[2]);
}

const ::std::string&
Test::Empty::ice_id(const ::Ice::Current&) const
{
    return __Test__Empty_ids[1];
}

const ::std::string&
Test::Empty::ice_staticId()
{
    return __Test__Empty_ids[1];
}

void
Test::Empty::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Empty::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(EmptyPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Empty::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Thrower* p) { return p; }

namespace
{
const ::std::string __Test__Thrower_ids[2] =
{
    "::Ice::Object",
    "::Test::Thrower"
};

}

bool
Test::Thrower::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Thrower_ids, __Test__Thrower_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Thrower::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Thrower_ids[0], &__Test__Thrower_ids[2]);
}

const ::std::string&
Test::Thrower::ice_id(const ::Ice::Current&) const
{
    return __Test__Thrower_ids[1];
}

const ::std::string&
Test::Thrower::ice_staticId()
{
    return __Test__Thrower_ids[1];
}

::Ice::DispatchStatus
Test::Thrower::___shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_shutdownPtr __cb = new IceAsync::Test::AMD_Thrower_shutdown(__inS);
    try
    {
        shutdown_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___supportsUndeclaredExceptions(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_supportsUndeclaredExceptionsPtr __cb = new IceAsync::Test::AMD_Thrower_supportsUndeclaredExceptions(__inS);
    try
    {
        supportsUndeclaredExceptions_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___supportsAssertException(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_supportsAssertExceptionPtr __cb = new IceAsync::Test::AMD_Thrower_supportsAssertException(__inS);
    try
    {
        supportsAssertException_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwAasA(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    __is->read(a);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwAasAPtr __cb = new IceAsync::Test::AMD_Thrower_throwAasA(__inS);
    try
    {
        throwAasA_async(__cb, a, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwAorDasAorD(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    __is->read(a);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwAorDasAorDPtr __cb = new IceAsync::Test::AMD_Thrower_throwAorDasAorD(__inS);
    try
    {
        throwAorDasAorD_async(__cb, a, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwBasA(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int b;
    __is->read(a);
    __is->read(b);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwBasAPtr __cb = new IceAsync::Test::AMD_Thrower_throwBasA(__inS);
    try
    {
        throwBasA_async(__cb, a, b, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwCasA(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int b;
    ::Ice::Int c;
    __is->read(a);
    __is->read(b);
    __is->read(c);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwCasAPtr __cb = new IceAsync::Test::AMD_Thrower_throwCasA(__inS);
    try
    {
        throwCasA_async(__cb, a, b, c, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwBasB(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int b;
    __is->read(a);
    __is->read(b);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwBasBPtr __cb = new IceAsync::Test::AMD_Thrower_throwBasB(__inS);
    try
    {
        throwBasB_async(__cb, a, b, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwCasB(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int b;
    ::Ice::Int c;
    __is->read(a);
    __is->read(b);
    __is->read(c);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwCasBPtr __cb = new IceAsync::Test::AMD_Thrower_throwCasB(__inS);
    try
    {
        throwCasB_async(__cb, a, b, c, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwCasC(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int b;
    ::Ice::Int c;
    __is->read(a);
    __is->read(b);
    __is->read(c);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwCasCPtr __cb = new IceAsync::Test::AMD_Thrower_throwCasC(__inS);
    try
    {
        throwCasC_async(__cb, a, b, c, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwModA(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int a2;
    __is->read(a);
    __is->read(a2);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwModAPtr __cb = new IceAsync::Test::AMD_Thrower_throwModA(__inS);
    try
    {
        throwModA_async(__cb, a, a2, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwUndeclaredA(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    __is->read(a);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwUndeclaredAPtr __cb = new IceAsync::Test::AMD_Thrower_throwUndeclaredA(__inS);
    try
    {
        throwUndeclaredA_async(__cb, a, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwUndeclaredB(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int b;
    __is->read(a);
    __is->read(b);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwUndeclaredBPtr __cb = new IceAsync::Test::AMD_Thrower_throwUndeclaredB(__inS);
    try
    {
        throwUndeclaredB_async(__cb, a, b, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwUndeclaredC(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int a;
    ::Ice::Int b;
    ::Ice::Int c;
    __is->read(a);
    __is->read(b);
    __is->read(c);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwUndeclaredCPtr __cb = new IceAsync::Test::AMD_Thrower_throwUndeclaredC(__inS);
    try
    {
        throwUndeclaredC_async(__cb, a, b, c, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwLocalException(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwLocalExceptionPtr __cb = new IceAsync::Test::AMD_Thrower_throwLocalException(__inS);
    try
    {
        throwLocalException_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwNonIceException(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwNonIceExceptionPtr __cb = new IceAsync::Test::AMD_Thrower_throwNonIceException(__inS);
    try
    {
        throwNonIceException_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwAssertException(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwAssertExceptionPtr __cb = new IceAsync::Test::AMD_Thrower_throwAssertException(__inS);
    try
    {
        throwAssertException_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwMemoryLimitException(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::ByteSeq seq;
    __is->read(seq);
    __inS.endReadParams();
    ::Test::AMD_Thrower_throwMemoryLimitExceptionPtr __cb = new IceAsync::Test::AMD_Thrower_throwMemoryLimitException(__inS);
    try
    {
        throwMemoryLimitException_async(__cb, seq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwLocalExceptionIdempotent(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwLocalExceptionIdempotentPtr __cb = new IceAsync::Test::AMD_Thrower_throwLocalExceptionIdempotent(__inS);
    try
    {
        throwLocalExceptionIdempotent_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwAfterResponse(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwAfterResponsePtr __cb = new IceAsync::Test::AMD_Thrower_throwAfterResponse(__inS);
    try
    {
        throwAfterResponse_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwAfterException(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwAfterExceptionPtr __cb = new IceAsync::Test::AMD_Thrower_throwAfterException(__inS);
    try
    {
        throwAfterException_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwE(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwEPtr __cb = new IceAsync::Test::AMD_Thrower_throwE(__inS);
    try
    {
        throwE_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwF(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwFPtr __cb = new IceAsync::Test::AMD_Thrower_throwF(__inS);
    try
    {
        throwF_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwG(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwGPtr __cb = new IceAsync::Test::AMD_Thrower_throwG(__inS);
    try
    {
        throwG_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::Thrower::___throwH(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_Thrower_throwHPtr __cb = new IceAsync::Test::AMD_Thrower_throwH(__inS);
    try
    {
        throwH_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __Test__Thrower_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "shutdown",
    "supportsAssertException",
    "supportsUndeclaredExceptions",
    "throwAasA",
    "throwAfterException",
    "throwAfterResponse",
    "throwAorDasAorD",
    "throwAssertException",
    "throwBasA",
    "throwBasB",
    "throwCasA",
    "throwCasB",
    "throwCasC",
    "throwE",
    "throwF",
    "throwG",
    "throwH",
    "throwLocalException",
    "throwLocalExceptionIdempotent",
    "throwMemoryLimitException",
    "throwModA",
    "throwNonIceException",
    "throwUndeclaredA",
    "throwUndeclaredB",
    "throwUndeclaredC"
};

}

::Ice::DispatchStatus
Test::Thrower::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Thrower_all, __Test__Thrower_all + 29, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Thrower_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___shutdown(in, current);
        }
        case 5:
        {
            return ___supportsAssertException(in, current);
        }
        case 6:
        {
            return ___supportsUndeclaredExceptions(in, current);
        }
        case 7:
        {
            return ___throwAasA(in, current);
        }
        case 8:
        {
            return ___throwAfterException(in, current);
        }
        case 9:
        {
            return ___throwAfterResponse(in, current);
        }
        case 10:
        {
            return ___throwAorDasAorD(in, current);
        }
        case 11:
        {
            return ___throwAssertException(in, current);
        }
        case 12:
        {
            return ___throwBasA(in, current);
        }
        case 13:
        {
            return ___throwBasB(in, current);
        }
        case 14:
        {
            return ___throwCasA(in, current);
        }
        case 15:
        {
            return ___throwCasB(in, current);
        }
        case 16:
        {
            return ___throwCasC(in, current);
        }
        case 17:
        {
            return ___throwE(in, current);
        }
        case 18:
        {
            return ___throwF(in, current);
        }
        case 19:
        {
            return ___throwG(in, current);
        }
        case 20:
        {
            return ___throwH(in, current);
        }
        case 21:
        {
            return ___throwLocalException(in, current);
        }
        case 22:
        {
            return ___throwLocalExceptionIdempotent(in, current);
        }
        case 23:
        {
            return ___throwMemoryLimitException(in, current);
        }
        case 24:
        {
            return ___throwModA(in, current);
        }
        case 25:
        {
            return ___throwNonIceException(in, current);
        }
        case 26:
        {
            return ___throwUndeclaredA(in, current);
        }
        case 27:
        {
            return ___throwUndeclaredB(in, current);
        }
        case 28:
        {
            return ___throwUndeclaredC(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Thrower::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Thrower::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(ThrowerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::ThrowerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Thrower::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::WrongOperation* p) { return p; }

namespace
{
const ::std::string __Test__WrongOperation_ids[2] =
{
    "::Ice::Object",
    "::Test::WrongOperation"
};

}

bool
Test::WrongOperation::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__WrongOperation_ids, __Test__WrongOperation_ids + 2, _s);
}

::std::vector< ::std::string>
Test::WrongOperation::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__WrongOperation_ids[0], &__Test__WrongOperation_ids[2]);
}

const ::std::string&
Test::WrongOperation::ice_id(const ::Ice::Current&) const
{
    return __Test__WrongOperation_ids[1];
}

const ::std::string&
Test::WrongOperation::ice_staticId()
{
    return __Test__WrongOperation_ids[1];
}

::Ice::DispatchStatus
Test::WrongOperation::___noSuchOperation(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_WrongOperation_noSuchOperationPtr __cb = new IceAsync::Test::AMD_WrongOperation_noSuchOperation(__inS);
    try
    {
        noSuchOperation_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __Test__WrongOperation_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "noSuchOperation"
};

}

::Ice::DispatchStatus
Test::WrongOperation::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__WrongOperation_all, __Test__WrongOperation_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__WrongOperation_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___noSuchOperation(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::WrongOperation::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::WrongOperation::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(WrongOperationPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::WrongOperationPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::WrongOperation::ice_staticId(), v);
    }
}
