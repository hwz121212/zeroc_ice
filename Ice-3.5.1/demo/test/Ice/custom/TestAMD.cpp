// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <TestAMD.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Test__TestIntf__opDoubleArray_name = "opDoubleArray";

const ::std::string __Test__TestIntf__opBoolArray_name = "opBoolArray";

const ::std::string __Test__TestIntf__opByteArray_name = "opByteArray";

const ::std::string __Test__TestIntf__opVariableArray_name = "opVariableArray";

const ::std::string __Test__TestIntf__opBoolRange_name = "opBoolRange";

const ::std::string __Test__TestIntf__opByteRange_name = "opByteRange";

const ::std::string __Test__TestIntf__opVariableRange_name = "opVariableRange";

const ::std::string __Test__TestIntf__opBoolRangeType_name = "opBoolRangeType";

const ::std::string __Test__TestIntf__opByteRangeType_name = "opByteRangeType";

const ::std::string __Test__TestIntf__opVariableRangeType_name = "opVariableRangeType";

const ::std::string __Test__TestIntf__opBoolSeq_name = "opBoolSeq";

const ::std::string __Test__TestIntf__opBoolList_name = "opBoolList";

const ::std::string __Test__TestIntf__opByteSeq_name = "opByteSeq";

const ::std::string __Test__TestIntf__opByteList_name = "opByteList";

const ::std::string __Test__TestIntf__opMyByteSeq_name = "opMyByteSeq";

const ::std::string __Test__TestIntf__opStringSeq_name = "opStringSeq";

const ::std::string __Test__TestIntf__opStringList_name = "opStringList";

const ::std::string __Test__TestIntf__opFixedSeq_name = "opFixedSeq";

const ::std::string __Test__TestIntf__opFixedList_name = "opFixedList";

const ::std::string __Test__TestIntf__opVariableSeq_name = "opVariableSeq";

const ::std::string __Test__TestIntf__opVariableList_name = "opVariableList";

const ::std::string __Test__TestIntf__opStringStringDictSeq_name = "opStringStringDictSeq";

const ::std::string __Test__TestIntf__opStringStringDictList_name = "opStringStringDictList";

const ::std::string __Test__TestIntf__opESeq_name = "opESeq";

const ::std::string __Test__TestIntf__opEList_name = "opEList";

const ::std::string __Test__TestIntf__opCPrxSeq_name = "opCPrxSeq";

const ::std::string __Test__TestIntf__opCPrxList_name = "opCPrxList";

const ::std::string __Test__TestIntf__opCSeq_name = "opCSeq";

const ::std::string __Test__TestIntf__opCList_name = "opCList";

const ::std::string __Test__TestIntf__opClassStruct_name = "opClassStruct";

const ::std::string __Test__TestIntf__opOutArrayByteSeq_name = "opOutArrayByteSeq";

const ::std::string __Test__TestIntf__opOutRangeByteSeq_name = "opOutRangeByteSeq";

const ::std::string __Test__TestIntf__opIntStringDict_name = "opIntStringDict";

const ::std::string __Test__TestIntf__opVarDict_name = "opVarDict";

const ::std::string __Test__TestIntf__opShortBuffer_name = "opShortBuffer";

const ::std::string __Test__TestIntf__opBoolBuffer_name = "opBoolBuffer";

const ::std::string __Test__TestIntf__opBufferStruct_name = "opBufferStruct";

const ::std::string __Test__TestIntf__shutdown_name = "shutdown";

}

namespace Ice
{
}

IceAsync::Test::AMD_TestIntf_opDoubleArray::AMD_TestIntf_opDoubleArray(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opDoubleArray::ice_response(const ::Test::DoubleSeq& __ret, const ::Test::DoubleSeq& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opBoolArray::AMD_TestIntf_opBoolArray(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opBoolArray::ice_response(const ::Test::BoolSeq& __ret, const ::Test::BoolSeq& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opByteArray::AMD_TestIntf_opByteArray(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opByteArray::ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __ret, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opVariableArray::AMD_TestIntf_opVariableArray(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opVariableArray::ice_response(const ::Test::VariableList& __ret, const ::Test::VariableList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opBoolRange::AMD_TestIntf_opBoolRange(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opBoolRange::ice_response(const ::Test::BoolSeq& __ret, const ::Test::BoolSeq& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opByteRange::AMD_TestIntf_opByteRange(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opByteRange::ice_response(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& __ret, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opVariableRange::AMD_TestIntf_opVariableRange(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opVariableRange::ice_response(const ::Test::VariableList& __ret, const ::Test::VariableList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opBoolRangeType::AMD_TestIntf_opBoolRangeType(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opBoolRangeType::ice_response(const ::Test::BoolSeq& __ret, const ::Test::BoolSeq& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opByteRangeType::AMD_TestIntf_opByteRangeType(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opByteRangeType::ice_response(const ::Test::ByteList& __ret, const ::Test::ByteList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opVariableRangeType::AMD_TestIntf_opVariableRangeType(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opVariableRangeType::ice_response(const ::Test::VariableList& __ret, const ::Test::VariableList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opBoolSeq::AMD_TestIntf_opBoolSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opBoolSeq::ice_response(const std::deque<bool>& __ret, const std::deque<bool>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opBoolList::AMD_TestIntf_opBoolList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opBoolList::ice_response(const ::Test::BoolList& __ret, const ::Test::BoolList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opByteSeq::AMD_TestIntf_opByteSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opByteSeq::ice_response(const std::deque< ::Ice::Byte>& __ret, const std::deque< ::Ice::Byte>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opByteList::AMD_TestIntf_opByteList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opByteList::ice_response(const ::Test::ByteList& __ret, const ::Test::ByteList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opMyByteSeq::AMD_TestIntf_opMyByteSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opMyByteSeq::ice_response(const MyByteSeq& __ret, const MyByteSeq& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opStringSeq::AMD_TestIntf_opStringSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opStringSeq::ice_response(const std::deque<std::string>& __ret, const std::deque<std::string>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opStringList::AMD_TestIntf_opStringList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opStringList::ice_response(const ::Test::StringList& __ret, const ::Test::StringList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opFixedSeq::AMD_TestIntf_opFixedSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opFixedSeq::ice_response(const std::deque< ::Test::Fixed>& __ret, const std::deque< ::Test::Fixed>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opFixedList::AMD_TestIntf_opFixedList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opFixedList::ice_response(const ::Test::FixedList& __ret, const ::Test::FixedList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opVariableSeq::AMD_TestIntf_opVariableSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opVariableSeq::ice_response(const std::deque< ::Test::Variable>& __ret, const std::deque< ::Test::Variable>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opVariableList::AMD_TestIntf_opVariableList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opVariableList::ice_response(const ::Test::VariableList& __ret, const ::Test::VariableList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opStringStringDictSeq::AMD_TestIntf_opStringStringDictSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opStringStringDictSeq::ice_response(const std::deque< ::Test::StringStringDict>& __ret, const std::deque< ::Test::StringStringDict>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opStringStringDictList::AMD_TestIntf_opStringStringDictList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opStringStringDictList::ice_response(const ::Test::StringStringDictList& __ret, const ::Test::StringStringDictList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opESeq::AMD_TestIntf_opESeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opESeq::ice_response(const std::deque< ::Test::E>& __ret, const std::deque< ::Test::E>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opEList::AMD_TestIntf_opEList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opEList::ice_response(const ::Test::EList& __ret, const ::Test::EList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opCPrxSeq::AMD_TestIntf_opCPrxSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opCPrxSeq::ice_response(const std::deque< ::Test::CPrx>& __ret, const std::deque< ::Test::CPrx>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opCPrxList::AMD_TestIntf_opCPrxList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opCPrxList::ice_response(const ::Test::CPrxList& __ret, const ::Test::CPrxList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opCSeq::AMD_TestIntf_opCSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opCSeq::ice_response(const std::deque< ::Test::CPtr>& __ret, const std::deque< ::Test::CPtr>& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opCList::AMD_TestIntf_opCList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opCList::ice_response(const ::Test::CList& __ret, const ::Test::CList& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outSeq);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opClassStruct::AMD_TestIntf_opClassStruct(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opClassStruct::ice_response(const ::Test::ClassStructPtr& __ret, const ::Test::ClassStructPtr& outS, const ::Test::ClassStructSeq& outSeq)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outS);
            __os->write(outSeq);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opOutArrayByteSeq::AMD_TestIntf_opOutArrayByteSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opOutArrayByteSeq::ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& copy)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(copy);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opOutRangeByteSeq::AMD_TestIntf_opOutRangeByteSeq(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opOutRangeByteSeq::ice_response(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>& copy)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(copy);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opIntStringDict::AMD_TestIntf_opIntStringDict(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opIntStringDict::ice_response(const ::Test::IntStringDict& __ret, const ::Test::IntStringDict& odict)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(odict);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opVarDict::AMD_TestIntf_opVarDict(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opVarDict::ice_response(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& __ret, const ::Test::CustomMap<std::string, ::Ice::Int>& odict)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(odict);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opShortBuffer::AMD_TestIntf_opShortBuffer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opShortBuffer::ice_response(const ::Test::ShortBuffer& __ret, const ::Test::ShortBuffer& outS)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outS);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opBoolBuffer::AMD_TestIntf_opBoolBuffer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opBoolBuffer::ice_response(const ::Test::CustomBuffer<bool>& __ret, const ::Test::CustomBuffer<bool>& outS)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(outS);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_opBufferStruct::AMD_TestIntf_opBufferStruct(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_opBufferStruct::ice_response(const ::Test::BufferStruct& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_shutdown::AMD_TestIntf_shutdown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_shutdown::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::C* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::C>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::C;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::C::ice_staticId()
{
    return ::Test::C::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::C::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::C);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::C::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::C);
}

::IceProxy::Ice::Object*
IceProxy::Test::C::__newInstance() const
{
    return new C;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::DictClass* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::DictClass>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::DictClass;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::DictClass::ice_staticId()
{
    return ::Test::DictClass::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::DictClass::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::DictClass);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::DictClass::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::DictClass);
}

::IceProxy::Ice::Object*
IceProxy::Test::DictClass::__newInstance() const
{
    return new DictClass;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::TestIntf* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::TestIntf;
        v->__copyFrom(proxy);
    }
}

::Test::DoubleSeq
IceProxy::Test::TestIntf::opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opDoubleArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opDoubleArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opDoubleArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opDoubleArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opDoubleArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opDoubleArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::DoubleSeq
IceProxy::Test::TestIntf::end_opDoubleArray(::Test::DoubleSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opDoubleArray_name);
    ::Test::DoubleSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opDoubleArray_async(const ::Test::AMI_TestIntf_opDoubleArrayPtr& __cb, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq)
{
    ::Test::Callback_TestIntf_opDoubleArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception, &::Test::AMI_TestIntf_opDoubleArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opDoubleArray_name);
        __ar = begin_opDoubleArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opDoubleArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opDoubleArray_async(const ::Test::AMI_TestIntf_opDoubleArrayPtr& __cb, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opDoubleArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception, &::Test::AMI_TestIntf_opDoubleArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opDoubleArray_name);
        __ar = begin_opDoubleArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opDoubleArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolSeq
IceProxy::Test::TestIntf::opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolArray(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolArray_name);
    ::Test::BoolSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolArray_async(const ::Test::AMI_TestIntf_opBoolArrayPtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception, &::Test::AMI_TestIntf_opBoolArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolArray_name);
        __ar = begin_opBoolArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolArray_async(const ::Test::AMI_TestIntf_opBoolArrayPtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception, &::Test::AMI_TestIntf_opBoolArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolArray_name);
        __ar = begin_opBoolArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteArray(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteArray_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& outSeq, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteArray_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opByteArray_async(const ::Test::AMI_TestIntf_opByteArrayPtr& __cb, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq)
{
    ::Test::Callback_TestIntf_opByteArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception, &::Test::AMI_TestIntf_opByteArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteArray_name);
        __ar = begin_opByteArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteArray_async(const ::Test::AMI_TestIntf_opByteArrayPtr& __cb, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception, &::Test::AMI_TestIntf_opByteArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteArray_name);
        __ar = begin_opByteArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableArray(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableArray_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableArray_async(const ::Test::AMI_TestIntf_opVariableArrayPtr& __cb, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception, &::Test::AMI_TestIntf_opVariableArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableArray_name);
        __ar = begin_opVariableArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableArray_async(const ::Test::AMI_TestIntf_opVariableArrayPtr& __cb, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception, &::Test::AMI_TestIntf_opVariableArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableArray_name);
        __ar = begin_opVariableArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolSeq
IceProxy::Test::TestIntf::opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolRange_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolRange_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolRange(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRange_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolRange(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolRange_name);
    ::Test::BoolSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolRange_async(const ::Test::AMI_TestIntf_opBoolRangePtr& __cb, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception, &::Test::AMI_TestIntf_opBoolRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRange_name);
        __ar = begin_opBoolRange(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolRange_async(const ::Test::AMI_TestIntf_opBoolRangePtr& __cb, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception, &::Test::AMI_TestIntf_opBoolRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRange_name);
        __ar = begin_opBoolRange(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteRange_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteRange_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteRange(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRange_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteRange(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteRange_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteRange_async(const ::Test::AMI_TestIntf_opByteRangePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opByteRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception, &::Test::AMI_TestIntf_opByteRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRange_name);
        __ar = begin_opByteRange(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteRange_async(const ::Test::AMI_TestIntf_opByteRangePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception, &::Test::AMI_TestIntf_opByteRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRange_name);
        __ar = begin_opByteRange(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableRange_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableRange_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableRange(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRange_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableRange(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableRange_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableRange_async(const ::Test::AMI_TestIntf_opVariableRangePtr& __cb, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception, &::Test::AMI_TestIntf_opVariableRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRange_name);
        __ar = begin_opVariableRange(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableRange_async(const ::Test::AMI_TestIntf_opVariableRangePtr& __cb, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception, &::Test::AMI_TestIntf_opVariableRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRange_name);
        __ar = begin_opVariableRange(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolSeq
IceProxy::Test::TestIntf::opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolRangeType_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolRangeType(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRangeType_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolRangeType_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolRangeType(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolRangeType_name);
    ::Test::BoolSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolRangeType_async(const ::Test::AMI_TestIntf_opBoolRangeTypePtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception, &::Test::AMI_TestIntf_opBoolRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
        __ar = begin_opBoolRangeType(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolRangeType_async(const ::Test::AMI_TestIntf_opBoolRangeTypePtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception, &::Test::AMI_TestIntf_opBoolRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
        __ar = begin_opBoolRangeType(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteRangeType_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteRangeType_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteRangeType(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteRangeType_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRangeType_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteRangeType_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteRangeType(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteRangeType_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteRangeType_async(const ::Test::AMI_TestIntf_opByteRangeTypePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opByteRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception, &::Test::AMI_TestIntf_opByteRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRangeType_name);
        __ar = begin_opByteRangeType(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteRangeType_async(const ::Test::AMI_TestIntf_opByteRangeTypePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception, &::Test::AMI_TestIntf_opByteRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRangeType_name);
        __ar = begin_opByteRangeType(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableRangeType_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableRangeType(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRangeType_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableRangeType_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableRangeType(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableRangeType_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableRangeType_async(const ::Test::AMI_TestIntf_opVariableRangeTypePtr& __cb, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception, &::Test::AMI_TestIntf_opVariableRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
        __ar = begin_opVariableRangeType(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableRangeType_async(const ::Test::AMI_TestIntf_opVariableRangeTypePtr& __cb, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception, &::Test::AMI_TestIntf_opVariableRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
        __ar = begin_opVariableRangeType(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque<bool>
IceProxy::Test::TestIntf::opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque<bool>
IceProxy::Test::TestIntf::end_opBoolSeq(std::deque<bool>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolSeq_name);
    std::deque<bool> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolSeq_async(const ::Test::AMI_TestIntf_opBoolSeqPtr& __cb, const std::deque<bool>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception, &::Test::AMI_TestIntf_opBoolSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolSeq_name);
        __ar = begin_opBoolSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolSeq_async(const ::Test::AMI_TestIntf_opBoolSeqPtr& __cb, const std::deque<bool>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception, &::Test::AMI_TestIntf_opBoolSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolSeq_name);
        __ar = begin_opBoolSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolList
IceProxy::Test::TestIntf::opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolList
IceProxy::Test::TestIntf::end_opBoolList(::Test::BoolList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolList_name);
    ::Test::BoolList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolList_async(const ::Test::AMI_TestIntf_opBoolListPtr& __cb, const ::Test::BoolList& inSeq)
{
    ::Test::Callback_TestIntf_opBoolListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception, &::Test::AMI_TestIntf_opBoolList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolList_name);
        __ar = begin_opBoolList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolList_async(const ::Test::AMI_TestIntf_opBoolListPtr& __cb, const ::Test::BoolList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception, &::Test::AMI_TestIntf_opBoolList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolList_name);
        __ar = begin_opBoolList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Ice::Byte>
IceProxy::Test::TestIntf::opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Ice::Byte>
IceProxy::Test::TestIntf::end_opByteSeq(std::deque< ::Ice::Byte>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteSeq_name);
    std::deque< ::Ice::Byte> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteSeq_async(const ::Test::AMI_TestIntf_opByteSeqPtr& __cb, const std::deque< ::Ice::Byte>& inSeq)
{
    ::Test::Callback_TestIntf_opByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception, &::Test::AMI_TestIntf_opByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteSeq_name);
        __ar = begin_opByteSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteSeq_async(const ::Test::AMI_TestIntf_opByteSeqPtr& __cb, const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception, &::Test::AMI_TestIntf_opByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteSeq_name);
        __ar = begin_opByteSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteList(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteList_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteList_async(const ::Test::AMI_TestIntf_opByteListPtr& __cb, const ::Test::ByteList& inSeq)
{
    ::Test::Callback_TestIntf_opByteListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception, &::Test::AMI_TestIntf_opByteList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteList_name);
        __ar = begin_opByteList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteList_async(const ::Test::AMI_TestIntf_opByteListPtr& __cb, const ::Test::ByteList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception, &::Test::AMI_TestIntf_opByteList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteList_name);
        __ar = begin_opByteList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

MyByteSeq
IceProxy::Test::TestIntf::opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opMyByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opMyByteSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opMyByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opMyByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

MyByteSeq
IceProxy::Test::TestIntf::end_opMyByteSeq(MyByteSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opMyByteSeq_name);
    MyByteSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opMyByteSeq_async(const ::Test::AMI_TestIntf_opMyByteSeqPtr& __cb, const MyByteSeq& inSeq)
{
    ::Test::Callback_TestIntf_opMyByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception, &::Test::AMI_TestIntf_opMyByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
        __ar = begin_opMyByteSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opMyByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opMyByteSeq_async(const ::Test::AMI_TestIntf_opMyByteSeqPtr& __cb, const MyByteSeq& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opMyByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception, &::Test::AMI_TestIntf_opMyByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
        __ar = begin_opMyByteSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opMyByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque<std::string>
IceProxy::Test::TestIntf::opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque<std::string>
IceProxy::Test::TestIntf::end_opStringSeq(std::deque<std::string>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringSeq_name);
    std::deque<std::string> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringSeq_async(const ::Test::AMI_TestIntf_opStringSeqPtr& __cb, const std::deque<std::string>& inSeq)
{
    ::Test::Callback_TestIntf_opStringSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception, &::Test::AMI_TestIntf_opStringSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringSeq_name);
        __ar = begin_opStringSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringSeq_async(const ::Test::AMI_TestIntf_opStringSeqPtr& __cb, const std::deque<std::string>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception, &::Test::AMI_TestIntf_opStringSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringSeq_name);
        __ar = begin_opStringSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::StringList
IceProxy::Test::TestIntf::opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::StringList
IceProxy::Test::TestIntf::end_opStringList(::Test::StringList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringList_name);
    ::Test::StringList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringList_async(const ::Test::AMI_TestIntf_opStringListPtr& __cb, const ::Test::StringList& inSeq)
{
    ::Test::Callback_TestIntf_opStringListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception, &::Test::AMI_TestIntf_opStringList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringList_name);
        __ar = begin_opStringList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringList_async(const ::Test::AMI_TestIntf_opStringListPtr& __cb, const ::Test::StringList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception, &::Test::AMI_TestIntf_opStringList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringList_name);
        __ar = begin_opStringList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::Fixed>
IceProxy::Test::TestIntf::opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opFixedSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opFixedSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opFixedSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opFixedSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opFixedSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::Fixed>
IceProxy::Test::TestIntf::end_opFixedSeq(std::deque< ::Test::Fixed>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opFixedSeq_name);
    std::deque< ::Test::Fixed> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opFixedSeq_async(const ::Test::AMI_TestIntf_opFixedSeqPtr& __cb, const std::deque< ::Test::Fixed>& inSeq)
{
    ::Test::Callback_TestIntf_opFixedSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception, &::Test::AMI_TestIntf_opFixedSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedSeq_name);
        __ar = begin_opFixedSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opFixedSeq_async(const ::Test::AMI_TestIntf_opFixedSeqPtr& __cb, const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opFixedSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception, &::Test::AMI_TestIntf_opFixedSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedSeq_name);
        __ar = begin_opFixedSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::FixedList
IceProxy::Test::TestIntf::opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opFixedList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opFixedList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opFixedList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opFixedList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opFixedList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::FixedList
IceProxy::Test::TestIntf::end_opFixedList(::Test::FixedList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opFixedList_name);
    ::Test::FixedList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opFixedList_async(const ::Test::AMI_TestIntf_opFixedListPtr& __cb, const ::Test::FixedList& inSeq)
{
    ::Test::Callback_TestIntf_opFixedListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception, &::Test::AMI_TestIntf_opFixedList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedList_name);
        __ar = begin_opFixedList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opFixedList_async(const ::Test::AMI_TestIntf_opFixedListPtr& __cb, const ::Test::FixedList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opFixedListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception, &::Test::AMI_TestIntf_opFixedList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedList_name);
        __ar = begin_opFixedList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::Variable>
IceProxy::Test::TestIntf::opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::Variable>
IceProxy::Test::TestIntf::end_opVariableSeq(std::deque< ::Test::Variable>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableSeq_name);
    std::deque< ::Test::Variable> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableSeq_async(const ::Test::AMI_TestIntf_opVariableSeqPtr& __cb, const std::deque< ::Test::Variable>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception, &::Test::AMI_TestIntf_opVariableSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableSeq_name);
        __ar = begin_opVariableSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableSeq_async(const ::Test::AMI_TestIntf_opVariableSeqPtr& __cb, const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception, &::Test::AMI_TestIntf_opVariableSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableSeq_name);
        __ar = begin_opVariableSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableList(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableList_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableList_async(const ::Test::AMI_TestIntf_opVariableListPtr& __cb, const ::Test::VariableList& inSeq)
{
    ::Test::Callback_TestIntf_opVariableListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception, &::Test::AMI_TestIntf_opVariableList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableList_name);
        __ar = begin_opVariableList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableList_async(const ::Test::AMI_TestIntf_opVariableListPtr& __cb, const ::Test::VariableList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception, &::Test::AMI_TestIntf_opVariableList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableList_name);
        __ar = begin_opVariableList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::StringStringDict>
IceProxy::Test::TestIntf::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringStringDictSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringStringDictSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringStringDictSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::StringStringDict>
IceProxy::Test::TestIntf::end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringStringDictSeq_name);
    std::deque< ::Test::StringStringDict> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringStringDictSeq_async(const ::Test::AMI_TestIntf_opStringStringDictSeqPtr& __cb, const std::deque< ::Test::StringStringDict>& inSeq)
{
    ::Test::Callback_TestIntf_opStringStringDictSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception, &::Test::AMI_TestIntf_opStringStringDictSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
        __ar = begin_opStringStringDictSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringStringDictSeq_async(const ::Test::AMI_TestIntf_opStringStringDictSeqPtr& __cb, const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringStringDictSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception, &::Test::AMI_TestIntf_opStringStringDictSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
        __ar = begin_opStringStringDictSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::StringStringDictList
IceProxy::Test::TestIntf::opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringStringDictList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringStringDictList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringStringDictList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::StringStringDictList
IceProxy::Test::TestIntf::end_opStringStringDictList(::Test::StringStringDictList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringStringDictList_name);
    ::Test::StringStringDictList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringStringDictList_async(const ::Test::AMI_TestIntf_opStringStringDictListPtr& __cb, const ::Test::StringStringDictList& inSeq)
{
    ::Test::Callback_TestIntf_opStringStringDictListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception, &::Test::AMI_TestIntf_opStringStringDictList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
        __ar = begin_opStringStringDictList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringStringDictList_async(const ::Test::AMI_TestIntf_opStringStringDictListPtr& __cb, const ::Test::StringStringDictList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringStringDictListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception, &::Test::AMI_TestIntf_opStringStringDictList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
        __ar = begin_opStringStringDictList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::E>
IceProxy::Test::TestIntf::opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opESeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opESeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opESeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opESeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opESeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opESeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::E>
IceProxy::Test::TestIntf::end_opESeq(std::deque< ::Test::E>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opESeq_name);
    std::deque< ::Test::E> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opESeq_async(const ::Test::AMI_TestIntf_opESeqPtr& __cb, const std::deque< ::Test::E>& inSeq)
{
    ::Test::Callback_TestIntf_opESeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception, &::Test::AMI_TestIntf_opESeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opESeq_name);
        __ar = begin_opESeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opESeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opESeq_async(const ::Test::AMI_TestIntf_opESeqPtr& __cb, const std::deque< ::Test::E>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opESeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception, &::Test::AMI_TestIntf_opESeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opESeq_name);
        __ar = begin_opESeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opESeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::EList
IceProxy::Test::TestIntf::opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opEList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opEList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opEList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opEList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opEList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opEList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::EList
IceProxy::Test::TestIntf::end_opEList(::Test::EList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opEList_name);
    ::Test::EList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opEList_async(const ::Test::AMI_TestIntf_opEListPtr& __cb, const ::Test::EList& inSeq)
{
    ::Test::Callback_TestIntf_opEListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception, &::Test::AMI_TestIntf_opEList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opEList_name);
        __ar = begin_opEList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opEList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opEList_async(const ::Test::AMI_TestIntf_opEListPtr& __cb, const ::Test::EList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opEListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception, &::Test::AMI_TestIntf_opEList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opEList_name);
        __ar = begin_opEList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opEList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::CPrx>
IceProxy::Test::TestIntf::opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, std::deque< ::Test::CPrx>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCPrxSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCPrxSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCPrxSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::CPrx>
IceProxy::Test::TestIntf::end_opCPrxSeq(std::deque< ::Test::CPrx>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCPrxSeq_name);
    std::deque< ::Test::CPrx> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCPrxSeq_async(const ::Test::AMI_TestIntf_opCPrxSeqPtr& __cb, const std::deque< ::Test::CPrx>& inSeq)
{
    ::Test::Callback_TestIntf_opCPrxSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception, &::Test::AMI_TestIntf_opCPrxSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
        __ar = begin_opCPrxSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCPrxSeq_async(const ::Test::AMI_TestIntf_opCPrxSeqPtr& __cb, const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCPrxSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception, &::Test::AMI_TestIntf_opCPrxSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
        __ar = begin_opCPrxSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CPrxList
IceProxy::Test::TestIntf::opCPrxList(const ::Test::CPrxList& inSeq, ::Test::CPrxList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCPrxList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCPrxList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCPrxList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCPrxList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCPrxList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CPrxList
IceProxy::Test::TestIntf::end_opCPrxList(::Test::CPrxList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCPrxList_name);
    ::Test::CPrxList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCPrxList_async(const ::Test::AMI_TestIntf_opCPrxListPtr& __cb, const ::Test::CPrxList& inSeq)
{
    ::Test::Callback_TestIntf_opCPrxListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception, &::Test::AMI_TestIntf_opCPrxList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxList_name);
        __ar = begin_opCPrxList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCPrxList_async(const ::Test::AMI_TestIntf_opCPrxListPtr& __cb, const ::Test::CPrxList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCPrxListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception, &::Test::AMI_TestIntf_opCPrxList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxList_name);
        __ar = begin_opCPrxList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::CPtr>
IceProxy::Test::TestIntf::opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::CPtr>
IceProxy::Test::TestIntf::end_opCSeq(std::deque< ::Test::CPtr>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCSeq_name);
    std::deque< ::Test::CPtr> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCSeq_async(const ::Test::AMI_TestIntf_opCSeqPtr& __cb, const std::deque< ::Test::CPtr>& inSeq)
{
    ::Test::Callback_TestIntf_opCSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception, &::Test::AMI_TestIntf_opCSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCSeq_name);
        __ar = begin_opCSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCSeq_async(const ::Test::AMI_TestIntf_opCSeqPtr& __cb, const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception, &::Test::AMI_TestIntf_opCSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCSeq_name);
        __ar = begin_opCSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CList
IceProxy::Test::TestIntf::opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CList
IceProxy::Test::TestIntf::end_opCList(::Test::CList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCList_name);
    ::Test::CList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCList_async(const ::Test::AMI_TestIntf_opCListPtr& __cb, const ::Test::CList& inSeq)
{
    ::Test::Callback_TestIntf_opCListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception, &::Test::AMI_TestIntf_opCList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCList_name);
        __ar = begin_opCList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCList_async(const ::Test::AMI_TestIntf_opCListPtr& __cb, const ::Test::CList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception, &::Test::AMI_TestIntf_opCList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCList_name);
        __ar = begin_opCList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ClassStructPtr
IceProxy::Test::TestIntf::opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opClassStruct_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opClassStruct_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opClassStruct(inS, inSeq, outS, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opClassStruct_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opClassStruct_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opClassStruct_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ClassStructPtr
IceProxy::Test::TestIntf::end_opClassStruct(::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opClassStruct_name);
    ::Test::ClassStructPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outS);
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opClassStruct_async(const ::Test::AMI_TestIntf_opClassStructPtr& __cb, const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq)
{
    ::Test::Callback_TestIntf_opClassStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception, &::Test::AMI_TestIntf_opClassStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opClassStruct_name);
        __ar = begin_opClassStruct(inS, inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opClassStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opClassStruct_async(const ::Test::AMI_TestIntf_opClassStructPtr& __cb, const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opClassStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception, &::Test::AMI_TestIntf_opClassStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opClassStruct_name);
        __ar = begin_opClassStruct(inS, inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opClassStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::TestIntf::opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opOutArrayByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->opOutArrayByteSeq(org, copy, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutArrayByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opOutArrayByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_opOutArrayByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opOutArrayByteSeq_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(copy);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opOutArrayByteSeq(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& copy, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opOutArrayByteSeq_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(copy);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opOutArrayByteSeq_async(const ::Test::AMI_TestIntf_opOutArrayByteSeqPtr& __cb, const ::Test::ByteSeq& org)
{
    ::Test::Callback_TestIntf_opOutArrayByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception, &::Test::AMI_TestIntf_opOutArrayByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
        __ar = begin_opOutArrayByteSeq(org, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutArrayByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opOutArrayByteSeq_async(const ::Test::AMI_TestIntf_opOutArrayByteSeqPtr& __cb, const ::Test::ByteSeq& org, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opOutArrayByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception, &::Test::AMI_TestIntf_opOutArrayByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
        __ar = begin_opOutArrayByteSeq(org, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutArrayByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::TestIntf::opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opOutRangeByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->opOutRangeByteSeq(org, copy, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutRangeByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opOutRangeByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_opOutRangeByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opOutRangeByteSeq_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(copy);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opOutRangeByteSeq_async(const ::Test::AMI_TestIntf_opOutRangeByteSeqPtr& __cb, const ::Test::ByteSeq& org)
{
    ::Test::Callback_TestIntf_opOutRangeByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception, &::Test::AMI_TestIntf_opOutRangeByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
        __ar = begin_opOutRangeByteSeq(org, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutRangeByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opOutRangeByteSeq_async(const ::Test::AMI_TestIntf_opOutRangeByteSeqPtr& __cb, const ::Test::ByteSeq& org, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opOutRangeByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception, &::Test::AMI_TestIntf_opOutRangeByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
        __ar = begin_opOutRangeByteSeq(org, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutRangeByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::IntStringDict
IceProxy::Test::TestIntf::opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opIntStringDict_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opIntStringDict_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opIntStringDict(idict, odict, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opIntStringDict_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opIntStringDict_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opIntStringDict_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::IntStringDict
IceProxy::Test::TestIntf::end_opIntStringDict(::Test::IntStringDict& odict, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opIntStringDict_name);
    ::Test::IntStringDict __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opIntStringDict_async(const ::Test::AMI_TestIntf_opIntStringDictPtr& __cb, const ::Test::IntStringDict& idict)
{
    ::Test::Callback_TestIntf_opIntStringDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception, &::Test::AMI_TestIntf_opIntStringDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opIntStringDict_name);
        __ar = begin_opIntStringDict(idict, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opIntStringDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opIntStringDict_async(const ::Test::AMI_TestIntf_opIntStringDictPtr& __cb, const ::Test::IntStringDict& idict, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opIntStringDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception, &::Test::AMI_TestIntf_opIntStringDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opIntStringDict_name);
        __ar = begin_opIntStringDict(idict, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opIntStringDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceProxy::Test::TestIntf::opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVarDict_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVarDict_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVarDict(idict, odict, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVarDict_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVarDict_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVarDict_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceProxy::Test::TestIntf::end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVarDict_name);
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVarDict_async(const ::Test::AMI_TestIntf_opVarDictPtr& __cb, const ::Test::CustomMap<std::string, ::Ice::Int>& idict)
{
    ::Test::Callback_TestIntf_opVarDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception, &::Test::AMI_TestIntf_opVarDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVarDict_name);
        __ar = begin_opVarDict(idict, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVarDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVarDict_async(const ::Test::AMI_TestIntf_opVarDictPtr& __cb, const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVarDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception, &::Test::AMI_TestIntf_opVarDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVarDict_name);
        __ar = begin_opVarDict(idict, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVarDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ShortBuffer
IceProxy::Test::TestIntf::opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opShortBuffer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opShortBuffer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opShortBuffer(inS, outS, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opShortBuffer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opShortBuffer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opShortBuffer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ShortBuffer
IceProxy::Test::TestIntf::end_opShortBuffer(::Test::ShortBuffer& outS, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opShortBuffer_name);
    ::Test::ShortBuffer __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opShortBuffer_async(const ::Test::AMI_TestIntf_opShortBufferPtr& __cb, const ::Test::ShortBuffer& inS)
{
    ::Test::Callback_TestIntf_opShortBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception, &::Test::AMI_TestIntf_opShortBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opShortBuffer_name);
        __ar = begin_opShortBuffer(inS, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opShortBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opShortBuffer_async(const ::Test::AMI_TestIntf_opShortBufferPtr& __cb, const ::Test::ShortBuffer& inS, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opShortBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception, &::Test::AMI_TestIntf_opShortBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opShortBuffer_name);
        __ar = begin_opShortBuffer(inS, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opShortBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CustomBuffer<bool>
IceProxy::Test::TestIntf::opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolBuffer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolBuffer(inS, outS, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolBuffer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolBuffer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CustomBuffer<bool>
IceProxy::Test::TestIntf::end_opBoolBuffer(::Test::CustomBuffer<bool>& outS, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolBuffer_name);
    ::Test::CustomBuffer<bool> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolBuffer_async(const ::Test::AMI_TestIntf_opBoolBufferPtr& __cb, const ::Test::CustomBuffer<bool>& inS)
{
    ::Test::Callback_TestIntf_opBoolBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception, &::Test::AMI_TestIntf_opBoolBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
        __ar = begin_opBoolBuffer(inS, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolBuffer_async(const ::Test::AMI_TestIntf_opBoolBufferPtr& __cb, const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception, &::Test::AMI_TestIntf_opBoolBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
        __ar = begin_opBoolBuffer(inS, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BufferStruct
IceProxy::Test::TestIntf::opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBufferStruct_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBufferStruct_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBufferStruct(s, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBufferStruct_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBufferStruct_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBufferStruct_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BufferStruct
IceProxy::Test::TestIntf::end_opBufferStruct(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBufferStruct_name);
    ::Test::BufferStruct __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBufferStruct_async(const ::Test::AMI_TestIntf_opBufferStructPtr& __cb, const ::Test::BufferStruct& s)
{
    ::Test::Callback_TestIntf_opBufferStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception, &::Test::AMI_TestIntf_opBufferStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBufferStruct_name);
        __ar = begin_opBufferStruct(s, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBufferStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBufferStruct_async(const ::Test::AMI_TestIntf_opBufferStructPtr& __cb, const ::Test::BufferStruct& s, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBufferStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception, &::Test::AMI_TestIntf_opBufferStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBufferStruct_name);
        __ar = begin_opBufferStruct(s, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBufferStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::TestIntf::shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__shutdown_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__shutdown_name);
}

bool
IceProxy::Test::TestIntf::shutdown_async(const ::Test::AMI_TestIntf_shutdownPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception, &::Test::AMI_TestIntf_shutdown::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_shutdown(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::shutdown_async(const ::Test::AMI_TestIntf_shutdownPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception, &::Test::AMI_TestIntf_shutdown::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_shutdown(&__ctx, __del);
    return __ar->sentSynchronously();
}

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::TestIntf);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::TestIntf);
}

::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::__newInstance() const
{
    return new TestIntf;
}

::Test::DoubleSeq
IceDelegateM::Test::TestIntf::opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opDoubleArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::DoubleSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolSeq
IceDelegateM::Test::TestIntf::opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolSeq
IceDelegateM::Test::TestIntf::opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolRange_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteRange_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableRange_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolSeq
IceDelegateM::Test::TestIntf::opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolRangeType_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteRangeType_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableRangeType_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque<bool>
IceDelegateM::Test::TestIntf::opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque<bool> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolList
IceDelegateM::Test::TestIntf::opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Ice::Byte>
IceDelegateM::Test::TestIntf::opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Ice::Byte> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

MyByteSeq
IceDelegateM::Test::TestIntf::opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opMyByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    MyByteSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque<std::string>
IceDelegateM::Test::TestIntf::opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque<std::string> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::StringList
IceDelegateM::Test::TestIntf::opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::StringList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::Fixed>
IceDelegateM::Test::TestIntf::opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opFixedSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::Fixed> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::FixedList
IceDelegateM::Test::TestIntf::opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opFixedList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::FixedList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::Variable>
IceDelegateM::Test::TestIntf::opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::Variable> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::StringStringDict>
IceDelegateM::Test::TestIntf::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringStringDictSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::StringStringDict> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::StringStringDictList
IceDelegateM::Test::TestIntf::opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringStringDictList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::StringStringDictList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::E>
IceDelegateM::Test::TestIntf::opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opESeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::E> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::EList
IceDelegateM::Test::TestIntf::opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opEList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::EList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::CPrx>
IceDelegateM::Test::TestIntf::opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, std::deque< ::Test::CPrx>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCPrxSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::CPrx> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CPrxList
IceDelegateM::Test::TestIntf::opCPrxList(const ::Test::CPrxList& inSeq, ::Test::CPrxList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCPrxList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CPrxList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::CPtr>
IceDelegateM::Test::TestIntf::opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::CPtr> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CList
IceDelegateM::Test::TestIntf::opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ClassStructPtr
IceDelegateM::Test::TestIntf::opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opClassStruct_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ClassStructPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outS);
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opOutArrayByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(copy);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opOutRangeByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(copy);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::IntStringDict
IceDelegateM::Test::TestIntf::opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opIntStringDict_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::IntStringDict __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceDelegateM::Test::TestIntf::opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVarDict_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ShortBuffer
IceDelegateM::Test::TestIntf::opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opShortBuffer_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ShortBuffer __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CustomBuffer<bool>
IceDelegateM::Test::TestIntf::opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolBuffer_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CustomBuffer<bool> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BufferStruct
IceDelegateM::Test::TestIntf::opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBufferStruct_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BufferStruct __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__shutdown_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Test::DoubleSeq
IceDelegateD::Test::TestIntf::opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, ::Test::DoubleSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::DoubleSeq(); // to avoid a warning with some compilers;
}

::Test::BoolSeq
IceDelegateD::Test::TestIntf::opBoolArray(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BoolSeq(); // to avoid a warning with some compilers;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::ByteList(); // to avoid a warning with some compilers;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::VariableList(); // to avoid a warning with some compilers;
}

::Test::BoolSeq
IceDelegateD::Test::TestIntf::opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BoolSeq(); // to avoid a warning with some compilers;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::ByteList(); // to avoid a warning with some compilers;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::VariableList(); // to avoid a warning with some compilers;
}

::Test::BoolSeq
IceDelegateD::Test::TestIntf::opBoolRangeType(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BoolSeq(); // to avoid a warning with some compilers;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::ByteList(); // to avoid a warning with some compilers;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::VariableList(); // to avoid a warning with some compilers;
}

std::deque<bool>
IceDelegateD::Test::TestIntf::opBoolSeq(const std::deque<bool>&, std::deque<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque<bool>(); // to avoid a warning with some compilers;
}

::Test::BoolList
IceDelegateD::Test::TestIntf::opBoolList(const ::Test::BoolList&, ::Test::BoolList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BoolList(); // to avoid a warning with some compilers;
}

std::deque< ::Ice::Byte>
IceDelegateD::Test::TestIntf::opByteSeq(const std::deque< ::Ice::Byte>&, std::deque< ::Ice::Byte>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque< ::Ice::Byte>(); // to avoid a warning with some compilers;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteList(const ::Test::ByteList&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::ByteList(); // to avoid a warning with some compilers;
}

MyByteSeq
IceDelegateD::Test::TestIntf::opMyByteSeq(const MyByteSeq&, MyByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return MyByteSeq(); // to avoid a warning with some compilers;
}

std::deque<std::string>
IceDelegateD::Test::TestIntf::opStringSeq(const std::deque<std::string>&, std::deque<std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque<std::string>(); // to avoid a warning with some compilers;
}

::Test::StringList
IceDelegateD::Test::TestIntf::opStringList(const ::Test::StringList&, ::Test::StringList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::StringList(); // to avoid a warning with some compilers;
}

std::deque< ::Test::Fixed>
IceDelegateD::Test::TestIntf::opFixedSeq(const std::deque< ::Test::Fixed>&, std::deque< ::Test::Fixed>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque< ::Test::Fixed>(); // to avoid a warning with some compilers;
}

::Test::FixedList
IceDelegateD::Test::TestIntf::opFixedList(const ::Test::FixedList&, ::Test::FixedList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::FixedList(); // to avoid a warning with some compilers;
}

std::deque< ::Test::Variable>
IceDelegateD::Test::TestIntf::opVariableSeq(const std::deque< ::Test::Variable>&, std::deque< ::Test::Variable>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque< ::Test::Variable>(); // to avoid a warning with some compilers;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableList(const ::Test::VariableList&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::VariableList(); // to avoid a warning with some compilers;
}

std::deque< ::Test::StringStringDict>
IceDelegateD::Test::TestIntf::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, std::deque< ::Test::StringStringDict>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque< ::Test::StringStringDict>(); // to avoid a warning with some compilers;
}

::Test::StringStringDictList
IceDelegateD::Test::TestIntf::opStringStringDictList(const ::Test::StringStringDictList&, ::Test::StringStringDictList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::StringStringDictList(); // to avoid a warning with some compilers;
}

std::deque< ::Test::E>
IceDelegateD::Test::TestIntf::opESeq(const std::deque< ::Test::E>&, std::deque< ::Test::E>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque< ::Test::E>(); // to avoid a warning with some compilers;
}

::Test::EList
IceDelegateD::Test::TestIntf::opEList(const ::Test::EList&, ::Test::EList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::EList(); // to avoid a warning with some compilers;
}

std::deque< ::Test::CPrx>
IceDelegateD::Test::TestIntf::opCPrxSeq(const std::deque< ::Test::CPrx>&, std::deque< ::Test::CPrx>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque< ::Test::CPrx>(); // to avoid a warning with some compilers;
}

::Test::CPrxList
IceDelegateD::Test::TestIntf::opCPrxList(const ::Test::CPrxList&, ::Test::CPrxList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::CPrxList(); // to avoid a warning with some compilers;
}

std::deque< ::Test::CPtr>
IceDelegateD::Test::TestIntf::opCSeq(const std::deque< ::Test::CPtr>&, std::deque< ::Test::CPtr>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return std::deque< ::Test::CPtr>(); // to avoid a warning with some compilers;
}

::Test::CList
IceDelegateD::Test::TestIntf::opCList(const ::Test::CList&, ::Test::CList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::CList(); // to avoid a warning with some compilers;
}

::Test::ClassStructPtr
IceDelegateD::Test::TestIntf::opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, ::Test::ClassStructPtr&, ::Test::ClassStructSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::ClassStructPtr(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::opOutArrayByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::opOutRangeByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Test::IntStringDict
IceDelegateD::Test::TestIntf::opIntStringDict(const ::Test::IntStringDict&, ::Test::IntStringDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::IntStringDict(); // to avoid a warning with some compilers;
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceDelegateD::Test::TestIntf::opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::CustomMap< ::Ice::Long, ::Ice::Long>(); // to avoid a warning with some compilers;
}

::Test::ShortBuffer
IceDelegateD::Test::TestIntf::opShortBuffer(const ::Test::ShortBuffer&, ::Test::ShortBuffer&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::ShortBuffer(); // to avoid a warning with some compilers;
}

::Test::CustomBuffer<bool>
IceDelegateD::Test::TestIntf::opBoolBuffer(const ::Test::CustomBuffer<bool>&, ::Test::CustomBuffer<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::CustomBuffer<bool>(); // to avoid a warning with some compilers;
}

::Test::BufferStruct
IceDelegateD::Test::TestIntf::opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BufferStruct(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Object* Test::upCast(::Test::C* p) { return p; }
::Ice::ObjectPtr
Test::C::ice_clone() const
{
    ::Ice::Object* __p = new C(*this);
    return __p;
}

namespace
{
const ::std::string __Test__C_ids[2] =
{
    "::Ice::Object",
    "::Test::C"
};

}

bool
Test::C::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__C_ids, __Test__C_ids + 2, _s);
}

::std::vector< ::std::string>
Test::C::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__C_ids[0], &__Test__C_ids[2]);
}

const ::std::string&
Test::C::ice_id(const ::Ice::Current&) const
{
    return __Test__C_ids[1];
}

const ::std::string&
Test::C::ice_staticId()
{
    return __Test__C_ids[1];
}

void
Test::C::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::C::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__C : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::C::ice_staticId());
        return new ::Test::C;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__C_Ptr = new __F__Test__C;

class __F__Test__C__Init
{
public:

    __F__Test__C__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::C::ice_staticId(), __F__Test__C_Ptr);
    }

    ~__F__Test__C__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::C::ice_staticId());
    }
};

const __F__Test__C__Init __F__Test__C__i;

}

const ::Ice::ObjectFactoryPtr&
Test::C::ice_factory()
{
    return __F__Test__C_Ptr;
}

void 
Test::__patch(CPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::CPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::C::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::DictClass* p) { return p; }
::Ice::ObjectPtr
Test::DictClass::ice_clone() const
{
    ::Ice::Object* __p = new DictClass(*this);
    return __p;
}

namespace
{
const ::std::string __Test__DictClass_ids[2] =
{
    "::Ice::Object",
    "::Test::DictClass"
};

}

bool
Test::DictClass::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__DictClass_ids, __Test__DictClass_ids + 2, _s);
}

::std::vector< ::std::string>
Test::DictClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__DictClass_ids[0], &__Test__DictClass_ids[2]);
}

const ::std::string&
Test::DictClass::ice_id(const ::Ice::Current&) const
{
    return __Test__DictClass_ids[1];
}

const ::std::string&
Test::DictClass::ice_staticId()
{
    return __Test__DictClass_ids[1];
}

void
Test::DictClass::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(isdict);
    __os->endWriteSlice();
}

void
Test::DictClass::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(isdict);
    __is->endReadSlice();
}

namespace
{

class __F__Test__DictClass : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::DictClass::ice_staticId());
        return new ::Test::DictClass;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__DictClass_Ptr = new __F__Test__DictClass;

class __F__Test__DictClass__Init
{
public:

    __F__Test__DictClass__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::DictClass::ice_staticId(), __F__Test__DictClass_Ptr);
    }

    ~__F__Test__DictClass__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::DictClass::ice_staticId());
    }
};

const __F__Test__DictClass__Init __F__Test__DictClass__i;

}

const ::Ice::ObjectFactoryPtr&
Test::DictClass::ice_factory()
{
    return __F__Test__DictClass_Ptr;
}

void 
Test::__patch(DictClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::DictClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::DictClass::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::TestIntf* p) { return p; }
::Ice::ObjectPtr
Test::TestIntf::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__TestIntf_ids, __Test__TestIntf_ids + 2, _s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__TestIntf_ids[0], &__Test__TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return __Test__TestIntf_ids[1];
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    return __Test__TestIntf_ids[1];
}

::Ice::DispatchStatus
Test::TestIntf::___opDoubleArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const ::Ice::Double*, const ::Ice::Double*> inSeq;
    ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ___inSeq;
    __is->read(___inSeq);
    inSeq = ___inSeq.second;
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opDoubleArrayPtr __cb = new IceAsync::Test::AMD_TestIntf_opDoubleArray(__inS);
    try
    {
        opDoubleArray_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const bool*, const bool*> inSeq;
    ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___inSeq;
    __is->read(___inSeq);
    inSeq = ___inSeq.second;
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opBoolArrayPtr __cb = new IceAsync::Test::AMD_TestIntf_opBoolArray(__inS);
    try
    {
        opBoolArray_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opByteArrayPtr __cb = new IceAsync::Test::AMD_TestIntf_opByteArray(__inS);
    try
    {
        opByteArray_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const ::Test::Variable*, const ::Test::Variable*> inSeq;
    ::std::vector< ::Test::Variable> ___inSeq;
    __is->read(___inSeq);
    if(!___inSeq.empty())
    {
        inSeq.first = &___inSeq[0];
        inSeq.second = inSeq.first + ___inSeq.size();
    }
    else
    {
        inSeq.first = inSeq.second = 0;
    }
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opVariableArrayPtr __cb = new IceAsync::Test::AMD_TestIntf_opVariableArray(__inS);
    try
    {
        opVariableArray_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> inSeq;
    ::Test::BoolSeq ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opBoolRangePtr __cb = new IceAsync::Test::AMD_TestIntf_opBoolRange(__inS);
    try
    {
        opBoolRange_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> inSeq;
    ::Test::ByteList ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opByteRangePtr __cb = new IceAsync::Test::AMD_TestIntf_opByteRange(__inS);
    try
    {
        opByteRange_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> inSeq;
    ::Test::VariableList ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opVariableRangePtr __cb = new IceAsync::Test::AMD_TestIntf_opVariableRange(__inS);
    try
    {
        opVariableRange_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolRangeType(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const bool*, const bool*> inSeq;
    ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___inSeq;
    __is->read(___inSeq);
    inSeq = ___inSeq.second;
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opBoolRangeTypePtr __cb = new IceAsync::Test::AMD_TestIntf_opBoolRangeType(__inS);
    try
    {
        opBoolRangeType_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteRangeType(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> inSeq;
    ::Test::ByteList ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opByteRangeTypePtr __cb = new IceAsync::Test::AMD_TestIntf_opByteRangeType(__inS);
    try
    {
        opByteRangeType_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableRangeType(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> inSeq;
    std::deque< ::Test::Variable> ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opVariableRangeTypePtr __cb = new IceAsync::Test::AMD_TestIntf_opVariableRangeType(__inS);
    try
    {
        opVariableRangeType_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque<bool> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opBoolSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opBoolSeq(__inS);
    try
    {
        opBoolSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::BoolList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opBoolListPtr __cb = new IceAsync::Test::AMD_TestIntf_opBoolList(__inS);
    try
    {
        opBoolList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Ice::Byte> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opByteSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opByteSeq(__inS);
    try
    {
        opByteSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ByteList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opByteListPtr __cb = new IceAsync::Test::AMD_TestIntf_opByteList(__inS);
    try
    {
        opByteList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opMyByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    MyByteSeq inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opMyByteSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opMyByteSeq(__inS);
    try
    {
        opMyByteSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque<std::string> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opStringSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opStringSeq(__inS);
    try
    {
        opStringSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::StringList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opStringListPtr __cb = new IceAsync::Test::AMD_TestIntf_opStringList(__inS);
    try
    {
        opStringList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opFixedSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::Fixed> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opFixedSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opFixedSeq(__inS);
    try
    {
        opFixedSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opFixedList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::FixedList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opFixedListPtr __cb = new IceAsync::Test::AMD_TestIntf_opFixedList(__inS);
    try
    {
        opFixedList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::Variable> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opVariableSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opVariableSeq(__inS);
    try
    {
        opVariableSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::VariableList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opVariableListPtr __cb = new IceAsync::Test::AMD_TestIntf_opVariableList(__inS);
    try
    {
        opVariableList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringStringDictSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::StringStringDict> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opStringStringDictSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opStringStringDictSeq(__inS);
    try
    {
        opStringStringDictSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringStringDictList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::StringStringDictList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opStringStringDictListPtr __cb = new IceAsync::Test::AMD_TestIntf_opStringStringDictList(__inS);
    try
    {
        opStringStringDictList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opESeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::E> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opESeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opESeq(__inS);
    try
    {
        opESeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opEList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::EList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opEListPtr __cb = new IceAsync::Test::AMD_TestIntf_opEList(__inS);
    try
    {
        opEList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opCPrxSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::CPrx> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opCPrxSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opCPrxSeq(__inS);
    try
    {
        opCPrxSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opCPrxList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CPrxList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opCPrxListPtr __cb = new IceAsync::Test::AMD_TestIntf_opCPrxList(__inS);
    try
    {
        opCPrxList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opCSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::CPtr> inSeq;
    __is->read(inSeq);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opCSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opCSeq(__inS);
    try
    {
        opCSeq_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opCList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CList inSeq;
    __is->read(inSeq);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opCListPtr __cb = new IceAsync::Test::AMD_TestIntf_opCList(__inS);
    try
    {
        opCList_async(__cb, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opClassStruct(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ClassStructPtr inS;
    ::Test::ClassStructSeq inSeq;
    __is->read(inS);
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opClassStructPtr __cb = new IceAsync::Test::AMD_TestIntf_opClassStruct(__inS);
    try
    {
        opClassStruct_async(__cb, inS, inSeq, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opOutArrayByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ByteSeq org;
    __is->read(org);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opOutArrayByteSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opOutArrayByteSeq(__inS);
    try
    {
        opOutArrayByteSeq_async(__cb, org, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opOutRangeByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ByteSeq org;
    __is->read(org);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opOutRangeByteSeqPtr __cb = new IceAsync::Test::AMD_TestIntf_opOutRangeByteSeq(__inS);
    try
    {
        opOutRangeByteSeq_async(__cb, org, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opIntStringDict(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::IntStringDict idict;
    __is->read(idict);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opIntStringDictPtr __cb = new IceAsync::Test::AMD_TestIntf_opIntStringDict(__inS);
    try
    {
        opIntStringDict_async(__cb, idict, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opVarDict(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> idict;
    __is->read(idict);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opVarDictPtr __cb = new IceAsync::Test::AMD_TestIntf_opVarDict(__inS);
    try
    {
        opVarDict_async(__cb, idict, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opShortBuffer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ShortBuffer inS;
    __is->read(inS);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opShortBufferPtr __cb = new IceAsync::Test::AMD_TestIntf_opShortBuffer(__inS);
    try
    {
        opShortBuffer_async(__cb, inS, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolBuffer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CustomBuffer<bool> inS;
    __is->read(inS);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opBoolBufferPtr __cb = new IceAsync::Test::AMD_TestIntf_opBoolBuffer(__inS);
    try
    {
        opBoolBuffer_async(__cb, inS, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___opBufferStruct(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::BufferStruct s;
    __is->read(s);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_opBufferStructPtr __cb = new IceAsync::Test::AMD_TestIntf_opBufferStruct(__inS);
    try
    {
        opBufferStruct_async(__cb, s, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_shutdownPtr __cb = new IceAsync::Test::AMD_TestIntf_shutdown(__inS);
    try
    {
        shutdown_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __Test__TestIntf_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolArray",
    "opBoolBuffer",
    "opBoolList",
    "opBoolRange",
    "opBoolRangeType",
    "opBoolSeq",
    "opBufferStruct",
    "opByteArray",
    "opByteList",
    "opByteRange",
    "opByteRangeType",
    "opByteSeq",
    "opCList",
    "opCPrxList",
    "opCPrxSeq",
    "opCSeq",
    "opClassStruct",
    "opDoubleArray",
    "opEList",
    "opESeq",
    "opFixedList",
    "opFixedSeq",
    "opIntStringDict",
    "opMyByteSeq",
    "opOutArrayByteSeq",
    "opOutRangeByteSeq",
    "opShortBuffer",
    "opStringList",
    "opStringSeq",
    "opStringStringDictList",
    "opStringStringDictSeq",
    "opVarDict",
    "opVariableArray",
    "opVariableList",
    "opVariableRange",
    "opVariableRangeType",
    "opVariableSeq",
    "shutdown"
};

}

::Ice::DispatchStatus
Test::TestIntf::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__TestIntf_all, __Test__TestIntf_all + 42, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__TestIntf_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___opBoolArray(in, current);
        }
        case 5:
        {
            return ___opBoolBuffer(in, current);
        }
        case 6:
        {
            return ___opBoolList(in, current);
        }
        case 7:
        {
            return ___opBoolRange(in, current);
        }
        case 8:
        {
            return ___opBoolRangeType(in, current);
        }
        case 9:
        {
            return ___opBoolSeq(in, current);
        }
        case 10:
        {
            return ___opBufferStruct(in, current);
        }
        case 11:
        {
            return ___opByteArray(in, current);
        }
        case 12:
        {
            return ___opByteList(in, current);
        }
        case 13:
        {
            return ___opByteRange(in, current);
        }
        case 14:
        {
            return ___opByteRangeType(in, current);
        }
        case 15:
        {
            return ___opByteSeq(in, current);
        }
        case 16:
        {
            return ___opCList(in, current);
        }
        case 17:
        {
            return ___opCPrxList(in, current);
        }
        case 18:
        {
            return ___opCPrxSeq(in, current);
        }
        case 19:
        {
            return ___opCSeq(in, current);
        }
        case 20:
        {
            return ___opClassStruct(in, current);
        }
        case 21:
        {
            return ___opDoubleArray(in, current);
        }
        case 22:
        {
            return ___opEList(in, current);
        }
        case 23:
        {
            return ___opESeq(in, current);
        }
        case 24:
        {
            return ___opFixedList(in, current);
        }
        case 25:
        {
            return ___opFixedSeq(in, current);
        }
        case 26:
        {
            return ___opIntStringDict(in, current);
        }
        case 27:
        {
            return ___opMyByteSeq(in, current);
        }
        case 28:
        {
            return ___opOutArrayByteSeq(in, current);
        }
        case 29:
        {
            return ___opOutRangeByteSeq(in, current);
        }
        case 30:
        {
            return ___opShortBuffer(in, current);
        }
        case 31:
        {
            return ___opStringList(in, current);
        }
        case 32:
        {
            return ___opStringSeq(in, current);
        }
        case 33:
        {
            return ___opStringStringDictList(in, current);
        }
        case 34:
        {
            return ___opStringStringDictSeq(in, current);
        }
        case 35:
        {
            return ___opVarDict(in, current);
        }
        case 36:
        {
            return ___opVariableArray(in, current);
        }
        case 37:
        {
            return ___opVariableList(in, current);
        }
        case 38:
        {
            return ___opVariableRange(in, current);
        }
        case 39:
        {
            return ___opVariableRangeType(in, current);
        }
        case 40:
        {
            return ___opVariableSeq(in, current);
        }
        case 41:
        {
            return ___shutdown(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::TestIntf::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::TestIntf::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(TestIntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::TestIntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::TestIntf::ice_staticId(), v);
    }
}
