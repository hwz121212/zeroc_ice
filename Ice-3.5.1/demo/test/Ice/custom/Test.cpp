// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Test.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Test__TestIntf__opDoubleArray_name = "opDoubleArray";

const ::std::string __Test__TestIntf__opBoolArray_name = "opBoolArray";

const ::std::string __Test__TestIntf__opByteArray_name = "opByteArray";

const ::std::string __Test__TestIntf__opVariableArray_name = "opVariableArray";

const ::std::string __Test__TestIntf__opBoolRange_name = "opBoolRange";

const ::std::string __Test__TestIntf__opByteRange_name = "opByteRange";

const ::std::string __Test__TestIntf__opVariableRange_name = "opVariableRange";

const ::std::string __Test__TestIntf__opBoolRangeType_name = "opBoolRangeType";

const ::std::string __Test__TestIntf__opByteRangeType_name = "opByteRangeType";

const ::std::string __Test__TestIntf__opVariableRangeType_name = "opVariableRangeType";

const ::std::string __Test__TestIntf__opBoolSeq_name = "opBoolSeq";

const ::std::string __Test__TestIntf__opBoolList_name = "opBoolList";

const ::std::string __Test__TestIntf__opBoolDequeList_name = "opBoolDequeList";

const ::std::string __Test__TestIntf__opBoolDequeListArray_name = "opBoolDequeListArray";

const ::std::string __Test__TestIntf__opBoolDequeListRange_name = "opBoolDequeListRange";

const ::std::string __Test__TestIntf__opByteSeq_name = "opByteSeq";

const ::std::string __Test__TestIntf__opByteList_name = "opByteList";

const ::std::string __Test__TestIntf__opMyByteSeq_name = "opMyByteSeq";

const ::std::string __Test__TestIntf__opStringSeq_name = "opStringSeq";

const ::std::string __Test__TestIntf__opStringList_name = "opStringList";

const ::std::string __Test__TestIntf__opFixedSeq_name = "opFixedSeq";

const ::std::string __Test__TestIntf__opFixedList_name = "opFixedList";

const ::std::string __Test__TestIntf__opVariableSeq_name = "opVariableSeq";

const ::std::string __Test__TestIntf__opVariableList_name = "opVariableList";

const ::std::string __Test__TestIntf__opStringStringDictSeq_name = "opStringStringDictSeq";

const ::std::string __Test__TestIntf__opStringStringDictList_name = "opStringStringDictList";

const ::std::string __Test__TestIntf__opESeq_name = "opESeq";

const ::std::string __Test__TestIntf__opEList_name = "opEList";

const ::std::string __Test__TestIntf__opCPrxSeq_name = "opCPrxSeq";

const ::std::string __Test__TestIntf__opCPrxList_name = "opCPrxList";

const ::std::string __Test__TestIntf__opCSeq_name = "opCSeq";

const ::std::string __Test__TestIntf__opCList_name = "opCList";

const ::std::string __Test__TestIntf__opClassStruct_name = "opClassStruct";

const ::std::string __Test__TestIntf__opOutArrayByteSeq_name = "opOutArrayByteSeq";

const ::std::string __Test__TestIntf__opOutRangeByteSeq_name = "opOutRangeByteSeq";

const ::std::string __Test__TestIntf__opIntStringDict_name = "opIntStringDict";

const ::std::string __Test__TestIntf__opVarDict_name = "opVarDict";

const ::std::string __Test__TestIntf__opShortBuffer_name = "opShortBuffer";

const ::std::string __Test__TestIntf__opBoolBuffer_name = "opBoolBuffer";

const ::std::string __Test__TestIntf__opBufferStruct_name = "opBufferStruct";

const ::std::string __Test__TestIntf__shutdown_name = "shutdown";

}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::C* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::C>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::C;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::C::ice_staticId()
{
    return ::Test::C::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::C::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::C);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::C::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::C);
}

::IceProxy::Ice::Object*
IceProxy::Test::C::__newInstance() const
{
    return new C;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::DictClass* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::DictClass>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::DictClass;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::DictClass::ice_staticId()
{
    return ::Test::DictClass::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::DictClass::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::DictClass);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::DictClass::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::DictClass);
}

::IceProxy::Ice::Object*
IceProxy::Test::DictClass::__newInstance() const
{
    return new DictClass;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::TestIntf* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::TestIntf;
        v->__copyFrom(proxy);
    }
}

::Test::DoubleSeq
IceProxy::Test::TestIntf::opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opDoubleArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opDoubleArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opDoubleArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opDoubleArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opDoubleArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opDoubleArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::DoubleSeq
IceProxy::Test::TestIntf::end_opDoubleArray(::Test::DoubleSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opDoubleArray_name);
    ::Test::DoubleSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opDoubleArray(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& outSeq, ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opDoubleArray_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opDoubleArray_async(const ::Test::AMI_TestIntf_opDoubleArrayPtr& __cb, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq)
{
    ::Test::Callback_TestIntf_opDoubleArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception, &::Test::AMI_TestIntf_opDoubleArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opDoubleArray_name);
        __ar = begin_opDoubleArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opDoubleArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opDoubleArray_async(const ::Test::AMI_TestIntf_opDoubleArrayPtr& __cb, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opDoubleArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception, &::Test::AMI_TestIntf_opDoubleArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opDoubleArray(__cb, &::Test::AMI_TestIntf_opDoubleArray::__response, &::Test::AMI_TestIntf_opDoubleArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opDoubleArray_name);
        __ar = begin_opDoubleArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opDoubleArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolSeq
IceProxy::Test::TestIntf::opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolArray(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolArray_name);
    ::Test::BoolSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opBoolArray(::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& outSeq, ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolArray_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opBoolArray_async(const ::Test::AMI_TestIntf_opBoolArrayPtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception, &::Test::AMI_TestIntf_opBoolArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolArray_name);
        __ar = begin_opBoolArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolArray_async(const ::Test::AMI_TestIntf_opBoolArrayPtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception, &::Test::AMI_TestIntf_opBoolArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolArray(__cb, &::Test::AMI_TestIntf_opBoolArray::__response, &::Test::AMI_TestIntf_opBoolArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolArray_name);
        __ar = begin_opBoolArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteArray(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteArray_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& outSeq, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteArray_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opByteArray_async(const ::Test::AMI_TestIntf_opByteArrayPtr& __cb, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq)
{
    ::Test::Callback_TestIntf_opByteArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception, &::Test::AMI_TestIntf_opByteArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteArray_name);
        __ar = begin_opByteArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteArray_async(const ::Test::AMI_TestIntf_opByteArrayPtr& __cb, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception, &::Test::AMI_TestIntf_opByteArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteArray(__cb, &::Test::AMI_TestIntf_opByteArray::__response, &::Test::AMI_TestIntf_opByteArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteArray_name);
        __ar = begin_opByteArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableArray(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableArray_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opVariableArray(::std::vector< ::Test::Variable>& outSeq, ::std::vector< ::Test::Variable>& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableArray_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opVariableArray_async(const ::Test::AMI_TestIntf_opVariableArrayPtr& __cb, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception, &::Test::AMI_TestIntf_opVariableArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableArray_name);
        __ar = begin_opVariableArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableArray_async(const ::Test::AMI_TestIntf_opVariableArrayPtr& __cb, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception, &::Test::AMI_TestIntf_opVariableArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableArray(__cb, &::Test::AMI_TestIntf_opVariableArray::__response, &::Test::AMI_TestIntf_opVariableArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableArray_name);
        __ar = begin_opVariableArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolSeq
IceProxy::Test::TestIntf::opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolRange_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolRange_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolRange(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRange_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolRange(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolRange_name);
    ::Test::BoolSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolRange_async(const ::Test::AMI_TestIntf_opBoolRangePtr& __cb, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception, &::Test::AMI_TestIntf_opBoolRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRange_name);
        __ar = begin_opBoolRange(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolRange_async(const ::Test::AMI_TestIntf_opBoolRangePtr& __cb, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception, &::Test::AMI_TestIntf_opBoolRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRange(__cb, &::Test::AMI_TestIntf_opBoolRange::__response, &::Test::AMI_TestIntf_opBoolRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRange_name);
        __ar = begin_opBoolRange(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteRange_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteRange_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteRange(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRange_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteRange(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteRange_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteRange_async(const ::Test::AMI_TestIntf_opByteRangePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opByteRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception, &::Test::AMI_TestIntf_opByteRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRange_name);
        __ar = begin_opByteRange(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteRange_async(const ::Test::AMI_TestIntf_opByteRangePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception, &::Test::AMI_TestIntf_opByteRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRange(__cb, &::Test::AMI_TestIntf_opByteRange::__response, &::Test::AMI_TestIntf_opByteRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRange_name);
        __ar = begin_opByteRange(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableRange_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableRange_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableRange(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRange_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableRange(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableRange_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableRange_async(const ::Test::AMI_TestIntf_opVariableRangePtr& __cb, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception, &::Test::AMI_TestIntf_opVariableRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRange_name);
        __ar = begin_opVariableRange(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableRange_async(const ::Test::AMI_TestIntf_opVariableRangePtr& __cb, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception, &::Test::AMI_TestIntf_opVariableRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRange(__cb, &::Test::AMI_TestIntf_opVariableRange::__response, &::Test::AMI_TestIntf_opVariableRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRange_name);
        __ar = begin_opVariableRange(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolSeq
IceProxy::Test::TestIntf::opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolRangeType_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolRangeType(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRangeType_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolRangeType_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolRangeType(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolRangeType_name);
    ::Test::BoolSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opBoolRangeType(::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& outSeq, ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolRangeType_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opBoolRangeType_async(const ::Test::AMI_TestIntf_opBoolRangeTypePtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception, &::Test::AMI_TestIntf_opBoolRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
        __ar = begin_opBoolRangeType(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolRangeType_async(const ::Test::AMI_TestIntf_opBoolRangeTypePtr& __cb, const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception, &::Test::AMI_TestIntf_opBoolRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolRangeType(__cb, &::Test::AMI_TestIntf_opBoolRangeType::__response, &::Test::AMI_TestIntf_opBoolRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolRangeType_name);
        __ar = begin_opBoolRangeType(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteRangeType_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteRangeType_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteRangeType(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteRangeType_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRangeType_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteRangeType_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteRangeType(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteRangeType_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteRangeType_async(const ::Test::AMI_TestIntf_opByteRangeTypePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opByteRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception, &::Test::AMI_TestIntf_opByteRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRangeType_name);
        __ar = begin_opByteRangeType(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteRangeType_async(const ::Test::AMI_TestIntf_opByteRangeTypePtr& __cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception, &::Test::AMI_TestIntf_opByteRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteRangeType(__cb, &::Test::AMI_TestIntf_opByteRangeType::__response, &::Test::AMI_TestIntf_opByteRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteRangeType_name);
        __ar = begin_opByteRangeType(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableRangeType_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableRangeType(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRangeType_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableRangeType_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableRangeType(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableRangeType_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opVariableRangeType(std::deque< ::Test::Variable>& outSeq, std::deque< ::Test::Variable>& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableRangeType_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opVariableRangeType_async(const ::Test::AMI_TestIntf_opVariableRangeTypePtr& __cb, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception, &::Test::AMI_TestIntf_opVariableRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
        __ar = begin_opVariableRangeType(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableRangeType_async(const ::Test::AMI_TestIntf_opVariableRangeTypePtr& __cb, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableRangeTypePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception, &::Test::AMI_TestIntf_opVariableRangeType::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableRangeType(__cb, &::Test::AMI_TestIntf_opVariableRangeType::__response, &::Test::AMI_TestIntf_opVariableRangeType::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableRangeType_name);
        __ar = begin_opVariableRangeType(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableRangeType_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque<bool>
IceProxy::Test::TestIntf::opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque<bool>
IceProxy::Test::TestIntf::end_opBoolSeq(std::deque<bool>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolSeq_name);
    std::deque<bool> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolSeq_async(const ::Test::AMI_TestIntf_opBoolSeqPtr& __cb, const std::deque<bool>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception, &::Test::AMI_TestIntf_opBoolSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolSeq_name);
        __ar = begin_opBoolSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolSeq_async(const ::Test::AMI_TestIntf_opBoolSeqPtr& __cb, const std::deque<bool>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception, &::Test::AMI_TestIntf_opBoolSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolSeq(__cb, &::Test::AMI_TestIntf_opBoolSeq::__response, &::Test::AMI_TestIntf_opBoolSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolSeq_name);
        __ar = begin_opBoolSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolList
IceProxy::Test::TestIntf::opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolList
IceProxy::Test::TestIntf::end_opBoolList(::Test::BoolList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolList_name);
    ::Test::BoolList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolList_async(const ::Test::AMI_TestIntf_opBoolListPtr& __cb, const ::Test::BoolList& inSeq)
{
    ::Test::Callback_TestIntf_opBoolListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception, &::Test::AMI_TestIntf_opBoolList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolList_name);
        __ar = begin_opBoolList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolList_async(const ::Test::AMI_TestIntf_opBoolListPtr& __cb, const ::Test::BoolList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception, &::Test::AMI_TestIntf_opBoolList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolList(__cb, &::Test::AMI_TestIntf_opBoolList::__response, &::Test::AMI_TestIntf_opBoolList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolList_name);
        __ar = begin_opBoolList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::opBoolDequeList(const ::Test::BoolDequeList& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolDequeList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolDequeList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolDequeList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolDequeList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolDequeList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::end_opBoolDequeList(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolDequeList_name);
    ::Test::BoolDequeList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolDequeList_async(const ::Test::AMI_TestIntf_opBoolDequeListPtr& __cb, const ::Test::BoolDequeList& inSeq)
{
    ::Test::Callback_TestIntf_opBoolDequeListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeList(__cb, &::Test::AMI_TestIntf_opBoolDequeList::__response, &::Test::AMI_TestIntf_opBoolDequeList::__exception, &::Test::AMI_TestIntf_opBoolDequeList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeList(__cb, &::Test::AMI_TestIntf_opBoolDequeList::__response, &::Test::AMI_TestIntf_opBoolDequeList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolDequeList_name);
        __ar = begin_opBoolDequeList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolDequeList_async(const ::Test::AMI_TestIntf_opBoolDequeListPtr& __cb, const ::Test::BoolDequeList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolDequeListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeList(__cb, &::Test::AMI_TestIntf_opBoolDequeList::__response, &::Test::AMI_TestIntf_opBoolDequeList::__exception, &::Test::AMI_TestIntf_opBoolDequeList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeList(__cb, &::Test::AMI_TestIntf_opBoolDequeList::__response, &::Test::AMI_TestIntf_opBoolDequeList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolDequeList_name);
        __ar = begin_opBoolDequeList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolDequeListArray_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolDequeListArray_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolDequeListArray(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolDequeListArray_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeListArray_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolDequeListArray_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::end_opBoolDequeListArray(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolDequeListArray_name);
    ::Test::BoolDequeList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opBoolDequeListArray(::std::vector<std::deque<bool> >& outSeq, ::std::vector<std::deque<bool> >& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolDequeListArray_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(outSeq);
    __is->read(__ret);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opBoolDequeListArray_async(const ::Test::AMI_TestIntf_opBoolDequeListArrayPtr& __cb, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolDequeListArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListArray(__cb, &::Test::AMI_TestIntf_opBoolDequeListArray::__response, &::Test::AMI_TestIntf_opBoolDequeListArray::__exception, &::Test::AMI_TestIntf_opBoolDequeListArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListArray(__cb, &::Test::AMI_TestIntf_opBoolDequeListArray::__response, &::Test::AMI_TestIntf_opBoolDequeListArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolDequeListArray_name);
        __ar = begin_opBoolDequeListArray(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeListArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolDequeListArray_async(const ::Test::AMI_TestIntf_opBoolDequeListArrayPtr& __cb, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolDequeListArrayPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListArray(__cb, &::Test::AMI_TestIntf_opBoolDequeListArray::__response, &::Test::AMI_TestIntf_opBoolDequeListArray::__exception, &::Test::AMI_TestIntf_opBoolDequeListArray::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListArray(__cb, &::Test::AMI_TestIntf_opBoolDequeListArray::__response, &::Test::AMI_TestIntf_opBoolDequeListArray::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolDequeListArray_name);
        __ar = begin_opBoolDequeListArray(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeListArray_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolDequeListRange_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolDequeListRange_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolDequeListRange(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolDequeListRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeListRange_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolDequeListRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::end_opBoolDequeListRange(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolDequeListRange_name);
    ::Test::BoolDequeList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolDequeListRange_async(const ::Test::AMI_TestIntf_opBoolDequeListRangePtr& __cb, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq)
{
    ::Test::Callback_TestIntf_opBoolDequeListRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListRange(__cb, &::Test::AMI_TestIntf_opBoolDequeListRange::__response, &::Test::AMI_TestIntf_opBoolDequeListRange::__exception, &::Test::AMI_TestIntf_opBoolDequeListRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListRange(__cb, &::Test::AMI_TestIntf_opBoolDequeListRange::__response, &::Test::AMI_TestIntf_opBoolDequeListRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolDequeListRange_name);
        __ar = begin_opBoolDequeListRange(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeListRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolDequeListRange_async(const ::Test::AMI_TestIntf_opBoolDequeListRangePtr& __cb, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolDequeListRangePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListRange(__cb, &::Test::AMI_TestIntf_opBoolDequeListRange::__response, &::Test::AMI_TestIntf_opBoolDequeListRange::__exception, &::Test::AMI_TestIntf_opBoolDequeListRange::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolDequeListRange(__cb, &::Test::AMI_TestIntf_opBoolDequeListRange::__response, &::Test::AMI_TestIntf_opBoolDequeListRange::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolDequeListRange_name);
        __ar = begin_opBoolDequeListRange(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolDequeListRange_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Ice::Byte>
IceProxy::Test::TestIntf::opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Ice::Byte>
IceProxy::Test::TestIntf::end_opByteSeq(std::deque< ::Ice::Byte>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteSeq_name);
    std::deque< ::Ice::Byte> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteSeq_async(const ::Test::AMI_TestIntf_opByteSeqPtr& __cb, const std::deque< ::Ice::Byte>& inSeq)
{
    ::Test::Callback_TestIntf_opByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception, &::Test::AMI_TestIntf_opByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteSeq_name);
        __ar = begin_opByteSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteSeq_async(const ::Test::AMI_TestIntf_opByteSeqPtr& __cb, const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception, &::Test::AMI_TestIntf_opByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteSeq(__cb, &::Test::AMI_TestIntf_opByteSeq::__response, &::Test::AMI_TestIntf_opByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteSeq_name);
        __ar = begin_opByteSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ByteList
IceProxy::Test::TestIntf::opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opByteList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opByteList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opByteList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opByteList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opByteList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteList(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opByteList_name);
    ::Test::ByteList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opByteList_async(const ::Test::AMI_TestIntf_opByteListPtr& __cb, const ::Test::ByteList& inSeq)
{
    ::Test::Callback_TestIntf_opByteListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception, &::Test::AMI_TestIntf_opByteList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteList_name);
        __ar = begin_opByteList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opByteList_async(const ::Test::AMI_TestIntf_opByteListPtr& __cb, const ::Test::ByteList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opByteListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception, &::Test::AMI_TestIntf_opByteList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opByteList(__cb, &::Test::AMI_TestIntf_opByteList::__response, &::Test::AMI_TestIntf_opByteList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opByteList_name);
        __ar = begin_opByteList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opByteList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

MyByteSeq
IceProxy::Test::TestIntf::opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opMyByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opMyByteSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opMyByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opMyByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

MyByteSeq
IceProxy::Test::TestIntf::end_opMyByteSeq(MyByteSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opMyByteSeq_name);
    MyByteSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opMyByteSeq_async(const ::Test::AMI_TestIntf_opMyByteSeqPtr& __cb, const MyByteSeq& inSeq)
{
    ::Test::Callback_TestIntf_opMyByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception, &::Test::AMI_TestIntf_opMyByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
        __ar = begin_opMyByteSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opMyByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opMyByteSeq_async(const ::Test::AMI_TestIntf_opMyByteSeqPtr& __cb, const MyByteSeq& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opMyByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception, &::Test::AMI_TestIntf_opMyByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opMyByteSeq(__cb, &::Test::AMI_TestIntf_opMyByteSeq::__response, &::Test::AMI_TestIntf_opMyByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opMyByteSeq_name);
        __ar = begin_opMyByteSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opMyByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque<std::string>
IceProxy::Test::TestIntf::opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque<std::string>
IceProxy::Test::TestIntf::end_opStringSeq(std::deque<std::string>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringSeq_name);
    std::deque<std::string> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringSeq_async(const ::Test::AMI_TestIntf_opStringSeqPtr& __cb, const std::deque<std::string>& inSeq)
{
    ::Test::Callback_TestIntf_opStringSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception, &::Test::AMI_TestIntf_opStringSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringSeq_name);
        __ar = begin_opStringSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringSeq_async(const ::Test::AMI_TestIntf_opStringSeqPtr& __cb, const std::deque<std::string>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception, &::Test::AMI_TestIntf_opStringSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringSeq(__cb, &::Test::AMI_TestIntf_opStringSeq::__response, &::Test::AMI_TestIntf_opStringSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringSeq_name);
        __ar = begin_opStringSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::StringList
IceProxy::Test::TestIntf::opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::StringList
IceProxy::Test::TestIntf::end_opStringList(::Test::StringList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringList_name);
    ::Test::StringList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringList_async(const ::Test::AMI_TestIntf_opStringListPtr& __cb, const ::Test::StringList& inSeq)
{
    ::Test::Callback_TestIntf_opStringListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception, &::Test::AMI_TestIntf_opStringList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringList_name);
        __ar = begin_opStringList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringList_async(const ::Test::AMI_TestIntf_opStringListPtr& __cb, const ::Test::StringList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception, &::Test::AMI_TestIntf_opStringList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringList(__cb, &::Test::AMI_TestIntf_opStringList::__response, &::Test::AMI_TestIntf_opStringList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringList_name);
        __ar = begin_opStringList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::Fixed>
IceProxy::Test::TestIntf::opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opFixedSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opFixedSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opFixedSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opFixedSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opFixedSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::Fixed>
IceProxy::Test::TestIntf::end_opFixedSeq(std::deque< ::Test::Fixed>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opFixedSeq_name);
    std::deque< ::Test::Fixed> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opFixedSeq_async(const ::Test::AMI_TestIntf_opFixedSeqPtr& __cb, const std::deque< ::Test::Fixed>& inSeq)
{
    ::Test::Callback_TestIntf_opFixedSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception, &::Test::AMI_TestIntf_opFixedSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedSeq_name);
        __ar = begin_opFixedSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opFixedSeq_async(const ::Test::AMI_TestIntf_opFixedSeqPtr& __cb, const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opFixedSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception, &::Test::AMI_TestIntf_opFixedSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedSeq(__cb, &::Test::AMI_TestIntf_opFixedSeq::__response, &::Test::AMI_TestIntf_opFixedSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedSeq_name);
        __ar = begin_opFixedSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::FixedList
IceProxy::Test::TestIntf::opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opFixedList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opFixedList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opFixedList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opFixedList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opFixedList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::FixedList
IceProxy::Test::TestIntf::end_opFixedList(::Test::FixedList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opFixedList_name);
    ::Test::FixedList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opFixedList_async(const ::Test::AMI_TestIntf_opFixedListPtr& __cb, const ::Test::FixedList& inSeq)
{
    ::Test::Callback_TestIntf_opFixedListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception, &::Test::AMI_TestIntf_opFixedList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedList_name);
        __ar = begin_opFixedList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opFixedList_async(const ::Test::AMI_TestIntf_opFixedListPtr& __cb, const ::Test::FixedList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opFixedListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception, &::Test::AMI_TestIntf_opFixedList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opFixedList(__cb, &::Test::AMI_TestIntf_opFixedList::__response, &::Test::AMI_TestIntf_opFixedList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opFixedList_name);
        __ar = begin_opFixedList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opFixedList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::Variable>
IceProxy::Test::TestIntf::opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::Variable>
IceProxy::Test::TestIntf::end_opVariableSeq(std::deque< ::Test::Variable>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableSeq_name);
    std::deque< ::Test::Variable> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableSeq_async(const ::Test::AMI_TestIntf_opVariableSeqPtr& __cb, const std::deque< ::Test::Variable>& inSeq)
{
    ::Test::Callback_TestIntf_opVariableSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception, &::Test::AMI_TestIntf_opVariableSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableSeq_name);
        __ar = begin_opVariableSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableSeq_async(const ::Test::AMI_TestIntf_opVariableSeqPtr& __cb, const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception, &::Test::AMI_TestIntf_opVariableSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableSeq(__cb, &::Test::AMI_TestIntf_opVariableSeq::__response, &::Test::AMI_TestIntf_opVariableSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableSeq_name);
        __ar = begin_opVariableSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::VariableList
IceProxy::Test::TestIntf::opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVariableList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVariableList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVariableList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVariableList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVariableList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableList(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVariableList_name);
    ::Test::VariableList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVariableList_async(const ::Test::AMI_TestIntf_opVariableListPtr& __cb, const ::Test::VariableList& inSeq)
{
    ::Test::Callback_TestIntf_opVariableListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception, &::Test::AMI_TestIntf_opVariableList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableList_name);
        __ar = begin_opVariableList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVariableList_async(const ::Test::AMI_TestIntf_opVariableListPtr& __cb, const ::Test::VariableList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVariableListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception, &::Test::AMI_TestIntf_opVariableList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVariableList(__cb, &::Test::AMI_TestIntf_opVariableList::__response, &::Test::AMI_TestIntf_opVariableList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVariableList_name);
        __ar = begin_opVariableList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVariableList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::StringStringDict>
IceProxy::Test::TestIntf::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringStringDictSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringStringDictSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringStringDictSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::StringStringDict>
IceProxy::Test::TestIntf::end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringStringDictSeq_name);
    std::deque< ::Test::StringStringDict> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringStringDictSeq_async(const ::Test::AMI_TestIntf_opStringStringDictSeqPtr& __cb, const std::deque< ::Test::StringStringDict>& inSeq)
{
    ::Test::Callback_TestIntf_opStringStringDictSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception, &::Test::AMI_TestIntf_opStringStringDictSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
        __ar = begin_opStringStringDictSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringStringDictSeq_async(const ::Test::AMI_TestIntf_opStringStringDictSeqPtr& __cb, const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringStringDictSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception, &::Test::AMI_TestIntf_opStringStringDictSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictSeq(__cb, &::Test::AMI_TestIntf_opStringStringDictSeq::__response, &::Test::AMI_TestIntf_opStringStringDictSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictSeq_name);
        __ar = begin_opStringStringDictSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::StringStringDictList
IceProxy::Test::TestIntf::opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opStringStringDictList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opStringStringDictList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opStringStringDictList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::StringStringDictList
IceProxy::Test::TestIntf::end_opStringStringDictList(::Test::StringStringDictList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opStringStringDictList_name);
    ::Test::StringStringDictList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opStringStringDictList_async(const ::Test::AMI_TestIntf_opStringStringDictListPtr& __cb, const ::Test::StringStringDictList& inSeq)
{
    ::Test::Callback_TestIntf_opStringStringDictListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception, &::Test::AMI_TestIntf_opStringStringDictList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
        __ar = begin_opStringStringDictList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opStringStringDictList_async(const ::Test::AMI_TestIntf_opStringStringDictListPtr& __cb, const ::Test::StringStringDictList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opStringStringDictListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception, &::Test::AMI_TestIntf_opStringStringDictList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opStringStringDictList(__cb, &::Test::AMI_TestIntf_opStringStringDictList::__response, &::Test::AMI_TestIntf_opStringStringDictList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opStringStringDictList_name);
        __ar = begin_opStringStringDictList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opStringStringDictList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::E>
IceProxy::Test::TestIntf::opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opESeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opESeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opESeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opESeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opESeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opESeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::E>
IceProxy::Test::TestIntf::end_opESeq(std::deque< ::Test::E>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opESeq_name);
    std::deque< ::Test::E> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opESeq_async(const ::Test::AMI_TestIntf_opESeqPtr& __cb, const std::deque< ::Test::E>& inSeq)
{
    ::Test::Callback_TestIntf_opESeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception, &::Test::AMI_TestIntf_opESeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opESeq_name);
        __ar = begin_opESeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opESeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opESeq_async(const ::Test::AMI_TestIntf_opESeqPtr& __cb, const std::deque< ::Test::E>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opESeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception, &::Test::AMI_TestIntf_opESeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opESeq(__cb, &::Test::AMI_TestIntf_opESeq::__response, &::Test::AMI_TestIntf_opESeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opESeq_name);
        __ar = begin_opESeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opESeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::EList
IceProxy::Test::TestIntf::opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opEList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opEList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opEList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opEList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opEList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opEList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::EList
IceProxy::Test::TestIntf::end_opEList(::Test::EList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opEList_name);
    ::Test::EList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opEList_async(const ::Test::AMI_TestIntf_opEListPtr& __cb, const ::Test::EList& inSeq)
{
    ::Test::Callback_TestIntf_opEListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception, &::Test::AMI_TestIntf_opEList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opEList_name);
        __ar = begin_opEList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opEList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opEList_async(const ::Test::AMI_TestIntf_opEListPtr& __cb, const ::Test::EList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opEListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception, &::Test::AMI_TestIntf_opEList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opEList(__cb, &::Test::AMI_TestIntf_opEList::__response, &::Test::AMI_TestIntf_opEList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opEList_name);
        __ar = begin_opEList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opEList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::CPrx>
IceProxy::Test::TestIntf::opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, std::deque< ::Test::CPrx>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCPrxSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCPrxSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCPrxSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::CPrx>
IceProxy::Test::TestIntf::end_opCPrxSeq(std::deque< ::Test::CPrx>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCPrxSeq_name);
    std::deque< ::Test::CPrx> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCPrxSeq_async(const ::Test::AMI_TestIntf_opCPrxSeqPtr& __cb, const std::deque< ::Test::CPrx>& inSeq)
{
    ::Test::Callback_TestIntf_opCPrxSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception, &::Test::AMI_TestIntf_opCPrxSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
        __ar = begin_opCPrxSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCPrxSeq_async(const ::Test::AMI_TestIntf_opCPrxSeqPtr& __cb, const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCPrxSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception, &::Test::AMI_TestIntf_opCPrxSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxSeq(__cb, &::Test::AMI_TestIntf_opCPrxSeq::__response, &::Test::AMI_TestIntf_opCPrxSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxSeq_name);
        __ar = begin_opCPrxSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CPrxList
IceProxy::Test::TestIntf::opCPrxList(const ::Test::CPrxList& inSeq, ::Test::CPrxList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCPrxList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCPrxList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCPrxList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCPrxList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCPrxList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CPrxList
IceProxy::Test::TestIntf::end_opCPrxList(::Test::CPrxList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCPrxList_name);
    ::Test::CPrxList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCPrxList_async(const ::Test::AMI_TestIntf_opCPrxListPtr& __cb, const ::Test::CPrxList& inSeq)
{
    ::Test::Callback_TestIntf_opCPrxListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception, &::Test::AMI_TestIntf_opCPrxList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxList_name);
        __ar = begin_opCPrxList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCPrxList_async(const ::Test::AMI_TestIntf_opCPrxListPtr& __cb, const ::Test::CPrxList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCPrxListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception, &::Test::AMI_TestIntf_opCPrxList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCPrxList(__cb, &::Test::AMI_TestIntf_opCPrxList::__response, &::Test::AMI_TestIntf_opCPrxList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCPrxList_name);
        __ar = begin_opCPrxList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCPrxList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

std::deque< ::Test::CPtr>
IceProxy::Test::TestIntf::opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCSeq(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

std::deque< ::Test::CPtr>
IceProxy::Test::TestIntf::end_opCSeq(std::deque< ::Test::CPtr>& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCSeq_name);
    std::deque< ::Test::CPtr> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCSeq_async(const ::Test::AMI_TestIntf_opCSeqPtr& __cb, const std::deque< ::Test::CPtr>& inSeq)
{
    ::Test::Callback_TestIntf_opCSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception, &::Test::AMI_TestIntf_opCSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCSeq_name);
        __ar = begin_opCSeq(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCSeq_async(const ::Test::AMI_TestIntf_opCSeqPtr& __cb, const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception, &::Test::AMI_TestIntf_opCSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCSeq(__cb, &::Test::AMI_TestIntf_opCSeq::__response, &::Test::AMI_TestIntf_opCSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCSeq_name);
        __ar = begin_opCSeq(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CList
IceProxy::Test::TestIntf::opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opCList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opCList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opCList(inSeq, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opCList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opCList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CList
IceProxy::Test::TestIntf::end_opCList(::Test::CList& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opCList_name);
    ::Test::CList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opCList_async(const ::Test::AMI_TestIntf_opCListPtr& __cb, const ::Test::CList& inSeq)
{
    ::Test::Callback_TestIntf_opCListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception, &::Test::AMI_TestIntf_opCList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCList_name);
        __ar = begin_opCList(inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opCList_async(const ::Test::AMI_TestIntf_opCListPtr& __cb, const ::Test::CList& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opCListPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception, &::Test::AMI_TestIntf_opCList::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opCList(__cb, &::Test::AMI_TestIntf_opCList::__response, &::Test::AMI_TestIntf_opCList::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opCList_name);
        __ar = begin_opCList(inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opCList_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ClassStructPtr
IceProxy::Test::TestIntf::opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opClassStruct_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opClassStruct_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opClassStruct(inS, inSeq, outS, outSeq, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opClassStruct_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opClassStruct_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opClassStruct_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __os->write(inSeq);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ClassStructPtr
IceProxy::Test::TestIntf::end_opClassStruct(::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opClassStruct_name);
    ::Test::ClassStructPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outS);
        __is->read(outSeq);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opClassStruct_async(const ::Test::AMI_TestIntf_opClassStructPtr& __cb, const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq)
{
    ::Test::Callback_TestIntf_opClassStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception, &::Test::AMI_TestIntf_opClassStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opClassStruct_name);
        __ar = begin_opClassStruct(inS, inSeq, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opClassStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opClassStruct_async(const ::Test::AMI_TestIntf_opClassStructPtr& __cb, const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opClassStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception, &::Test::AMI_TestIntf_opClassStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opClassStruct(__cb, &::Test::AMI_TestIntf_opClassStruct::__response, &::Test::AMI_TestIntf_opClassStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opClassStruct_name);
        __ar = begin_opClassStruct(inS, inSeq, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opClassStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::TestIntf::opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opOutArrayByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->opOutArrayByteSeq(org, copy, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutArrayByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opOutArrayByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_opOutArrayByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opOutArrayByteSeq_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(copy);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::Test::TestIntf::___end_opOutArrayByteSeq(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& copy, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opOutArrayByteSeq_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(copy);
    __result->__endReadParams();
}

bool
IceProxy::Test::TestIntf::opOutArrayByteSeq_async(const ::Test::AMI_TestIntf_opOutArrayByteSeqPtr& __cb, const ::Test::ByteSeq& org)
{
    ::Test::Callback_TestIntf_opOutArrayByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception, &::Test::AMI_TestIntf_opOutArrayByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
        __ar = begin_opOutArrayByteSeq(org, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutArrayByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opOutArrayByteSeq_async(const ::Test::AMI_TestIntf_opOutArrayByteSeqPtr& __cb, const ::Test::ByteSeq& org, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opOutArrayByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception, &::Test::AMI_TestIntf_opOutArrayByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutArrayByteSeq(__cb, &::Test::AMI_TestIntf_opOutArrayByteSeq::__response, &::Test::AMI_TestIntf_opOutArrayByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutArrayByteSeq_name);
        __ar = begin_opOutArrayByteSeq(org, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutArrayByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::TestIntf::opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opOutRangeByteSeq_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->opOutRangeByteSeq(org, copy, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutRangeByteSeq_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opOutRangeByteSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_opOutRangeByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opOutRangeByteSeq_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(copy);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opOutRangeByteSeq_async(const ::Test::AMI_TestIntf_opOutRangeByteSeqPtr& __cb, const ::Test::ByteSeq& org)
{
    ::Test::Callback_TestIntf_opOutRangeByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception, &::Test::AMI_TestIntf_opOutRangeByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
        __ar = begin_opOutRangeByteSeq(org, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutRangeByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opOutRangeByteSeq_async(const ::Test::AMI_TestIntf_opOutRangeByteSeqPtr& __cb, const ::Test::ByteSeq& org, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opOutRangeByteSeqPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception, &::Test::AMI_TestIntf_opOutRangeByteSeq::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opOutRangeByteSeq(__cb, &::Test::AMI_TestIntf_opOutRangeByteSeq::__response, &::Test::AMI_TestIntf_opOutRangeByteSeq::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opOutRangeByteSeq_name);
        __ar = begin_opOutRangeByteSeq(org, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opOutRangeByteSeq_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::IntStringDict
IceProxy::Test::TestIntf::opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opIntStringDict_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opIntStringDict_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opIntStringDict(idict, odict, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opIntStringDict_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opIntStringDict_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opIntStringDict_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::IntStringDict
IceProxy::Test::TestIntf::end_opIntStringDict(::Test::IntStringDict& odict, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opIntStringDict_name);
    ::Test::IntStringDict __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opIntStringDict_async(const ::Test::AMI_TestIntf_opIntStringDictPtr& __cb, const ::Test::IntStringDict& idict)
{
    ::Test::Callback_TestIntf_opIntStringDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception, &::Test::AMI_TestIntf_opIntStringDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opIntStringDict_name);
        __ar = begin_opIntStringDict(idict, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opIntStringDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opIntStringDict_async(const ::Test::AMI_TestIntf_opIntStringDictPtr& __cb, const ::Test::IntStringDict& idict, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opIntStringDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception, &::Test::AMI_TestIntf_opIntStringDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opIntStringDict(__cb, &::Test::AMI_TestIntf_opIntStringDict::__response, &::Test::AMI_TestIntf_opIntStringDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opIntStringDict_name);
        __ar = begin_opIntStringDict(idict, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opIntStringDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceProxy::Test::TestIntf::opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opVarDict_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opVarDict_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opVarDict(idict, odict, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opVarDict_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVarDict_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opVarDict_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceProxy::Test::TestIntf::end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opVarDict_name);
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opVarDict_async(const ::Test::AMI_TestIntf_opVarDictPtr& __cb, const ::Test::CustomMap<std::string, ::Ice::Int>& idict)
{
    ::Test::Callback_TestIntf_opVarDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception, &::Test::AMI_TestIntf_opVarDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVarDict_name);
        __ar = begin_opVarDict(idict, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVarDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opVarDict_async(const ::Test::AMI_TestIntf_opVarDictPtr& __cb, const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opVarDictPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception, &::Test::AMI_TestIntf_opVarDict::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opVarDict(__cb, &::Test::AMI_TestIntf_opVarDict::__response, &::Test::AMI_TestIntf_opVarDict::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opVarDict_name);
        __ar = begin_opVarDict(idict, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opVarDict_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::ShortBuffer
IceProxy::Test::TestIntf::opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opShortBuffer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opShortBuffer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opShortBuffer(inS, outS, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opShortBuffer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opShortBuffer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opShortBuffer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::ShortBuffer
IceProxy::Test::TestIntf::end_opShortBuffer(::Test::ShortBuffer& outS, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opShortBuffer_name);
    ::Test::ShortBuffer __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opShortBuffer_async(const ::Test::AMI_TestIntf_opShortBufferPtr& __cb, const ::Test::ShortBuffer& inS)
{
    ::Test::Callback_TestIntf_opShortBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception, &::Test::AMI_TestIntf_opShortBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opShortBuffer_name);
        __ar = begin_opShortBuffer(inS, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opShortBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opShortBuffer_async(const ::Test::AMI_TestIntf_opShortBufferPtr& __cb, const ::Test::ShortBuffer& inS, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opShortBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception, &::Test::AMI_TestIntf_opShortBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opShortBuffer(__cb, &::Test::AMI_TestIntf_opShortBuffer::__response, &::Test::AMI_TestIntf_opShortBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opShortBuffer_name);
        __ar = begin_opShortBuffer(inS, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opShortBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::CustomBuffer<bool>
IceProxy::Test::TestIntf::opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBoolBuffer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBoolBuffer(inS, outS, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolBuffer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBoolBuffer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::CustomBuffer<bool>
IceProxy::Test::TestIntf::end_opBoolBuffer(::Test::CustomBuffer<bool>& outS, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBoolBuffer_name);
    ::Test::CustomBuffer<bool> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBoolBuffer_async(const ::Test::AMI_TestIntf_opBoolBufferPtr& __cb, const ::Test::CustomBuffer<bool>& inS)
{
    ::Test::Callback_TestIntf_opBoolBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception, &::Test::AMI_TestIntf_opBoolBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
        __ar = begin_opBoolBuffer(inS, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBoolBuffer_async(const ::Test::AMI_TestIntf_opBoolBufferPtr& __cb, const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBoolBufferPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception, &::Test::AMI_TestIntf_opBoolBuffer::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBoolBuffer(__cb, &::Test::AMI_TestIntf_opBoolBuffer::__response, &::Test::AMI_TestIntf_opBoolBuffer::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBoolBuffer_name);
        __ar = begin_opBoolBuffer(inS, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBoolBuffer_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

::Test::BufferStruct
IceProxy::Test::TestIntf::opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__opBufferStruct_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__opBufferStruct_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->opBufferStruct(s, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__opBufferStruct_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBufferStruct_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__opBufferStruct_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BufferStruct
IceProxy::Test::TestIntf::end_opBufferStruct(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__opBufferStruct_name);
    ::Test::BufferStruct __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Test::TestIntf::opBufferStruct_async(const ::Test::AMI_TestIntf_opBufferStructPtr& __cb, const ::Test::BufferStruct& s)
{
    ::Test::Callback_TestIntf_opBufferStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception, &::Test::AMI_TestIntf_opBufferStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBufferStruct_name);
        __ar = begin_opBufferStruct(s, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBufferStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::opBufferStruct_async(const ::Test::AMI_TestIntf_opBufferStructPtr& __cb, const ::Test::BufferStruct& s, const ::Ice::Context& __ctx)
{
    ::Test::Callback_TestIntf_opBufferStructPtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception, &::Test::AMI_TestIntf_opBufferStruct::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_opBufferStruct(__cb, &::Test::AMI_TestIntf_opBufferStruct::__response, &::Test::AMI_TestIntf_opBufferStruct::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__Test__TestIntf__opBufferStruct_name);
        __ar = begin_opBufferStruct(s, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__opBufferStruct_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::Test::TestIntf::shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__shutdown_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__shutdown_name);
}

bool
IceProxy::Test::TestIntf::shutdown_async(const ::Test::AMI_TestIntf_shutdownPtr& __cb)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception, &::Test::AMI_TestIntf_shutdown::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_shutdown(0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::Test::TestIntf::shutdown_async(const ::Test::AMI_TestIntf_shutdownPtr& __cb, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception, &::Test::AMI_TestIntf_shutdown::__sent);
    }
    else
    {
         __del = ::Test::newCallback_TestIntf_shutdown(__cb, &::Test::AMI_TestIntf_shutdown::__response, &::Test::AMI_TestIntf_shutdown::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_shutdown(&__ctx, __del);
    return __ar->sentSynchronously();
}

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::TestIntf);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::TestIntf);
}

::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::__newInstance() const
{
    return new TestIntf;
}

::Test::DoubleSeq
IceDelegateM::Test::TestIntf::opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opDoubleArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::DoubleSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolSeq
IceDelegateM::Test::TestIntf::opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolSeq
IceDelegateM::Test::TestIntf::opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolRange_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteRange_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableRange_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolSeq
IceDelegateM::Test::TestIntf::opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolRangeType_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteRangeType_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableRangeType_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque<bool>
IceDelegateM::Test::TestIntf::opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque<bool> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolList
IceDelegateM::Test::TestIntf::opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolDequeList
IceDelegateM::Test::TestIntf::opBoolDequeList(const ::Test::BoolDequeList& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolDequeList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolDequeList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolDequeList
IceDelegateM::Test::TestIntf::opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolDequeListArray_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolDequeList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BoolDequeList
IceDelegateM::Test::TestIntf::opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolDequeListRange_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BoolDequeList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Ice::Byte>
IceDelegateM::Test::TestIntf::opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Ice::Byte> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ByteList
IceDelegateM::Test::TestIntf::opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opByteList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ByteList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

MyByteSeq
IceDelegateM::Test::TestIntf::opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opMyByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    MyByteSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque<std::string>
IceDelegateM::Test::TestIntf::opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque<std::string> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::StringList
IceDelegateM::Test::TestIntf::opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::StringList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::Fixed>
IceDelegateM::Test::TestIntf::opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opFixedSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::Fixed> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::FixedList
IceDelegateM::Test::TestIntf::opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opFixedList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::FixedList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::Variable>
IceDelegateM::Test::TestIntf::opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::Variable> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::VariableList
IceDelegateM::Test::TestIntf::opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVariableList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::VariableList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::StringStringDict>
IceDelegateM::Test::TestIntf::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringStringDictSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::StringStringDict> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::StringStringDictList
IceDelegateM::Test::TestIntf::opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opStringStringDictList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::StringStringDictList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::E>
IceDelegateM::Test::TestIntf::opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opESeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::E> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::EList
IceDelegateM::Test::TestIntf::opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opEList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::EList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::CPrx>
IceDelegateM::Test::TestIntf::opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, std::deque< ::Test::CPrx>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCPrxSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::CPrx> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CPrxList
IceDelegateM::Test::TestIntf::opCPrxList(const ::Test::CPrxList& inSeq, ::Test::CPrxList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCPrxList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CPrxList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

std::deque< ::Test::CPtr>
IceDelegateM::Test::TestIntf::opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    std::deque< ::Test::CPtr> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CList
IceDelegateM::Test::TestIntf::opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opCList_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inSeq);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outSeq);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ClassStructPtr
IceDelegateM::Test::TestIntf::opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opClassStruct_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __os->write(inSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ClassStructPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outS);
        __is->read(outSeq);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opOutArrayByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(copy);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opOutRangeByteSeq_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(org);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(copy);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::IntStringDict
IceDelegateM::Test::TestIntf::opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opIntStringDict_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::IntStringDict __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceDelegateM::Test::TestIntf::opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opVarDict_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(idict);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(odict);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::ShortBuffer
IceDelegateM::Test::TestIntf::opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opShortBuffer_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::ShortBuffer __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::CustomBuffer<bool>
IceDelegateM::Test::TestIntf::opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBoolBuffer_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inS);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::CustomBuffer<bool> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outS);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BufferStruct
IceDelegateM::Test::TestIntf::opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__opBufferStruct_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BufferStruct __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__shutdown_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Test::DoubleSeq
IceDelegateD::Test::TestIntf::opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::DoubleSeq& __result, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& __p_inSeq, ::Test::DoubleSeq& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opDoubleArray(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::DoubleSeq& _result;
        const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& _m_inSeq;
        ::Test::DoubleSeq& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opDoubleArray_name, ::Ice::Normal, __context);
    ::Test::DoubleSeq __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BoolSeq
IceDelegateD::Test::TestIntf::opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BoolSeq& __result, const ::std::pair<const bool*, const bool*>& __p_inSeq, ::Test::BoolSeq& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolArray(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BoolSeq& _result;
        const ::std::pair<const bool*, const bool*>& _m_inSeq;
        ::Test::BoolSeq& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolArray_name, ::Ice::Normal, __context);
    ::Test::BoolSeq __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::ByteList& __result, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_inSeq, ::Test::ByteList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opByteArray(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::ByteList& _result;
        const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& _m_inSeq;
        ::Test::ByteList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opByteArray_name, ::Ice::Normal, __context);
    ::Test::ByteList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::VariableList& __result, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& __p_inSeq, ::Test::VariableList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opVariableArray(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::VariableList& _result;
        const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& _m_inSeq;
        ::Test::VariableList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opVariableArray_name, ::Ice::Normal, __context);
    ::Test::VariableList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BoolSeq
IceDelegateD::Test::TestIntf::opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BoolSeq& __result, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& __p_inSeq, ::Test::BoolSeq& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolRange(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BoolSeq& _result;
        const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& _m_inSeq;
        ::Test::BoolSeq& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolRange_name, ::Ice::Normal, __context);
    ::Test::BoolSeq __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::ByteList& __result, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& __p_inSeq, ::Test::ByteList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opByteRange(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::ByteList& _result;
        const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& _m_inSeq;
        ::Test::ByteList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opByteRange_name, ::Ice::Normal, __context);
    ::Test::ByteList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::VariableList& __result, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& __p_inSeq, ::Test::VariableList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opVariableRange(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::VariableList& _result;
        const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& _m_inSeq;
        ::Test::VariableList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opVariableRange_name, ::Ice::Normal, __context);
    ::Test::VariableList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BoolSeq
IceDelegateD::Test::TestIntf::opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BoolSeq& __result, const ::std::pair<const bool*, const bool*>& __p_inSeq, ::Test::BoolSeq& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolRangeType(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BoolSeq& _result;
        const ::std::pair<const bool*, const bool*>& _m_inSeq;
        ::Test::BoolSeq& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolRangeType_name, ::Ice::Normal, __context);
    ::Test::BoolSeq __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::ByteList& __result, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& __p_inSeq, ::Test::ByteList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opByteRangeType(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::ByteList& _result;
        const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& _m_inSeq;
        ::Test::ByteList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opByteRangeType_name, ::Ice::Normal, __context);
    ::Test::ByteList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::VariableList& __result, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& __p_inSeq, ::Test::VariableList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opVariableRangeType(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::VariableList& _result;
        const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& _m_inSeq;
        ::Test::VariableList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opVariableRangeType_name, ::Ice::Normal, __context);
    ::Test::VariableList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque<bool>
IceDelegateD::Test::TestIntf::opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque<bool>& __result, const std::deque<bool>& __p_inSeq, std::deque<bool>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque<bool>& _result;
        const std::deque<bool>& _m_inSeq;
        std::deque<bool>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolSeq_name, ::Ice::Normal, __context);
    std::deque<bool> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BoolList
IceDelegateD::Test::TestIntf::opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BoolList& __result, const ::Test::BoolList& __p_inSeq, ::Test::BoolList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BoolList& _result;
        const ::Test::BoolList& _m_inSeq;
        ::Test::BoolList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolList_name, ::Ice::Normal, __context);
    ::Test::BoolList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BoolDequeList
IceDelegateD::Test::TestIntf::opBoolDequeList(const ::Test::BoolDequeList& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BoolDequeList& __result, const ::Test::BoolDequeList& __p_inSeq, ::Test::BoolDequeList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolDequeList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BoolDequeList& _result;
        const ::Test::BoolDequeList& _m_inSeq;
        ::Test::BoolDequeList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolDequeList_name, ::Ice::Normal, __context);
    ::Test::BoolDequeList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BoolDequeList
IceDelegateD::Test::TestIntf::opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BoolDequeList& __result, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& __p_inSeq, ::Test::BoolDequeList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolDequeListArray(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BoolDequeList& _result;
        const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& _m_inSeq;
        ::Test::BoolDequeList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolDequeListArray_name, ::Ice::Normal, __context);
    ::Test::BoolDequeList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BoolDequeList
IceDelegateD::Test::TestIntf::opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BoolDequeList& __result, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& __p_inSeq, ::Test::BoolDequeList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolDequeListRange(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BoolDequeList& _result;
        const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& _m_inSeq;
        ::Test::BoolDequeList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolDequeListRange_name, ::Ice::Normal, __context);
    ::Test::BoolDequeList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque< ::Ice::Byte>
IceDelegateD::Test::TestIntf::opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque< ::Ice::Byte>& __result, const std::deque< ::Ice::Byte>& __p_inSeq, std::deque< ::Ice::Byte>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opByteSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque< ::Ice::Byte>& _result;
        const std::deque< ::Ice::Byte>& _m_inSeq;
        std::deque< ::Ice::Byte>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opByteSeq_name, ::Ice::Normal, __context);
    std::deque< ::Ice::Byte> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::ByteList
IceDelegateD::Test::TestIntf::opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::ByteList& __result, const ::Test::ByteList& __p_inSeq, ::Test::ByteList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opByteList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::ByteList& _result;
        const ::Test::ByteList& _m_inSeq;
        ::Test::ByteList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opByteList_name, ::Ice::Normal, __context);
    ::Test::ByteList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

MyByteSeq
IceDelegateD::Test::TestIntf::opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(MyByteSeq& __result, const MyByteSeq& __p_inSeq, MyByteSeq& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opMyByteSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        MyByteSeq& _result;
        const MyByteSeq& _m_inSeq;
        MyByteSeq& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opMyByteSeq_name, ::Ice::Normal, __context);
    MyByteSeq __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque<std::string>
IceDelegateD::Test::TestIntf::opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque<std::string>& __result, const std::deque<std::string>& __p_inSeq, std::deque<std::string>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opStringSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque<std::string>& _result;
        const std::deque<std::string>& _m_inSeq;
        std::deque<std::string>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opStringSeq_name, ::Ice::Normal, __context);
    std::deque<std::string> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::StringList
IceDelegateD::Test::TestIntf::opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::StringList& __result, const ::Test::StringList& __p_inSeq, ::Test::StringList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opStringList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::StringList& _result;
        const ::Test::StringList& _m_inSeq;
        ::Test::StringList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opStringList_name, ::Ice::Normal, __context);
    ::Test::StringList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque< ::Test::Fixed>
IceDelegateD::Test::TestIntf::opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque< ::Test::Fixed>& __result, const std::deque< ::Test::Fixed>& __p_inSeq, std::deque< ::Test::Fixed>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opFixedSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque< ::Test::Fixed>& _result;
        const std::deque< ::Test::Fixed>& _m_inSeq;
        std::deque< ::Test::Fixed>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opFixedSeq_name, ::Ice::Normal, __context);
    std::deque< ::Test::Fixed> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::FixedList
IceDelegateD::Test::TestIntf::opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::FixedList& __result, const ::Test::FixedList& __p_inSeq, ::Test::FixedList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opFixedList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::FixedList& _result;
        const ::Test::FixedList& _m_inSeq;
        ::Test::FixedList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opFixedList_name, ::Ice::Normal, __context);
    ::Test::FixedList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque< ::Test::Variable>
IceDelegateD::Test::TestIntf::opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque< ::Test::Variable>& __result, const std::deque< ::Test::Variable>& __p_inSeq, std::deque< ::Test::Variable>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opVariableSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque< ::Test::Variable>& _result;
        const std::deque< ::Test::Variable>& _m_inSeq;
        std::deque< ::Test::Variable>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opVariableSeq_name, ::Ice::Normal, __context);
    std::deque< ::Test::Variable> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::VariableList
IceDelegateD::Test::TestIntf::opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::VariableList& __result, const ::Test::VariableList& __p_inSeq, ::Test::VariableList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opVariableList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::VariableList& _result;
        const ::Test::VariableList& _m_inSeq;
        ::Test::VariableList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opVariableList_name, ::Ice::Normal, __context);
    ::Test::VariableList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque< ::Test::StringStringDict>
IceDelegateD::Test::TestIntf::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque< ::Test::StringStringDict>& __result, const std::deque< ::Test::StringStringDict>& __p_inSeq, std::deque< ::Test::StringStringDict>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opStringStringDictSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque< ::Test::StringStringDict>& _result;
        const std::deque< ::Test::StringStringDict>& _m_inSeq;
        std::deque< ::Test::StringStringDict>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opStringStringDictSeq_name, ::Ice::Normal, __context);
    std::deque< ::Test::StringStringDict> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::StringStringDictList
IceDelegateD::Test::TestIntf::opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::StringStringDictList& __result, const ::Test::StringStringDictList& __p_inSeq, ::Test::StringStringDictList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opStringStringDictList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::StringStringDictList& _result;
        const ::Test::StringStringDictList& _m_inSeq;
        ::Test::StringStringDictList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opStringStringDictList_name, ::Ice::Normal, __context);
    ::Test::StringStringDictList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque< ::Test::E>
IceDelegateD::Test::TestIntf::opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque< ::Test::E>& __result, const std::deque< ::Test::E>& __p_inSeq, std::deque< ::Test::E>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opESeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque< ::Test::E>& _result;
        const std::deque< ::Test::E>& _m_inSeq;
        std::deque< ::Test::E>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opESeq_name, ::Ice::Normal, __context);
    std::deque< ::Test::E> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::EList
IceDelegateD::Test::TestIntf::opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::EList& __result, const ::Test::EList& __p_inSeq, ::Test::EList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opEList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::EList& _result;
        const ::Test::EList& _m_inSeq;
        ::Test::EList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opEList_name, ::Ice::Normal, __context);
    ::Test::EList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque< ::Test::CPrx>
IceDelegateD::Test::TestIntf::opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, std::deque< ::Test::CPrx>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque< ::Test::CPrx>& __result, const std::deque< ::Test::CPrx>& __p_inSeq, std::deque< ::Test::CPrx>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opCPrxSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque< ::Test::CPrx>& _result;
        const std::deque< ::Test::CPrx>& _m_inSeq;
        std::deque< ::Test::CPrx>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opCPrxSeq_name, ::Ice::Normal, __context);
    std::deque< ::Test::CPrx> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::CPrxList
IceDelegateD::Test::TestIntf::opCPrxList(const ::Test::CPrxList& inSeq, ::Test::CPrxList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::CPrxList& __result, const ::Test::CPrxList& __p_inSeq, ::Test::CPrxList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opCPrxList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::CPrxList& _result;
        const ::Test::CPrxList& _m_inSeq;
        ::Test::CPrxList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opCPrxList_name, ::Ice::Normal, __context);
    ::Test::CPrxList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

std::deque< ::Test::CPtr>
IceDelegateD::Test::TestIntf::opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(std::deque< ::Test::CPtr>& __result, const std::deque< ::Test::CPtr>& __p_inSeq, std::deque< ::Test::CPtr>& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opCSeq(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        std::deque< ::Test::CPtr>& _result;
        const std::deque< ::Test::CPtr>& _m_inSeq;
        std::deque< ::Test::CPtr>& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opCSeq_name, ::Ice::Normal, __context);
    std::deque< ::Test::CPtr> __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::CList
IceDelegateD::Test::TestIntf::opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::CList& __result, const ::Test::CList& __p_inSeq, ::Test::CList& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inSeq(__p_inSeq),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opCList(_m_inSeq, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::CList& _result;
        const ::Test::CList& _m_inSeq;
        ::Test::CList& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opCList_name, ::Ice::Normal, __context);
    ::Test::CList __result;
    try
    {
        _DirectI __direct(__result, inSeq, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::ClassStructPtr
IceDelegateD::Test::TestIntf::opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::ClassStructPtr& __result, const ::Test::ClassStructPtr& __p_inS, const ::Test::ClassStructSeq& __p_inSeq, ::Test::ClassStructPtr& __p_outS, ::Test::ClassStructSeq& __p_outSeq, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inS(__p_inS),
            _m_inSeq(__p_inSeq),
            _m_outS(__p_outS),
            _m_outSeq(__p_outSeq)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opClassStruct(_m_inS, _m_inSeq, _m_outS, _m_outSeq, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::ClassStructPtr& _result;
        const ::Test::ClassStructPtr& _m_inS;
        const ::Test::ClassStructSeq& _m_inSeq;
        ::Test::ClassStructPtr& _m_outS;
        ::Test::ClassStructSeq& _m_outSeq;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opClassStruct_name, ::Ice::Normal, __context);
    ::Test::ClassStructPtr __result;
    try
    {
        _DirectI __direct(__result, inS, inSeq, outS, outSeq, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Test::TestIntf::opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Test::ByteSeq& __p_org, ::Test::ByteSeq& __p_copy, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_org(__p_org),
            _m_copy(__p_copy)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->opOutArrayByteSeq(_m_org, _m_copy, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Test::ByteSeq& _m_org;
        ::Test::ByteSeq& _m_copy;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opOutArrayByteSeq_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(org, copy, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::TestIntf::opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Test::ByteSeq& __p_org, ::Test::ByteSeq& __p_copy, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_org(__p_org),
            _m_copy(__p_copy)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->opOutRangeByteSeq(_m_org, _m_copy, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Test::ByteSeq& _m_org;
        ::Test::ByteSeq& _m_copy;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opOutRangeByteSeq_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(org, copy, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Test::IntStringDict
IceDelegateD::Test::TestIntf::opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::IntStringDict& __result, const ::Test::IntStringDict& __p_idict, ::Test::IntStringDict& __p_odict, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_idict(__p_idict),
            _m_odict(__p_odict)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opIntStringDict(_m_idict, _m_odict, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::IntStringDict& _result;
        const ::Test::IntStringDict& _m_idict;
        ::Test::IntStringDict& _m_odict;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opIntStringDict_name, ::Ice::Normal, __context);
    ::Test::IntStringDict __result;
    try
    {
        _DirectI __direct(__result, idict, odict, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceDelegateD::Test::TestIntf::opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::CustomMap< ::Ice::Long, ::Ice::Long>& __result, const ::Test::CustomMap<std::string, ::Ice::Int>& __p_idict, ::Test::CustomMap<std::string, ::Ice::Int>& __p_odict, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_idict(__p_idict),
            _m_odict(__p_odict)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opVarDict(_m_idict, _m_odict, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& _result;
        const ::Test::CustomMap<std::string, ::Ice::Int>& _m_idict;
        ::Test::CustomMap<std::string, ::Ice::Int>& _m_odict;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opVarDict_name, ::Ice::Normal, __context);
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __result;
    try
    {
        _DirectI __direct(__result, idict, odict, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::ShortBuffer
IceDelegateD::Test::TestIntf::opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::ShortBuffer& __result, const ::Test::ShortBuffer& __p_inS, ::Test::ShortBuffer& __p_outS, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inS(__p_inS),
            _m_outS(__p_outS)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opShortBuffer(_m_inS, _m_outS, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::ShortBuffer& _result;
        const ::Test::ShortBuffer& _m_inS;
        ::Test::ShortBuffer& _m_outS;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opShortBuffer_name, ::Ice::Normal, __context);
    ::Test::ShortBuffer __result;
    try
    {
        _DirectI __direct(__result, inS, outS, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::CustomBuffer<bool>
IceDelegateD::Test::TestIntf::opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::CustomBuffer<bool>& __result, const ::Test::CustomBuffer<bool>& __p_inS, ::Test::CustomBuffer<bool>& __p_outS, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inS(__p_inS),
            _m_outS(__p_outS)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBoolBuffer(_m_inS, _m_outS, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::CustomBuffer<bool>& _result;
        const ::Test::CustomBuffer<bool>& _m_inS;
        ::Test::CustomBuffer<bool>& _m_outS;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBoolBuffer_name, ::Ice::Normal, __context);
    ::Test::CustomBuffer<bool> __result;
    try
    {
        _DirectI __direct(__result, inS, outS, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Test::BufferStruct
IceDelegateD::Test::TestIntf::opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Test::BufferStruct& __result, const ::Test::BufferStruct& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->opBufferStruct(_m_s, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Test::BufferStruct& _result;
        const ::Test::BufferStruct& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__opBufferStruct_name, ::Ice::Normal, __context);
    ::Test::BufferStruct __result;
    try
    {
        _DirectI __direct(__result, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Test::TestIntf::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::TestIntf* servant = dynamic_cast< ::Test::TestIntf*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->shutdown(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__TestIntf__shutdown_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Object* Test::upCast(::Test::C* p) { return p; }
::Ice::ObjectPtr
Test::C::ice_clone() const
{
    ::Ice::Object* __p = new C(*this);
    return __p;
}

namespace
{
const ::std::string __Test__C_ids[2] =
{
    "::Ice::Object",
    "::Test::C"
};

}

bool
Test::C::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__C_ids, __Test__C_ids + 2, _s);
}

::std::vector< ::std::string>
Test::C::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__C_ids[0], &__Test__C_ids[2]);
}

const ::std::string&
Test::C::ice_id(const ::Ice::Current&) const
{
    return __Test__C_ids[1];
}

const ::std::string&
Test::C::ice_staticId()
{
    return __Test__C_ids[1];
}

void
Test::C::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::C::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__C : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::C::ice_staticId());
        return new ::Test::C;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__C_Ptr = new __F__Test__C;

class __F__Test__C__Init
{
public:

    __F__Test__C__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::C::ice_staticId(), __F__Test__C_Ptr);
    }

    ~__F__Test__C__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::C::ice_staticId());
    }
};

const __F__Test__C__Init __F__Test__C__i;

}

const ::Ice::ObjectFactoryPtr&
Test::C::ice_factory()
{
    return __F__Test__C_Ptr;
}

void 
Test::__patch(CPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::CPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::C::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::DictClass* p) { return p; }
::Ice::ObjectPtr
Test::DictClass::ice_clone() const
{
    ::Ice::Object* __p = new DictClass(*this);
    return __p;
}

namespace
{
const ::std::string __Test__DictClass_ids[2] =
{
    "::Ice::Object",
    "::Test::DictClass"
};

}

bool
Test::DictClass::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__DictClass_ids, __Test__DictClass_ids + 2, _s);
}

::std::vector< ::std::string>
Test::DictClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__DictClass_ids[0], &__Test__DictClass_ids[2]);
}

const ::std::string&
Test::DictClass::ice_id(const ::Ice::Current&) const
{
    return __Test__DictClass_ids[1];
}

const ::std::string&
Test::DictClass::ice_staticId()
{
    return __Test__DictClass_ids[1];
}

void
Test::DictClass::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(isdict);
    __os->endWriteSlice();
}

void
Test::DictClass::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(isdict);
    __is->endReadSlice();
}

namespace
{

class __F__Test__DictClass : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::DictClass::ice_staticId());
        return new ::Test::DictClass;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__DictClass_Ptr = new __F__Test__DictClass;

class __F__Test__DictClass__Init
{
public:

    __F__Test__DictClass__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::DictClass::ice_staticId(), __F__Test__DictClass_Ptr);
    }

    ~__F__Test__DictClass__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::DictClass::ice_staticId());
    }
};

const __F__Test__DictClass__Init __F__Test__DictClass__i;

}

const ::Ice::ObjectFactoryPtr&
Test::DictClass::ice_factory()
{
    return __F__Test__DictClass_Ptr;
}

void 
Test::__patch(DictClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::DictClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::DictClass::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::TestIntf* p) { return p; }
::Ice::ObjectPtr
Test::TestIntf::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__TestIntf_ids, __Test__TestIntf_ids + 2, _s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__TestIntf_ids[0], &__Test__TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return __Test__TestIntf_ids[1];
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    return __Test__TestIntf_ids[1];
}

::Ice::DispatchStatus
Test::TestIntf::___opDoubleArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const ::Ice::Double*, const ::Ice::Double*> inSeq;
    ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ___inSeq;
    __is->read(___inSeq);
    inSeq = ___inSeq.second;
    __inS.endReadParams();
    ::Test::DoubleSeq outSeq;
    ::Test::DoubleSeq __ret = opDoubleArray(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const bool*, const bool*> inSeq;
    ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___inSeq;
    __is->read(___inSeq);
    inSeq = ___inSeq.second;
    __inS.endReadParams();
    ::Test::BoolSeq outSeq;
    ::Test::BoolSeq __ret = opBoolArray(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::ByteList outSeq;
    ::Test::ByteList __ret = opByteArray(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const ::Test::Variable*, const ::Test::Variable*> inSeq;
    ::std::vector< ::Test::Variable> ___inSeq;
    __is->read(___inSeq);
    if(!___inSeq.empty())
    {
        inSeq.first = &___inSeq[0];
        inSeq.second = inSeq.first + ___inSeq.size();
    }
    else
    {
        inSeq.first = inSeq.second = 0;
    }
    __inS.endReadParams();
    ::Test::VariableList outSeq;
    ::Test::VariableList __ret = opVariableArray(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> inSeq;
    ::Test::BoolSeq ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::BoolSeq outSeq;
    ::Test::BoolSeq __ret = opBoolRange(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> inSeq;
    ::Test::ByteList ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::ByteList outSeq;
    ::Test::ByteList __ret = opByteRange(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> inSeq;
    ::Test::VariableList ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::VariableList outSeq;
    ::Test::VariableList __ret = opVariableRange(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolRangeType(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const bool*, const bool*> inSeq;
    ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___inSeq;
    __is->read(___inSeq);
    inSeq = ___inSeq.second;
    __inS.endReadParams();
    ::Test::BoolSeq outSeq;
    ::Test::BoolSeq __ret = opBoolRangeType(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteRangeType(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> inSeq;
    ::Test::ByteList ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::ByteList outSeq;
    ::Test::ByteList __ret = opByteRangeType(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableRangeType(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> inSeq;
    std::deque< ::Test::Variable> ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::VariableList outSeq;
    ::Test::VariableList __ret = opVariableRangeType(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque<bool> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque<bool> outSeq;
    std::deque<bool> __ret = opBoolSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::BoolList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::BoolList outSeq;
    ::Test::BoolList __ret = opBoolList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolDequeList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::BoolDequeList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::BoolDequeList outSeq;
    ::Test::BoolDequeList __ret = opBoolDequeList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolDequeListArray(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair<const std::deque<bool>*, const std::deque<bool>*> inSeq;
    ::std::vector<std::deque<bool> > ___inSeq;
    __is->read(___inSeq);
    if(!___inSeq.empty())
    {
        inSeq.first = &___inSeq[0];
        inSeq.second = inSeq.first + ___inSeq.size();
    }
    else
    {
        inSeq.first = inSeq.second = 0;
    }
    __inS.endReadParams();
    ::Test::BoolDequeList outSeq;
    ::Test::BoolDequeList __ret = opBoolDequeListArray(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolDequeListRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator> inSeq;
    ::Test::BoolDequeList ___inSeq;
    __is->read(___inSeq);
    inSeq.first = ___inSeq.begin();
    inSeq.second = ___inSeq.end();
    __inS.endReadParams();
    ::Test::BoolDequeList outSeq;
    ::Test::BoolDequeList __ret = opBoolDequeListRange(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Ice::Byte> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque< ::Ice::Byte> outSeq;
    std::deque< ::Ice::Byte> __ret = opByteSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opByteList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ByteList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::ByteList outSeq;
    ::Test::ByteList __ret = opByteList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opMyByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    MyByteSeq inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    MyByteSeq outSeq;
    MyByteSeq __ret = opMyByteSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque<std::string> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque<std::string> outSeq;
    std::deque<std::string> __ret = opStringSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::StringList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::StringList outSeq;
    ::Test::StringList __ret = opStringList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opFixedSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::Fixed> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque< ::Test::Fixed> outSeq;
    std::deque< ::Test::Fixed> __ret = opFixedSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opFixedList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::FixedList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::FixedList outSeq;
    ::Test::FixedList __ret = opFixedList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::Variable> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque< ::Test::Variable> outSeq;
    std::deque< ::Test::Variable> __ret = opVariableSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opVariableList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::VariableList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::VariableList outSeq;
    ::Test::VariableList __ret = opVariableList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringStringDictSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::StringStringDict> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque< ::Test::StringStringDict> outSeq;
    std::deque< ::Test::StringStringDict> __ret = opStringStringDictSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opStringStringDictList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::StringStringDictList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::StringStringDictList outSeq;
    ::Test::StringStringDictList __ret = opStringStringDictList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opESeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::E> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque< ::Test::E> outSeq;
    std::deque< ::Test::E> __ret = opESeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opEList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::EList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::EList outSeq;
    ::Test::EList __ret = opEList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opCPrxSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::CPrx> inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    std::deque< ::Test::CPrx> outSeq;
    std::deque< ::Test::CPrx> __ret = opCPrxSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opCPrxList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CPrxList inSeq;
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::CPrxList outSeq;
    ::Test::CPrxList __ret = opCPrxList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opCSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    std::deque< ::Test::CPtr> inSeq;
    __is->read(inSeq);
    __is->readPendingObjects();
    __inS.endReadParams();
    std::deque< ::Test::CPtr> outSeq;
    std::deque< ::Test::CPtr> __ret = opCSeq(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __os->writePendingObjects();
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opCList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CList inSeq;
    __is->read(inSeq);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::CList outSeq;
    ::Test::CList __ret = opCList(inSeq, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outSeq);
    __os->write(__ret);
    __os->writePendingObjects();
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opClassStruct(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ClassStructPtr inS;
    ::Test::ClassStructSeq inSeq;
    __is->read(inS);
    __is->read(inSeq);
    __inS.endReadParams();
    ::Test::ClassStructPtr outS;
    ::Test::ClassStructSeq outSeq;
    ::Test::ClassStructPtr __ret = opClassStruct(inS, inSeq, outS, outSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outS);
    __os->write(outSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opOutArrayByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ByteSeq org;
    __is->read(org);
    __inS.endReadParams();
    ::Test::ByteSeq copy;
    opOutArrayByteSeq(org, copy, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(copy);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opOutRangeByteSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ByteSeq org;
    __is->read(org);
    __inS.endReadParams();
    ::Test::ByteSeq copy;
    opOutRangeByteSeq(org, copy, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(copy);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opIntStringDict(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::IntStringDict idict;
    __is->read(idict);
    __inS.endReadParams();
    ::Test::IntStringDict odict;
    ::Test::IntStringDict __ret = opIntStringDict(idict, odict, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(odict);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opVarDict(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> idict;
    __is->read(idict);
    __inS.endReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> odict;
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret = opVarDict(idict, odict, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(odict);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opShortBuffer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::ShortBuffer inS;
    __is->read(inS);
    __inS.endReadParams();
    ::Test::ShortBuffer outS;
    ::Test::ShortBuffer __ret = opShortBuffer(inS, outS, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outS);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBoolBuffer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::CustomBuffer<bool> inS;
    __is->read(inS);
    __inS.endReadParams();
    ::Test::CustomBuffer<bool> outS;
    ::Test::CustomBuffer<bool> __ret = opBoolBuffer(inS, outS, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(outS);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___opBufferStruct(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::BufferStruct s;
    __is->read(s);
    __inS.endReadParams();
    ::Test::BufferStruct __ret = opBufferStruct(s, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::TestIntf::___shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    shutdown(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__TestIntf_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolArray",
    "opBoolBuffer",
    "opBoolDequeList",
    "opBoolDequeListArray",
    "opBoolDequeListRange",
    "opBoolList",
    "opBoolRange",
    "opBoolRangeType",
    "opBoolSeq",
    "opBufferStruct",
    "opByteArray",
    "opByteList",
    "opByteRange",
    "opByteRangeType",
    "opByteSeq",
    "opCList",
    "opCPrxList",
    "opCPrxSeq",
    "opCSeq",
    "opClassStruct",
    "opDoubleArray",
    "opEList",
    "opESeq",
    "opFixedList",
    "opFixedSeq",
    "opIntStringDict",
    "opMyByteSeq",
    "opOutArrayByteSeq",
    "opOutRangeByteSeq",
    "opShortBuffer",
    "opStringList",
    "opStringSeq",
    "opStringStringDictList",
    "opStringStringDictSeq",
    "opVarDict",
    "opVariableArray",
    "opVariableList",
    "opVariableRange",
    "opVariableRangeType",
    "opVariableSeq",
    "shutdown"
};

}

::Ice::DispatchStatus
Test::TestIntf::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__TestIntf_all, __Test__TestIntf_all + 45, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__TestIntf_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___opBoolArray(in, current);
        }
        case 5:
        {
            return ___opBoolBuffer(in, current);
        }
        case 6:
        {
            return ___opBoolDequeList(in, current);
        }
        case 7:
        {
            return ___opBoolDequeListArray(in, current);
        }
        case 8:
        {
            return ___opBoolDequeListRange(in, current);
        }
        case 9:
        {
            return ___opBoolList(in, current);
        }
        case 10:
        {
            return ___opBoolRange(in, current);
        }
        case 11:
        {
            return ___opBoolRangeType(in, current);
        }
        case 12:
        {
            return ___opBoolSeq(in, current);
        }
        case 13:
        {
            return ___opBufferStruct(in, current);
        }
        case 14:
        {
            return ___opByteArray(in, current);
        }
        case 15:
        {
            return ___opByteList(in, current);
        }
        case 16:
        {
            return ___opByteRange(in, current);
        }
        case 17:
        {
            return ___opByteRangeType(in, current);
        }
        case 18:
        {
            return ___opByteSeq(in, current);
        }
        case 19:
        {
            return ___opCList(in, current);
        }
        case 20:
        {
            return ___opCPrxList(in, current);
        }
        case 21:
        {
            return ___opCPrxSeq(in, current);
        }
        case 22:
        {
            return ___opCSeq(in, current);
        }
        case 23:
        {
            return ___opClassStruct(in, current);
        }
        case 24:
        {
            return ___opDoubleArray(in, current);
        }
        case 25:
        {
            return ___opEList(in, current);
        }
        case 26:
        {
            return ___opESeq(in, current);
        }
        case 27:
        {
            return ___opFixedList(in, current);
        }
        case 28:
        {
            return ___opFixedSeq(in, current);
        }
        case 29:
        {
            return ___opIntStringDict(in, current);
        }
        case 30:
        {
            return ___opMyByteSeq(in, current);
        }
        case 31:
        {
            return ___opOutArrayByteSeq(in, current);
        }
        case 32:
        {
            return ___opOutRangeByteSeq(in, current);
        }
        case 33:
        {
            return ___opShortBuffer(in, current);
        }
        case 34:
        {
            return ___opStringList(in, current);
        }
        case 35:
        {
            return ___opStringSeq(in, current);
        }
        case 36:
        {
            return ___opStringStringDictList(in, current);
        }
        case 37:
        {
            return ___opStringStringDictSeq(in, current);
        }
        case 38:
        {
            return ___opVarDict(in, current);
        }
        case 39:
        {
            return ___opVariableArray(in, current);
        }
        case 40:
        {
            return ___opVariableList(in, current);
        }
        case 41:
        {
            return ___opVariableRange(in, current);
        }
        case 42:
        {
            return ___opVariableRangeType(in, current);
        }
        case 43:
        {
            return ___opVariableSeq(in, current);
        }
        case 44:
        {
            return ___shutdown(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::TestIntf::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::TestIntf::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(TestIntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::TestIntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::TestIntf::ice_staticId(), v);
    }
}
