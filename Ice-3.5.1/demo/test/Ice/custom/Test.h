// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>
#include <deque>
#include <list>
#include <MyByteSeq.h>
#include <CustomMap.h>
#include <CustomBuffer.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::C*);

class DictClass;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::DictClass>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::DictClass*);

class TestIntf;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::TestIntf*);

}

}

namespace Test
{

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::C*);
typedef ::IceInternal::Handle< ::Test::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class DictClass;
bool operator==(const DictClass&, const DictClass&);
bool operator<(const DictClass&, const DictClass&);
::Ice::Object* upCast(::Test::DictClass*);
typedef ::IceInternal::Handle< ::Test::DictClass> DictClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DictClass> DictClassPrx;
void __patch(DictClassPtr&, const ::Ice::ObjectPtr&);

class TestIntf;
bool operator==(const TestIntf&, const TestIntf&);
bool operator<(const TestIntf&, const TestIntf&);
::Ice::Object* upCast(::Test::TestIntf*);
typedef ::IceInternal::Handle< ::Test::TestIntf> TestIntfPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
void __patch(TestIntfPtr&, const ::Ice::ObjectPtr&);

}

namespace Test
{

typedef ::std::vector<bool> BoolSeq;

typedef std::list<bool> BoolList;

typedef std::list< ::Test::BoolList> BoolListList;

typedef ::std::vector< ::Test::BoolList> BoolListSeq;

typedef std::list< ::Test::BoolSeq> BoolSeqList;

typedef std::list<std::deque<bool> > BoolDequeList;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef std::list< ::Ice::Byte> ByteList;

typedef std::list< ::Test::ByteList> ByteListList;

typedef ::std::vector< ::Test::ByteList> ByteListSeq;

typedef std::list< ::Test::ByteSeq> ByteSeqList;

typedef ::std::vector< ::std::string> StringSeq;

typedef std::list<std::string> StringList;

typedef std::list< ::Test::StringList> StringListList;

typedef ::std::vector< ::Test::StringList> StringListSeq;

typedef std::list< ::Test::StringSeq> StringSeqList;

struct Fixed
{
    ::Ice::Short s;

    bool operator==(const Fixed& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(s != __rhs.s)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Fixed& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(s < __rhs.s)
        {
            return true;
        }
        else if(__rhs.s < s)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Fixed& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Fixed& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Fixed& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Fixed& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::Test::Fixed> FixedSeq;

typedef std::list< ::Test::Fixed> FixedList;

typedef std::list< ::Test::FixedList> FixedListList;

typedef ::std::vector< ::Test::FixedList> FixedListSeq;

typedef std::list< ::Test::FixedSeq> FixedSeqList;

struct Variable
{
    ::std::string s;
    ::Test::BoolList bl;
    std::list<std::string> ss;

    bool operator==(const Variable& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(s != __rhs.s)
        {
            return false;
        }
        if(bl != __rhs.bl)
        {
            return false;
        }
        if(ss != __rhs.ss)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Variable& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(s < __rhs.s)
        {
            return true;
        }
        else if(__rhs.s < s)
        {
            return false;
        }
        if(bl < __rhs.bl)
        {
            return true;
        }
        else if(__rhs.bl < bl)
        {
            return false;
        }
        if(ss < __rhs.ss)
        {
            return true;
        }
        else if(__rhs.ss < ss)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Variable& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Variable& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Variable& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Variable& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::Test::Variable> VariableSeq;

typedef std::list< ::Test::Variable> VariableList;

typedef std::list< ::Test::VariableList> VariableListList;

typedef ::std::vector< ::Test::VariableList> VariableListSeq;

typedef std::list< ::Test::VariableSeq> VariableSeqList;

typedef ::std::map< ::std::string, ::std::string> StringStringDict;

typedef ::std::vector< ::Test::StringStringDict> StringStringDictSeq;

typedef std::list< ::Test::StringStringDict> StringStringDictList;

typedef std::list< ::Test::StringStringDictList> StringStringDictListList;

typedef ::std::vector< ::Test::StringStringDictList> StringStringDictListSeq;

typedef std::list< ::Test::StringStringDictSeq> StringStringDictSeqList;

enum E
{
    E1,
    E2,
    E3
};

typedef ::std::vector< ::Test::E> ESeq;

typedef std::list< ::Test::E> EList;

typedef std::list< ::Test::EList> EListList;

typedef ::std::vector< ::Test::EList> EListSeq;

typedef std::list< ::Test::ESeq> ESeqList;

typedef ::std::vector< ::Test::CPtr> CSeq;

typedef std::list< ::Test::CPtr> CList;

typedef std::list< ::Test::CList> CListList;

typedef ::std::vector< ::Test::CList> CListSeq;

typedef std::list< ::Test::CSeq> CSeqList;

typedef ::std::vector< ::Test::CPrx> CPrxSeq;

typedef std::list< ::Test::CPrx> CPrxList;

typedef std::list< ::Test::CPrxList> CPrxListList;

typedef ::std::vector< ::Test::CPrxList> CPrxListSeq;

typedef std::list< ::Test::CPrxSeq> CPrxSeqList;

typedef ::std::vector< ::Ice::Double> DoubleSeq;

class ClassOtherStruct : public IceUtil::Shared
{
public:
    
    ClassOtherStruct() {}
    explicit ClassOtherStruct(::Ice::Int __ice_x) :
        x(__ice_x)
    {
    }
    

    ::Ice::Int x;

    bool operator==(const ClassOtherStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(x != __rhs.x)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassOtherStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(x < __rhs.x)
        {
            return true;
        }
        else if(__rhs.x < x)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassOtherStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ClassOtherStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ClassOtherStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ClassOtherStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::IceUtil::Handle< ::Test::ClassOtherStruct> ClassOtherStructPtr;

typedef ::std::vector< ::Test::ClassOtherStructPtr> ClassOtherStructSeq;

class ClassStruct : public IceUtil::Shared
{
public:
    
    ClassStruct() {}
    ClassStruct(const ::Test::ClassOtherStructSeq& __ice_otherSeq, const ::Test::ClassOtherStructPtr& __ice_other, ::Ice::Int __ice_y) :
        otherSeq(__ice_otherSeq),
        other(__ice_other),
        y(__ice_y)
    {
    }
    

    ::Test::ClassOtherStructSeq otherSeq;
    ::Test::ClassOtherStructPtr other;
    ::Ice::Int y;

    bool operator==(const ClassStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(otherSeq != __rhs.otherSeq)
        {
            return false;
        }
        if(other != __rhs.other)
        {
            return false;
        }
        if(y != __rhs.y)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(otherSeq < __rhs.otherSeq)
        {
            return true;
        }
        else if(__rhs.otherSeq < otherSeq)
        {
            return false;
        }
        if(other < __rhs.other)
        {
            return true;
        }
        else if(__rhs.other < other)
        {
            return false;
        }
        if(y < __rhs.y)
        {
            return true;
        }
        else if(__rhs.y < y)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ClassStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ClassStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ClassStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::IceUtil::Handle< ::Test::ClassStruct> ClassStructPtr;

typedef ::std::vector< ::Test::ClassStructPtr> ClassStructSeq;

typedef Test::CustomMap<Ice::Int, std::string> IntStringDict;

typedef ::std::map< ::Ice::Long, ::Ice::Long> LongLongDict;

typedef ::std::map< ::std::string, ::Ice::Int> StringIntDict;

typedef Test::CustomBuffer<bool> BoolBuffer;

typedef Test::CustomBuffer<Ice::Short> ShortBuffer;

typedef Test::CustomBuffer<Ice::Int> IntBuffer;

typedef Test::CustomBuffer<Ice::Long> LongBuffer;

typedef Test::CustomBuffer<Ice::Float> FloatBuffer;

typedef Test::CustomBuffer<Ice::Double> DoubleBuffer;

typedef Test::CustomBuffer<Ice::Byte> ByteBuffer;

struct BufferStruct
{
    ::Test::ByteBuffer byteBuf;
    ::Test::BoolBuffer boolBuf;
    ::Test::ShortBuffer shortBuf;
    ::Test::IntBuffer intBuf;
    ::Test::LongBuffer longBuf;
    ::Test::FloatBuffer floatBuf;
    ::Test::DoubleBuffer doubleBuf;

    bool operator==(const BufferStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(byteBuf != __rhs.byteBuf)
        {
            return false;
        }
        if(boolBuf != __rhs.boolBuf)
        {
            return false;
        }
        if(shortBuf != __rhs.shortBuf)
        {
            return false;
        }
        if(intBuf != __rhs.intBuf)
        {
            return false;
        }
        if(longBuf != __rhs.longBuf)
        {
            return false;
        }
        if(floatBuf != __rhs.floatBuf)
        {
            return false;
        }
        if(doubleBuf != __rhs.doubleBuf)
        {
            return false;
        }
        return true;
    }

    bool operator<(const BufferStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(byteBuf < __rhs.byteBuf)
        {
            return true;
        }
        else if(__rhs.byteBuf < byteBuf)
        {
            return false;
        }
        if(boolBuf < __rhs.boolBuf)
        {
            return true;
        }
        else if(__rhs.boolBuf < boolBuf)
        {
            return false;
        }
        if(shortBuf < __rhs.shortBuf)
        {
            return true;
        }
        else if(__rhs.shortBuf < shortBuf)
        {
            return false;
        }
        if(intBuf < __rhs.intBuf)
        {
            return true;
        }
        else if(__rhs.intBuf < intBuf)
        {
            return false;
        }
        if(longBuf < __rhs.longBuf)
        {
            return true;
        }
        else if(__rhs.longBuf < longBuf)
        {
            return false;
        }
        if(floatBuf < __rhs.floatBuf)
        {
            return true;
        }
        else if(__rhs.floatBuf < floatBuf)
        {
            return false;
        }
        if(doubleBuf < __rhs.doubleBuf)
        {
            return true;
        }
        else if(__rhs.doubleBuf < doubleBuf)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const BufferStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const BufferStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const BufferStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const BufferStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::Fixed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::Fixed, S>
{
    static void write(S* __os, const ::Test::Fixed& v)
    {
        __os->write(v.s);
    }
};

template<class S>
struct StreamReader< ::Test::Fixed, S>
{
    static void read(S* __is, ::Test::Fixed& v)
    {
        __is->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::Variable>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Variable, S>
{
    static void write(S* __os, const ::Test::Variable& v)
    {
        __os->write(v.s);
        __os->write(v.bl);
        __os->write(v.ss);
    }
};

template<class S>
struct StreamReader< ::Test::Variable, S>
{
    static void read(S* __is, ::Test::Variable& v)
    {
        __is->read(v.s);
        __is->read(v.bl);
        __is->read(v.ss);
    }
};

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::ClassOtherStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::ClassOtherStructPtr, S>
{
    static void write(S* __os, const ::Test::ClassOtherStructPtr& v)
    {
        __os->write(v->x);
    }
};

template<class S>
struct StreamReader< ::Test::ClassOtherStructPtr, S>
{
    static void read(S* __is, ::Test::ClassOtherStructPtr& v)
    {
        __is->read(v->x);
    }
};

template<>
struct StreamableTraits< ::Test::ClassStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::ClassStructPtr, S>
{
    static void write(S* __os, const ::Test::ClassStructPtr& v)
    {
        __os->write(v->otherSeq);
        __os->write(v->other);
        __os->write(v->y);
    }
};

template<class S>
struct StreamReader< ::Test::ClassStructPtr, S>
{
    static void read(S* __is, ::Test::ClassStructPtr& v)
    {
        __is->read(v->otherSeq);
        __is->read(v->other);
        __is->read(v->y);
    }
};

template<>
struct StreamableTraits< ::Test::BufferStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::BufferStruct, S>
{
    static void write(S* __os, const ::Test::BufferStruct& v)
    {
        __os->write(v.byteBuf);
        __os->write(v.boolBuf);
        __os->write(v.shortBuf);
        __os->write(v.intBuf);
        __os->write(v.longBuf);
        __os->write(v.floatBuf);
        __os->write(v.doubleBuf);
    }
};

template<class S>
struct StreamReader< ::Test::BufferStruct, S>
{
    static void read(S* __is, ::Test::BufferStruct& v)
    {
        __is->read(v.byteBuf);
        __is->read(v.boolBuf);
        __is->read(v.shortBuf);
        __is->read(v.intBuf);
        __is->read(v.longBuf);
        __is->read(v.floatBuf);
        __is->read(v.doubleBuf);
    }
};

}

namespace Test
{

class AMI_TestIntf_opDoubleArray : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&) = 0;

    void __response(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& __ret, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opDoubleArray> AMI_TestIntf_opDoubleArrayPtr;

class AMI_TestIntf_opBoolArray : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&) = 0;

    void __response(const ::std::pair<const bool*, const bool*>& __ret, const ::std::pair<const bool*, const bool*>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolArray> AMI_TestIntf_opBoolArrayPtr;

class AMI_TestIntf_opByteArray : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&) = 0;

    void __response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __ret, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opByteArray> AMI_TestIntf_opByteArrayPtr;

class AMI_TestIntf_opVariableArray : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&) = 0;

    void __response(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& __ret, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opVariableArray> AMI_TestIntf_opVariableArrayPtr;

class AMI_TestIntf_opBoolRange : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&) = 0;

    void __response(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& __ret, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolRange> AMI_TestIntf_opBoolRangePtr;

class AMI_TestIntf_opByteRange : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&) = 0;

    void __response(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& __ret, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opByteRange> AMI_TestIntf_opByteRangePtr;

class AMI_TestIntf_opVariableRange : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&) = 0;

    void __response(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& __ret, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opVariableRange> AMI_TestIntf_opVariableRangePtr;

class AMI_TestIntf_opBoolRangeType : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&) = 0;

    void __response(const ::std::pair<const bool*, const bool*>& __ret, const ::std::pair<const bool*, const bool*>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolRangeType> AMI_TestIntf_opBoolRangeTypePtr;

class AMI_TestIntf_opByteRangeType : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&) = 0;

    void __response(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& __ret, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opByteRangeType> AMI_TestIntf_opByteRangeTypePtr;

class AMI_TestIntf_opVariableRangeType : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&) = 0;

    void __response(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& __ret, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opVariableRangeType> AMI_TestIntf_opVariableRangeTypePtr;

class AMI_TestIntf_opBoolSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque<bool>&, const std::deque<bool>&) = 0;

    void __response(const std::deque<bool>& __ret, const std::deque<bool>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolSeq> AMI_TestIntf_opBoolSeqPtr;

class AMI_TestIntf_opBoolList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::BoolList&, const ::Test::BoolList&) = 0;

    void __response(const ::Test::BoolList& __ret, const ::Test::BoolList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolList> AMI_TestIntf_opBoolListPtr;

class AMI_TestIntf_opBoolDequeList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::BoolDequeList&, const ::Test::BoolDequeList&) = 0;

    void __response(const ::Test::BoolDequeList& __ret, const ::Test::BoolDequeList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolDequeList> AMI_TestIntf_opBoolDequeListPtr;

class AMI_TestIntf_opBoolDequeListArray : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&) = 0;

    void __response(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& __ret, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolDequeListArray> AMI_TestIntf_opBoolDequeListArrayPtr;

class AMI_TestIntf_opBoolDequeListRange : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&) = 0;

    void __response(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& __ret, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolDequeListRange> AMI_TestIntf_opBoolDequeListRangePtr;

class AMI_TestIntf_opByteSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&) = 0;

    void __response(const std::deque< ::Ice::Byte>& __ret, const std::deque< ::Ice::Byte>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opByteSeq> AMI_TestIntf_opByteSeqPtr;

class AMI_TestIntf_opByteList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::ByteList&, const ::Test::ByteList&) = 0;

    void __response(const ::Test::ByteList& __ret, const ::Test::ByteList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opByteList> AMI_TestIntf_opByteListPtr;

class AMI_TestIntf_opMyByteSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const MyByteSeq&, const MyByteSeq&) = 0;

    void __response(const MyByteSeq& __ret, const MyByteSeq& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opMyByteSeq> AMI_TestIntf_opMyByteSeqPtr;

class AMI_TestIntf_opStringSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque<std::string>&, const std::deque<std::string>&) = 0;

    void __response(const std::deque<std::string>& __ret, const std::deque<std::string>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opStringSeq> AMI_TestIntf_opStringSeqPtr;

class AMI_TestIntf_opStringList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::StringList&, const ::Test::StringList&) = 0;

    void __response(const ::Test::StringList& __ret, const ::Test::StringList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opStringList> AMI_TestIntf_opStringListPtr;

class AMI_TestIntf_opFixedSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&) = 0;

    void __response(const std::deque< ::Test::Fixed>& __ret, const std::deque< ::Test::Fixed>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opFixedSeq> AMI_TestIntf_opFixedSeqPtr;

class AMI_TestIntf_opFixedList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::FixedList&, const ::Test::FixedList&) = 0;

    void __response(const ::Test::FixedList& __ret, const ::Test::FixedList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opFixedList> AMI_TestIntf_opFixedListPtr;

class AMI_TestIntf_opVariableSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&) = 0;

    void __response(const std::deque< ::Test::Variable>& __ret, const std::deque< ::Test::Variable>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opVariableSeq> AMI_TestIntf_opVariableSeqPtr;

class AMI_TestIntf_opVariableList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::VariableList&, const ::Test::VariableList&) = 0;

    void __response(const ::Test::VariableList& __ret, const ::Test::VariableList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opVariableList> AMI_TestIntf_opVariableListPtr;

class AMI_TestIntf_opStringStringDictSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&) = 0;

    void __response(const std::deque< ::Test::StringStringDict>& __ret, const std::deque< ::Test::StringStringDict>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opStringStringDictSeq> AMI_TestIntf_opStringStringDictSeqPtr;

class AMI_TestIntf_opStringStringDictList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&) = 0;

    void __response(const ::Test::StringStringDictList& __ret, const ::Test::StringStringDictList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opStringStringDictList> AMI_TestIntf_opStringStringDictListPtr;

class AMI_TestIntf_opESeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&) = 0;

    void __response(const std::deque< ::Test::E>& __ret, const std::deque< ::Test::E>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opESeq> AMI_TestIntf_opESeqPtr;

class AMI_TestIntf_opEList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::EList&, const ::Test::EList&) = 0;

    void __response(const ::Test::EList& __ret, const ::Test::EList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opEList> AMI_TestIntf_opEListPtr;

class AMI_TestIntf_opCPrxSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&) = 0;

    void __response(const std::deque< ::Test::CPrx>& __ret, const std::deque< ::Test::CPrx>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opCPrxSeq> AMI_TestIntf_opCPrxSeqPtr;

class AMI_TestIntf_opCPrxList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::CPrxList&, const ::Test::CPrxList&) = 0;

    void __response(const ::Test::CPrxList& __ret, const ::Test::CPrxList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opCPrxList> AMI_TestIntf_opCPrxListPtr;

class AMI_TestIntf_opCSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&) = 0;

    void __response(const std::deque< ::Test::CPtr>& __ret, const std::deque< ::Test::CPtr>& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opCSeq> AMI_TestIntf_opCSeqPtr;

class AMI_TestIntf_opCList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::CList&, const ::Test::CList&) = 0;

    void __response(const ::Test::CList& __ret, const ::Test::CList& outSeq)
    {
        ice_response(__ret, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opCList> AMI_TestIntf_opCListPtr;

class AMI_TestIntf_opClassStruct : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&) = 0;

    void __response(const ::Test::ClassStructPtr& __ret, const ::Test::ClassStructPtr& outS, const ::Test::ClassStructSeq& outSeq)
    {
        ice_response(__ret, outS, outSeq);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opClassStruct> AMI_TestIntf_opClassStructPtr;

class AMI_TestIntf_opOutArrayByteSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&) = 0;

    void __response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& copy)
    {
        ice_response(copy);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opOutArrayByteSeq> AMI_TestIntf_opOutArrayByteSeqPtr;

class AMI_TestIntf_opOutRangeByteSeq : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&) = 0;

    void __response(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>& copy)
    {
        ice_response(copy);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opOutRangeByteSeq> AMI_TestIntf_opOutRangeByteSeqPtr;

class AMI_TestIntf_opIntStringDict : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::IntStringDict&, const ::Test::IntStringDict&) = 0;

    void __response(const ::Test::IntStringDict& __ret, const ::Test::IntStringDict& odict)
    {
        ice_response(__ret, odict);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opIntStringDict> AMI_TestIntf_opIntStringDictPtr;

class AMI_TestIntf_opVarDict : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&) = 0;

    void __response(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& __ret, const ::Test::CustomMap<std::string, ::Ice::Int>& odict)
    {
        ice_response(__ret, odict);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opVarDict> AMI_TestIntf_opVarDictPtr;

class AMI_TestIntf_opShortBuffer : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&) = 0;

    void __response(const ::Test::ShortBuffer& __ret, const ::Test::ShortBuffer& outS)
    {
        ice_response(__ret, outS);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opShortBuffer> AMI_TestIntf_opShortBufferPtr;

class AMI_TestIntf_opBoolBuffer : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&) = 0;

    void __response(const ::Test::CustomBuffer<bool>& __ret, const ::Test::CustomBuffer<bool>& outS)
    {
        ice_response(__ret, outS);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBoolBuffer> AMI_TestIntf_opBoolBufferPtr;

class AMI_TestIntf_opBufferStruct : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Test::BufferStruct&) = 0;

    void __response(const ::Test::BufferStruct& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_opBufferStruct> AMI_TestIntf_opBufferStructPtr;

class AMI_TestIntf_shutdown : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::Test::AMI_TestIntf_shutdown> AMI_TestIntf_shutdownPtr;

}

namespace Test
{

class Callback_TestIntf_opDoubleArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDoubleArray_Base> Callback_TestIntf_opDoubleArrayPtr;

class Callback_TestIntf_opBoolArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolArray_Base> Callback_TestIntf_opBoolArrayPtr;

class Callback_TestIntf_opByteArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteArray_Base> Callback_TestIntf_opByteArrayPtr;

class Callback_TestIntf_opVariableArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableArray_Base> Callback_TestIntf_opVariableArrayPtr;

class Callback_TestIntf_opBoolRange_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolRange_Base> Callback_TestIntf_opBoolRangePtr;

class Callback_TestIntf_opByteRange_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteRange_Base> Callback_TestIntf_opByteRangePtr;

class Callback_TestIntf_opVariableRange_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableRange_Base> Callback_TestIntf_opVariableRangePtr;

class Callback_TestIntf_opBoolRangeType_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolRangeType_Base> Callback_TestIntf_opBoolRangeTypePtr;

class Callback_TestIntf_opByteRangeType_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteRangeType_Base> Callback_TestIntf_opByteRangeTypePtr;

class Callback_TestIntf_opVariableRangeType_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableRangeType_Base> Callback_TestIntf_opVariableRangeTypePtr;

class Callback_TestIntf_opBoolSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolSeq_Base> Callback_TestIntf_opBoolSeqPtr;

class Callback_TestIntf_opBoolList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolList_Base> Callback_TestIntf_opBoolListPtr;

class Callback_TestIntf_opBoolDequeList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolDequeList_Base> Callback_TestIntf_opBoolDequeListPtr;

class Callback_TestIntf_opBoolDequeListArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolDequeListArray_Base> Callback_TestIntf_opBoolDequeListArrayPtr;

class Callback_TestIntf_opBoolDequeListRange_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolDequeListRange_Base> Callback_TestIntf_opBoolDequeListRangePtr;

class Callback_TestIntf_opByteSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteSeq_Base> Callback_TestIntf_opByteSeqPtr;

class Callback_TestIntf_opByteList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteList_Base> Callback_TestIntf_opByteListPtr;

class Callback_TestIntf_opMyByteSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opMyByteSeq_Base> Callback_TestIntf_opMyByteSeqPtr;

class Callback_TestIntf_opStringSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringSeq_Base> Callback_TestIntf_opStringSeqPtr;

class Callback_TestIntf_opStringList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringList_Base> Callback_TestIntf_opStringListPtr;

class Callback_TestIntf_opFixedSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFixedSeq_Base> Callback_TestIntf_opFixedSeqPtr;

class Callback_TestIntf_opFixedList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFixedList_Base> Callback_TestIntf_opFixedListPtr;

class Callback_TestIntf_opVariableSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableSeq_Base> Callback_TestIntf_opVariableSeqPtr;

class Callback_TestIntf_opVariableList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableList_Base> Callback_TestIntf_opVariableListPtr;

class Callback_TestIntf_opStringStringDictSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringStringDictSeq_Base> Callback_TestIntf_opStringStringDictSeqPtr;

class Callback_TestIntf_opStringStringDictList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringStringDictList_Base> Callback_TestIntf_opStringStringDictListPtr;

class Callback_TestIntf_opESeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opESeq_Base> Callback_TestIntf_opESeqPtr;

class Callback_TestIntf_opEList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opEList_Base> Callback_TestIntf_opEListPtr;

class Callback_TestIntf_opCPrxSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCPrxSeq_Base> Callback_TestIntf_opCPrxSeqPtr;

class Callback_TestIntf_opCPrxList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCPrxList_Base> Callback_TestIntf_opCPrxListPtr;

class Callback_TestIntf_opCSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCSeq_Base> Callback_TestIntf_opCSeqPtr;

class Callback_TestIntf_opCList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCList_Base> Callback_TestIntf_opCListPtr;

class Callback_TestIntf_opClassStruct_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opClassStruct_Base> Callback_TestIntf_opClassStructPtr;

class Callback_TestIntf_opOutArrayByteSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOutArrayByteSeq_Base> Callback_TestIntf_opOutArrayByteSeqPtr;

class Callback_TestIntf_opOutRangeByteSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOutRangeByteSeq_Base> Callback_TestIntf_opOutRangeByteSeqPtr;

class Callback_TestIntf_opIntStringDict_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opIntStringDict_Base> Callback_TestIntf_opIntStringDictPtr;

class Callback_TestIntf_opVarDict_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVarDict_Base> Callback_TestIntf_opVarDictPtr;

class Callback_TestIntf_opShortBuffer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opShortBuffer_Base> Callback_TestIntf_opShortBufferPtr;

class Callback_TestIntf_opBoolBuffer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolBuffer_Base> Callback_TestIntf_opBoolBufferPtr;

class Callback_TestIntf_opBufferStruct_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBufferStruct_Base> Callback_TestIntf_opBufferStructPtr;

class Callback_TestIntf_shutdown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class C : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class DictClass : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<DictClass> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_secure(bool __secure) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_twoway() const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_oneway() const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_batchOneway() const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_datagram() const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_batchDatagram() const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_compress(bool __compress) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_timeout(int __timeout) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DictClass> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<DictClass*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class TestIntf : virtual public ::IceProxy::Ice::Object
{
public:

    ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq)
    {
        return opDoubleArray(inSeq, outSeq, 0);
    }
    ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context& __ctx)
    {
        return opDoubleArray(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDoubleArray(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDoubleArray(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDoubleArray(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDoubleArray(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<const ::Ice::Double*, const ::Ice::Double*> outSeq;
                ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ___outSeq;
                ::std::pair<const ::Ice::Double*, const ::Ice::Double*> __ret;
                ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > _____ret;
                try
                {
                    __proxy->___end_opDoubleArray(___outSeq, _____ret, __result);
                    outSeq = ___outSeq.second;
                    __ret = _____ret.second;
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&)> _response;
        };
        return begin_opDoubleArray(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq)
    {
        return begin_opDoubleArray(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opDoubleArray(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Test::Callback_TestIntf_opDoubleArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opDoubleArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::DoubleSeq end_opDoubleArray(::Test::DoubleSeq& outSeq, const ::Ice::AsyncResultPtr&);

     void ___end_opDoubleArray(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& outSeq, ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, ::Test::DoubleSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opDoubleArray_async(const ::Test::AMI_TestIntf_opDoubleArrayPtr&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&);
    bool opDoubleArray_async(const ::Test::AMI_TestIntf_opDoubleArrayPtr&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::Ice::Context&);

    ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq)
    {
        return opBoolArray(inSeq, outSeq, 0);
    }
    ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolArray(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::IceInternal::Function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolArray(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolArray(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolArray(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolArray(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<const bool*, const bool*> outSeq;
                ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___outSeq;
                ::std::pair<const bool*, const bool*> __ret;
                ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > _____ret;
                try
                {
                    __proxy->___end_opBoolArray(___outSeq, _____ret, __result);
                    outSeq = ___outSeq.second;
                    __ret = _____ret.second;
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)> _response;
        };
        return begin_opBoolArray(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq)
    {
        return begin_opBoolArray(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolArray(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Test::Callback_TestIntf_opBoolArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::BoolSeq end_opBoolArray(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr&);

     void ___end_opBoolArray(::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& outSeq, ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolArray_async(const ::Test::AMI_TestIntf_opBoolArrayPtr&, const ::std::pair<const bool*, const bool*>&);
    bool opBoolArray_async(const ::Test::AMI_TestIntf_opBoolArrayPtr&, const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&);

    ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq)
    {
        return opByteArray(inSeq, outSeq, 0);
    }
    ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& __ctx)
    {
        return opByteArray(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteArray(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteArray(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteArray(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteArray(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> outSeq;
                ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> __ret;
                try
                {
                    __proxy->___end_opByteArray(outSeq, __ret, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)> _response;
        };
        return begin_opByteArray(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq)
    {
        return begin_opByteArray(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opByteArray(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Test::Callback_TestIntf_opByteArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opByteArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::ByteList end_opByteArray(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr&);

     void ___end_opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& outSeq, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, ::Test::ByteList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteArray_async(const ::Test::AMI_TestIntf_opByteArrayPtr&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);
    bool opByteArray_async(const ::Test::AMI_TestIntf_opByteArrayPtr&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::Ice::Context&);

    ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq)
    {
        return opVariableArray(inSeq, outSeq, 0);
    }
    ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& __ctx)
    {
        return opVariableArray(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::IceInternal::Function<void (const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableArray(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableArray(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableArray(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableArray(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<const ::Test::Variable*, const ::Test::Variable*> outSeq;
                ::std::vector< ::Test::Variable> ___outSeq;
                ::std::pair<const ::Test::Variable*, const ::Test::Variable*> __ret;
                ::std::vector< ::Test::Variable> _____ret;
                try
                {
                    __proxy->___end_opVariableArray(___outSeq, _____ret, __result);
                    if(!___outSeq.empty())
                    {
                        outSeq.first = &___outSeq[0];
                        outSeq.second = outSeq.first + ___outSeq.size();
                    }
                    else
                    {
                        outSeq.first = outSeq.second = 0;
                    }
                    if(!_____ret.empty())
                    {
                        __ret.first = &_____ret[0];
                        __ret.second = __ret.first + _____ret.size();
                    }
                    else
                    {
                        __ret.first = __ret.second = 0;
                    }
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&)> _response;
        };
        return begin_opVariableArray(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq)
    {
        return begin_opVariableArray(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opVariableArray(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Test::Callback_TestIntf_opVariableArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opVariableArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::VariableList end_opVariableArray(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr&);

     void ___end_opVariableArray(::std::vector< ::Test::Variable>& outSeq, ::std::vector< ::Test::Variable>& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, ::Test::VariableList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opVariableArray_async(const ::Test::AMI_TestIntf_opVariableArrayPtr&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&);
    bool opVariableArray_async(const ::Test::AMI_TestIntf_opVariableArrayPtr&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::Ice::Context&);

    ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq)
    {
        return opBoolRange(inSeq, outSeq, 0);
    }
    ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolRange(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolRange(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolRange(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolRange(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolRange(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> outSeq;
                ::Test::BoolSeq ___outSeq;
                ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> __ret;
                ::Test::BoolSeq _____ret;
                try
                {
                    _____ret = __proxy->end_opBoolRange(___outSeq, __result);
                    outSeq.first = ___outSeq.begin();
                    outSeq.second = ___outSeq.end();
                    __ret.first = _____ret.begin();
                    __ret.second = _____ret.end();
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&)> _response;
        };
        return begin_opBoolRange(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq)
    {
        return begin_opBoolRange(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolRange(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opBoolRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::BoolSeq end_opBoolRange(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, ::Test::BoolSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolRange_async(const ::Test::AMI_TestIntf_opBoolRangePtr&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&);
    bool opBoolRange_async(const ::Test::AMI_TestIntf_opBoolRangePtr&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::Ice::Context&);

    ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq)
    {
        return opByteRange(inSeq, outSeq, 0);
    }
    ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& __ctx)
    {
        return opByteRange(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteRange(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteRange(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteRange(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteRange(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> outSeq;
                ::Test::ByteList ___outSeq;
                ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> __ret;
                ::Test::ByteList _____ret;
                try
                {
                    _____ret = __proxy->end_opByteRange(___outSeq, __result);
                    outSeq.first = ___outSeq.begin();
                    outSeq.second = ___outSeq.end();
                    __ret.first = _____ret.begin();
                    __ret.second = _____ret.end();
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)> _response;
        };
        return begin_opByteRange(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq)
    {
        return begin_opByteRange(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opByteRange(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opByteRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opByteRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::ByteList end_opByteRange(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteRange_async(const ::Test::AMI_TestIntf_opByteRangePtr&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&);
    bool opByteRange_async(const ::Test::AMI_TestIntf_opByteRangePtr&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context&);

    ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq)
    {
        return opVariableRange(inSeq, outSeq, 0);
    }
    ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& __ctx)
    {
        return opVariableRange(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableRange(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableRange(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableRange(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableRange(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> outSeq;
                ::Test::VariableList ___outSeq;
                ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> __ret;
                ::Test::VariableList _____ret;
                try
                {
                    _____ret = __proxy->end_opVariableRange(___outSeq, __result);
                    outSeq.first = ___outSeq.begin();
                    outSeq.second = ___outSeq.end();
                    __ret.first = _____ret.begin();
                    __ret.second = _____ret.end();
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&)> _response;
        };
        return begin_opVariableRange(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq)
    {
        return begin_opVariableRange(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opVariableRange(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opVariableRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opVariableRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::VariableList end_opVariableRange(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opVariableRange_async(const ::Test::AMI_TestIntf_opVariableRangePtr&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&);
    bool opVariableRange_async(const ::Test::AMI_TestIntf_opVariableRangePtr&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::Ice::Context&);

    ::Test::BoolSeq opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq)
    {
        return opBoolRangeType(inSeq, outSeq, 0);
    }
    ::Test::BoolSeq opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolRangeType(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::IceInternal::Function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolRangeType(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolRangeType(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolRangeType(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolRangeType(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<const bool*, const bool*> outSeq;
                ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___outSeq;
                ::std::pair<const bool*, const bool*> __ret;
                ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > _____ret;
                try
                {
                    __proxy->___end_opBoolRangeType(___outSeq, _____ret, __result);
                    outSeq = ___outSeq.second;
                    __ret = _____ret.second;
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&)> _response;
        };
        return begin_opBoolRangeType(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq)
    {
        return begin_opBoolRangeType(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolRangeType(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRangeType(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRangeType(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Test::Callback_TestIntf_opBoolRangeTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRangeType(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolRangeTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolRangeType(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::BoolSeq end_opBoolRangeType(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr&);

     void ___end_opBoolRangeType(::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& outSeq, ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolSeq opBoolRangeType(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolRangeType(const ::std::pair<const bool*, const bool*>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolRangeType_async(const ::Test::AMI_TestIntf_opBoolRangeTypePtr&, const ::std::pair<const bool*, const bool*>&);
    bool opBoolRangeType_async(const ::Test::AMI_TestIntf_opBoolRangeTypePtr&, const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&);

    ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq)
    {
        return opByteRangeType(inSeq, outSeq, 0);
    }
    ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& __ctx)
    {
        return opByteRangeType(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteRangeType(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteRangeType(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteRangeType(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteRangeType(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> outSeq;
                ::Test::ByteList ___outSeq;
                ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> __ret;
                ::Test::ByteList _____ret;
                try
                {
                    _____ret = __proxy->end_opByteRangeType(___outSeq, __result);
                    outSeq.first = ___outSeq.begin();
                    outSeq.second = ___outSeq.end();
                    __ret.first = _____ret.begin();
                    __ret.second = _____ret.end();
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&)> _response;
        };
        return begin_opByteRangeType(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq)
    {
        return begin_opByteRangeType(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opByteRangeType(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRangeType(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRangeType(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opByteRangeTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRangeType(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opByteRangeTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteRangeType(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::ByteList end_opByteRangeType(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteRangeType_async(const ::Test::AMI_TestIntf_opByteRangeTypePtr&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&);
    bool opByteRangeType_async(const ::Test::AMI_TestIntf_opByteRangeTypePtr&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context&);

    ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq)
    {
        return opVariableRangeType(inSeq, outSeq, 0);
    }
    ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& __ctx)
    {
        return opVariableRangeType(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableRangeType(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableRangeType(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableRangeType(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableRangeType(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> outSeq;
                std::deque< ::Test::Variable> ___outSeq;
                ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> __ret;
                std::deque< ::Test::Variable> _____ret;
                try
                {
                    __proxy->___end_opVariableRangeType(___outSeq, _____ret, __result);
                    outSeq.first = ___outSeq.begin();
                    outSeq.second = ___outSeq.end();
                    __ret.first = _____ret.begin();
                    __ret.second = _____ret.end();
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&)> _response;
        };
        return begin_opVariableRangeType(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq)
    {
        return begin_opVariableRangeType(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opVariableRangeType(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRangeType(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRangeType(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opVariableRangeTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRangeType(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opVariableRangeTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableRangeType(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::VariableList end_opVariableRangeType(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr&);

     void ___end_opVariableRangeType(std::deque< ::Test::Variable>& outSeq, std::deque< ::Test::Variable>& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opVariableRangeType_async(const ::Test::AMI_TestIntf_opVariableRangeTypePtr&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&);
    bool opVariableRangeType_async(const ::Test::AMI_TestIntf_opVariableRangeTypePtr&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::Ice::Context&);

    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq)
    {
        return opBoolSeq(inSeq, outSeq, 0);
    }
    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const std::deque<bool>& inSeq, const ::IceInternal::Function<void (const std::deque<bool>&, const std::deque<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const std::deque<bool>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque<bool>&, const std::deque<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque<bool>&, const std::deque<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque<bool>&, const std::deque<bool>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque<bool> outSeq;
                std::deque<bool> __ret;
                try
                {
                    __ret = __proxy->end_opBoolSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque<bool>&, const std::deque<bool>&)> _response;
        };
        return begin_opBoolSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq)
    {
        return begin_opBoolSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Test::Callback_TestIntf_opBoolSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque<bool> end_opBoolSeq(std::deque<bool>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque<bool> opBoolSeq(const std::deque<bool>&, std::deque<bool>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolSeq_async(const ::Test::AMI_TestIntf_opBoolSeqPtr&, const std::deque<bool>&);
    bool opBoolSeq_async(const ::Test::AMI_TestIntf_opBoolSeqPtr&, const std::deque<bool>&, const ::Ice::Context&);

    ::Test::BoolList opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq)
    {
        return opBoolList(inSeq, outSeq, 0);
    }
    ::Test::BoolList opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolList(const ::Test::BoolList& inSeq, const ::IceInternal::Function<void (const ::Test::BoolList&, const ::Test::BoolList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolList(const ::Test::BoolList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BoolList&, const ::Test::BoolList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BoolList&, const ::Test::BoolList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BoolList&, const ::Test::BoolList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BoolList outSeq;
                ::Test::BoolList __ret;
                try
                {
                    __ret = __proxy->end_opBoolList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BoolList&, const ::Test::BoolList&)> _response;
        };
        return begin_opBoolList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq)
    {
        return begin_opBoolList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Test::Callback_TestIntf_opBoolListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::BoolList end_opBoolList(::Test::BoolList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolList opBoolList(const ::Test::BoolList&, ::Test::BoolList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolList_async(const ::Test::AMI_TestIntf_opBoolListPtr&, const ::Test::BoolList&);
    bool opBoolList_async(const ::Test::AMI_TestIntf_opBoolListPtr&, const ::Test::BoolList&, const ::Ice::Context&);

    ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList& inSeq, ::Test::BoolDequeList& outSeq)
    {
        return opBoolDequeList(inSeq, outSeq, 0);
    }
    ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolDequeList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::IceInternal::Function<void (const ::Test::BoolDequeList&, const ::Test::BoolDequeList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolDequeList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolDequeList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BoolDequeList&, const ::Test::BoolDequeList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolDequeList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolDequeList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BoolDequeList&, const ::Test::BoolDequeList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BoolDequeList&, const ::Test::BoolDequeList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BoolDequeList outSeq;
                ::Test::BoolDequeList __ret;
                try
                {
                    __ret = __proxy->end_opBoolDequeList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BoolDequeList&, const ::Test::BoolDequeList&)> _response;
        };
        return begin_opBoolDequeList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq)
    {
        return begin_opBoolDequeList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolDequeList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Test::Callback_TestIntf_opBoolDequeListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolDequeListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::BoolDequeList end_opBoolDequeList(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList&, ::Test::BoolDequeList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolDequeList_async(const ::Test::AMI_TestIntf_opBoolDequeListPtr&, const ::Test::BoolDequeList&);
    bool opBoolDequeList_async(const ::Test::AMI_TestIntf_opBoolDequeListPtr&, const ::Test::BoolDequeList&, const ::Ice::Context&);

    ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, ::Test::BoolDequeList& outSeq)
    {
        return opBoolDequeListArray(inSeq, outSeq, 0);
    }
    ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolDequeListArray(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::IceInternal::Function<void (const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolDequeListArray(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolDequeListArray(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolDequeListArray(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolDequeListArray(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<const std::deque<bool>*, const std::deque<bool>*> outSeq;
                ::std::vector<std::deque<bool> > ___outSeq;
                ::std::pair<const std::deque<bool>*, const std::deque<bool>*> __ret;
                ::std::vector<std::deque<bool> > _____ret;
                try
                {
                    __proxy->___end_opBoolDequeListArray(___outSeq, _____ret, __result);
                    if(!___outSeq.empty())
                    {
                        outSeq.first = &___outSeq[0];
                        outSeq.second = outSeq.first + ___outSeq.size();
                    }
                    else
                    {
                        outSeq.first = outSeq.second = 0;
                    }
                    if(!_____ret.empty())
                    {
                        __ret.first = &_____ret[0];
                        __ret.second = __ret.first + _____ret.size();
                    }
                    else
                    {
                        __ret.first = __ret.second = 0;
                    }
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&)> _response;
        };
        return begin_opBoolDequeListArray(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq)
    {
        return begin_opBoolDequeListArray(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolDequeListArray(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Test::Callback_TestIntf_opBoolDequeListArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListArray(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolDequeListArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListArray(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::BoolDequeList end_opBoolDequeListArray(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr&);

     void ___end_opBoolDequeListArray(::std::vector<std::deque<bool> >& outSeq, ::std::vector<std::deque<bool> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, ::Test::BoolDequeList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolDequeListArray_async(const ::Test::AMI_TestIntf_opBoolDequeListArrayPtr&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&);
    bool opBoolDequeListArray_async(const ::Test::AMI_TestIntf_opBoolDequeListArrayPtr&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::Ice::Context&);

    ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, ::Test::BoolDequeList& outSeq)
    {
        return opBoolDequeListRange(inSeq, outSeq, 0);
    }
    ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context& __ctx)
    {
        return opBoolDequeListRange(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolDequeListRange(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolDequeListRange(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolDequeListRange(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolDequeListRange(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator> outSeq;
                ::Test::BoolDequeList ___outSeq;
                ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator> __ret;
                ::Test::BoolDequeList _____ret;
                try
                {
                    _____ret = __proxy->end_opBoolDequeListRange(___outSeq, __result);
                    outSeq.first = ___outSeq.begin();
                    outSeq.second = ___outSeq.end();
                    __ret.first = _____ret.begin();
                    __ret.second = _____ret.end();
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&)> _response;
        };
        return begin_opBoolDequeListRange(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq)
    {
        return begin_opBoolDequeListRange(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opBoolDequeListRange(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opBoolDequeListRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListRange(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolDequeListRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolDequeListRange(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::BoolDequeList end_opBoolDequeListRange(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, ::Test::BoolDequeList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolDequeListRange_async(const ::Test::AMI_TestIntf_opBoolDequeListRangePtr&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&);
    bool opBoolDequeListRange_async(const ::Test::AMI_TestIntf_opBoolDequeListRangePtr&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::Ice::Context&);

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq)
    {
        return opByteSeq(inSeq, outSeq, 0);
    }
    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context& __ctx)
    {
        return opByteSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::IceInternal::Function<void (const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque< ::Ice::Byte> outSeq;
                std::deque< ::Ice::Byte> __ret;
                try
                {
                    __ret = __proxy->end_opByteSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&)> _response;
        };
        return begin_opByteSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq)
    {
        return begin_opByteSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opByteSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Test::Callback_TestIntf_opByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque< ::Ice::Byte> end_opByteSeq(std::deque< ::Ice::Byte>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>&, std::deque< ::Ice::Byte>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteSeq_async(const ::Test::AMI_TestIntf_opByteSeqPtr&, const std::deque< ::Ice::Byte>&);
    bool opByteSeq_async(const ::Test::AMI_TestIntf_opByteSeqPtr&, const std::deque< ::Ice::Byte>&, const ::Ice::Context&);

    ::Test::ByteList opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq)
    {
        return opByteList(inSeq, outSeq, 0);
    }
    ::Test::ByteList opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& __ctx)
    {
        return opByteList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteList(const ::Test::ByteList& inSeq, const ::IceInternal::Function<void (const ::Test::ByteList&, const ::Test::ByteList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteList(const ::Test::ByteList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ByteList&, const ::Test::ByteList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ByteList&, const ::Test::ByteList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ByteList&, const ::Test::ByteList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::ByteList outSeq;
                ::Test::ByteList __ret;
                try
                {
                    __ret = __proxy->end_opByteList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ByteList&, const ::Test::ByteList&)> _response;
        };
        return begin_opByteList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq)
    {
        return begin_opByteList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opByteList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Test::Callback_TestIntf_opByteListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opByteListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::ByteList end_opByteList(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ByteList opByteList(const ::Test::ByteList&, ::Test::ByteList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opByteList_async(const ::Test::AMI_TestIntf_opByteListPtr&, const ::Test::ByteList&);
    bool opByteList_async(const ::Test::AMI_TestIntf_opByteListPtr&, const ::Test::ByteList&, const ::Ice::Context&);

    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq)
    {
        return opMyByteSeq(inSeq, outSeq, 0);
    }
    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context& __ctx)
    {
        return opMyByteSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opMyByteSeq(const MyByteSeq& inSeq, const ::IceInternal::Function<void (const MyByteSeq&, const MyByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyByteSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyByteSeq(const MyByteSeq& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyByteSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const MyByteSeq&, const MyByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyByteSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyByteSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const MyByteSeq&, const MyByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const MyByteSeq&, const MyByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                MyByteSeq outSeq;
                MyByteSeq __ret;
                try
                {
                    __ret = __proxy->end_opMyByteSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const MyByteSeq&, const MyByteSeq&)> _response;
        };
        return begin_opMyByteSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq)
    {
        return begin_opMyByteSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opMyByteSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyByteSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyByteSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Test::Callback_TestIntf_opMyByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyByteSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opMyByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyByteSeq(inSeq, &__ctx, __del, __cookie);
    }

    MyByteSeq end_opMyByteSeq(MyByteSeq& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    MyByteSeq opMyByteSeq(const MyByteSeq&, MyByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opMyByteSeq_async(const ::Test::AMI_TestIntf_opMyByteSeqPtr&, const MyByteSeq&);
    bool opMyByteSeq_async(const ::Test::AMI_TestIntf_opMyByteSeqPtr&, const MyByteSeq&, const ::Ice::Context&);

    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq)
    {
        return opStringSeq(inSeq, outSeq, 0);
    }
    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context& __ctx)
    {
        return opStringSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const std::deque<std::string>& inSeq, const ::IceInternal::Function<void (const std::deque<std::string>&, const std::deque<std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const std::deque<std::string>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque<std::string>&, const std::deque<std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque<std::string>&, const std::deque<std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque<std::string>&, const std::deque<std::string>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque<std::string> outSeq;
                std::deque<std::string> __ret;
                try
                {
                    __ret = __proxy->end_opStringSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque<std::string>&, const std::deque<std::string>&)> _response;
        };
        return begin_opStringSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq)
    {
        return begin_opStringSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opStringSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Test::Callback_TestIntf_opStringSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opStringSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque<std::string> end_opStringSeq(std::deque<std::string>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque<std::string> opStringSeq(const std::deque<std::string>&, std::deque<std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringSeq_async(const ::Test::AMI_TestIntf_opStringSeqPtr&, const std::deque<std::string>&);
    bool opStringSeq_async(const ::Test::AMI_TestIntf_opStringSeqPtr&, const std::deque<std::string>&, const ::Ice::Context&);

    ::Test::StringList opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq)
    {
        return opStringList(inSeq, outSeq, 0);
    }
    ::Test::StringList opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context& __ctx)
    {
        return opStringList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringList(const ::Test::StringList& inSeq, const ::IceInternal::Function<void (const ::Test::StringList&, const ::Test::StringList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringList(const ::Test::StringList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::StringList&, const ::Test::StringList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::StringList&, const ::Test::StringList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::StringList&, const ::Test::StringList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::StringList outSeq;
                ::Test::StringList __ret;
                try
                {
                    __ret = __proxy->end_opStringList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::StringList&, const ::Test::StringList&)> _response;
        };
        return begin_opStringList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq)
    {
        return begin_opStringList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opStringList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Test::Callback_TestIntf_opStringListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opStringListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::StringList end_opStringList(::Test::StringList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::StringList opStringList(const ::Test::StringList&, ::Test::StringList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringList_async(const ::Test::AMI_TestIntf_opStringListPtr&, const ::Test::StringList&);
    bool opStringList_async(const ::Test::AMI_TestIntf_opStringListPtr&, const ::Test::StringList&, const ::Ice::Context&);

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq)
    {
        return opFixedSeq(inSeq, outSeq, 0);
    }
    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context& __ctx)
    {
        return opFixedSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::IceInternal::Function<void (const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque< ::Test::Fixed> outSeq;
                std::deque< ::Test::Fixed> __ret;
                try
                {
                    __ret = __proxy->end_opFixedSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&)> _response;
        };
        return begin_opFixedSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq)
    {
        return begin_opFixedSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opFixedSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Test::Callback_TestIntf_opFixedSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opFixedSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque< ::Test::Fixed> end_opFixedSeq(std::deque< ::Test::Fixed>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>&, std::deque< ::Test::Fixed>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opFixedSeq_async(const ::Test::AMI_TestIntf_opFixedSeqPtr&, const std::deque< ::Test::Fixed>&);
    bool opFixedSeq_async(const ::Test::AMI_TestIntf_opFixedSeqPtr&, const std::deque< ::Test::Fixed>&, const ::Ice::Context&);

    ::Test::FixedList opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq)
    {
        return opFixedList(inSeq, outSeq, 0);
    }
    ::Test::FixedList opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context& __ctx)
    {
        return opFixedList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFixedList(const ::Test::FixedList& inSeq, const ::IceInternal::Function<void (const ::Test::FixedList&, const ::Test::FixedList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedList(const ::Test::FixedList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::FixedList&, const ::Test::FixedList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::FixedList&, const ::Test::FixedList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::FixedList&, const ::Test::FixedList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::FixedList outSeq;
                ::Test::FixedList __ret;
                try
                {
                    __ret = __proxy->end_opFixedList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::FixedList&, const ::Test::FixedList&)> _response;
        };
        return begin_opFixedList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq)
    {
        return begin_opFixedList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opFixedList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Test::Callback_TestIntf_opFixedListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opFixedListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::FixedList end_opFixedList(::Test::FixedList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::FixedList opFixedList(const ::Test::FixedList&, ::Test::FixedList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opFixedList_async(const ::Test::AMI_TestIntf_opFixedListPtr&, const ::Test::FixedList&);
    bool opFixedList_async(const ::Test::AMI_TestIntf_opFixedListPtr&, const ::Test::FixedList&, const ::Ice::Context&);

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq)
    {
        return opVariableSeq(inSeq, outSeq, 0);
    }
    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context& __ctx)
    {
        return opVariableSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::IceInternal::Function<void (const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque< ::Test::Variable> outSeq;
                std::deque< ::Test::Variable> __ret;
                try
                {
                    __ret = __proxy->end_opVariableSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&)> _response;
        };
        return begin_opVariableSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq)
    {
        return begin_opVariableSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opVariableSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Test::Callback_TestIntf_opVariableSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opVariableSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque< ::Test::Variable> end_opVariableSeq(std::deque< ::Test::Variable>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>&, std::deque< ::Test::Variable>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opVariableSeq_async(const ::Test::AMI_TestIntf_opVariableSeqPtr&, const std::deque< ::Test::Variable>&);
    bool opVariableSeq_async(const ::Test::AMI_TestIntf_opVariableSeqPtr&, const std::deque< ::Test::Variable>&, const ::Ice::Context&);

    ::Test::VariableList opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq)
    {
        return opVariableList(inSeq, outSeq, 0);
    }
    ::Test::VariableList opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& __ctx)
    {
        return opVariableList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVariableList(const ::Test::VariableList& inSeq, const ::IceInternal::Function<void (const ::Test::VariableList&, const ::Test::VariableList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableList(const ::Test::VariableList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::VariableList&, const ::Test::VariableList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVariableList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVariableList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::VariableList&, const ::Test::VariableList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::VariableList&, const ::Test::VariableList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::VariableList outSeq;
                ::Test::VariableList __ret;
                try
                {
                    __ret = __proxy->end_opVariableList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::VariableList&, const ::Test::VariableList&)> _response;
        };
        return begin_opVariableList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq)
    {
        return begin_opVariableList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opVariableList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Test::Callback_TestIntf_opVariableListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opVariableListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVariableList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::VariableList end_opVariableList(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::VariableList opVariableList(const ::Test::VariableList&, ::Test::VariableList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opVariableList_async(const ::Test::AMI_TestIntf_opVariableListPtr&, const ::Test::VariableList&);
    bool opVariableList_async(const ::Test::AMI_TestIntf_opVariableListPtr&, const ::Test::VariableList&, const ::Ice::Context&);

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq)
    {
        return opStringStringDictSeq(inSeq, outSeq, 0);
    }
    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context& __ctx)
    {
        return opStringStringDictSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::IceInternal::Function<void (const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringStringDictSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringStringDictSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringStringDictSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringStringDictSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque< ::Test::StringStringDict> outSeq;
                std::deque< ::Test::StringStringDict> __ret;
                try
                {
                    __ret = __proxy->end_opStringStringDictSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&)> _response;
        };
        return begin_opStringStringDictSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq)
    {
        return begin_opStringStringDictSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opStringStringDictSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Test::Callback_TestIntf_opStringStringDictSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opStringStringDictSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque< ::Test::StringStringDict> end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, std::deque< ::Test::StringStringDict>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringStringDictSeq_async(const ::Test::AMI_TestIntf_opStringStringDictSeqPtr&, const std::deque< ::Test::StringStringDict>&);
    bool opStringStringDictSeq_async(const ::Test::AMI_TestIntf_opStringStringDictSeqPtr&, const std::deque< ::Test::StringStringDict>&, const ::Ice::Context&);

    ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq)
    {
        return opStringStringDictList(inSeq, outSeq, 0);
    }
    ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context& __ctx)
    {
        return opStringStringDictList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::IceInternal::Function<void (const ::Test::StringStringDictList&, const ::Test::StringStringDictList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringStringDictList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringStringDictList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::StringStringDictList&, const ::Test::StringStringDictList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringStringDictList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringStringDictList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::StringStringDictList&, const ::Test::StringStringDictList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::StringStringDictList&, const ::Test::StringStringDictList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::StringStringDictList outSeq;
                ::Test::StringStringDictList __ret;
                try
                {
                    __ret = __proxy->end_opStringStringDictList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::StringStringDictList&, const ::Test::StringStringDictList&)> _response;
        };
        return begin_opStringStringDictList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq)
    {
        return begin_opStringStringDictList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opStringStringDictList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Test::Callback_TestIntf_opStringStringDictListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opStringStringDictListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringStringDictList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::StringStringDictList end_opStringStringDictList(::Test::StringStringDictList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList&, ::Test::StringStringDictList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opStringStringDictList_async(const ::Test::AMI_TestIntf_opStringStringDictListPtr&, const ::Test::StringStringDictList&);
    bool opStringStringDictList_async(const ::Test::AMI_TestIntf_opStringStringDictListPtr&, const ::Test::StringStringDictList&, const ::Ice::Context&);

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq)
    {
        return opESeq(inSeq, outSeq, 0);
    }
    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context& __ctx)
    {
        return opESeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::IceInternal::Function<void (const std::deque< ::Test::E>&, const std::deque< ::Test::E>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opESeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opESeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::E>&, const std::deque< ::Test::E>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opESeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opESeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::E>&, const std::deque< ::Test::E>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque< ::Test::E>&, const std::deque< ::Test::E>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque< ::Test::E> outSeq;
                std::deque< ::Test::E> __ret;
                try
                {
                    __ret = __proxy->end_opESeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque< ::Test::E>&, const std::deque< ::Test::E>&)> _response;
        };
        return begin_opESeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq)
    {
        return begin_opESeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opESeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opESeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opESeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Test::Callback_TestIntf_opESeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opESeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opESeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opESeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque< ::Test::E> end_opESeq(std::deque< ::Test::E>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>&, std::deque< ::Test::E>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opESeq_async(const ::Test::AMI_TestIntf_opESeqPtr&, const std::deque< ::Test::E>&);
    bool opESeq_async(const ::Test::AMI_TestIntf_opESeqPtr&, const std::deque< ::Test::E>&, const ::Ice::Context&);

    ::Test::EList opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq)
    {
        return opEList(inSeq, outSeq, 0);
    }
    ::Test::EList opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context& __ctx)
    {
        return opEList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opEList(const ::Test::EList& inSeq, const ::IceInternal::Function<void (const ::Test::EList&, const ::Test::EList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opEList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opEList(const ::Test::EList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opEList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::EList&, const ::Test::EList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opEList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opEList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::EList&, const ::Test::EList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::EList&, const ::Test::EList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::EList outSeq;
                ::Test::EList __ret;
                try
                {
                    __ret = __proxy->end_opEList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::EList&, const ::Test::EList&)> _response;
        };
        return begin_opEList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq)
    {
        return begin_opEList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opEList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opEList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opEList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Test::Callback_TestIntf_opEListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opEList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opEListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opEList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::EList end_opEList(::Test::EList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::EList opEList(const ::Test::EList&, ::Test::EList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opEList_async(const ::Test::AMI_TestIntf_opEListPtr&, const ::Test::EList&);
    bool opEList_async(const ::Test::AMI_TestIntf_opEListPtr&, const ::Test::EList&, const ::Ice::Context&);

    std::deque< ::Test::CPrx> opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, std::deque< ::Test::CPrx>& outSeq)
    {
        return opCPrxSeq(inSeq, outSeq, 0);
    }
    std::deque< ::Test::CPrx> opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, std::deque< ::Test::CPrx>& outSeq, const ::Ice::Context& __ctx)
    {
        return opCPrxSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::IceInternal::Function<void (const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCPrxSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCPrxSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCPrxSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCPrxSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque< ::Test::CPrx> outSeq;
                std::deque< ::Test::CPrx> __ret;
                try
                {
                    __ret = __proxy->end_opCPrxSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&)> _response;
        };
        return begin_opCPrxSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq)
    {
        return begin_opCPrxSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opCPrxSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Test::Callback_TestIntf_opCPrxSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCPrxSeq(const std::deque< ::Test::CPrx>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opCPrxSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque< ::Test::CPrx> end_opCPrxSeq(std::deque< ::Test::CPrx>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque< ::Test::CPrx> opCPrxSeq(const std::deque< ::Test::CPrx>&, std::deque< ::Test::CPrx>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opCPrxSeq(const std::deque< ::Test::CPrx>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opCPrxSeq_async(const ::Test::AMI_TestIntf_opCPrxSeqPtr&, const std::deque< ::Test::CPrx>&);
    bool opCPrxSeq_async(const ::Test::AMI_TestIntf_opCPrxSeqPtr&, const std::deque< ::Test::CPrx>&, const ::Ice::Context&);

    ::Test::CPrxList opCPrxList(const ::Test::CPrxList& inSeq, ::Test::CPrxList& outSeq)
    {
        return opCPrxList(inSeq, outSeq, 0);
    }
    ::Test::CPrxList opCPrxList(const ::Test::CPrxList& inSeq, ::Test::CPrxList& outSeq, const ::Ice::Context& __ctx)
    {
        return opCPrxList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::IceInternal::Function<void (const ::Test::CPrxList&, const ::Test::CPrxList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCPrxList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCPrxList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::CPrxList&, const ::Test::CPrxList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCPrxList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCPrxList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::CPrxList&, const ::Test::CPrxList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::CPrxList&, const ::Test::CPrxList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::CPrxList outSeq;
                ::Test::CPrxList __ret;
                try
                {
                    __ret = __proxy->end_opCPrxList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::CPrxList&, const ::Test::CPrxList&)> _response;
        };
        return begin_opCPrxList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opCPrxList(const ::Test::CPrxList& inSeq)
    {
        return begin_opCPrxList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opCPrxList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Test::Callback_TestIntf_opCPrxListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCPrxList(const ::Test::CPrxList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opCPrxListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCPrxList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::CPrxList end_opCPrxList(::Test::CPrxList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::CPrxList opCPrxList(const ::Test::CPrxList&, ::Test::CPrxList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opCPrxList(const ::Test::CPrxList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opCPrxList_async(const ::Test::AMI_TestIntf_opCPrxListPtr&, const ::Test::CPrxList&);
    bool opCPrxList_async(const ::Test::AMI_TestIntf_opCPrxListPtr&, const ::Test::CPrxList&, const ::Ice::Context&);

    std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq)
    {
        return opCSeq(inSeq, outSeq, 0);
    }
    std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context& __ctx)
    {
        return opCSeq(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::IceInternal::Function<void (const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCSeq(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCSeq(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCSeq(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCSeq(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                std::deque< ::Test::CPtr> outSeq;
                std::deque< ::Test::CPtr> __ret;
                try
                {
                    __ret = __proxy->end_opCSeq(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&)> _response;
        };
        return begin_opCSeq(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq)
    {
        return begin_opCSeq(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opCSeq(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCSeq(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Test::Callback_TestIntf_opCSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCSeq(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opCSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCSeq(inSeq, &__ctx, __del, __cookie);
    }

    std::deque< ::Test::CPtr> end_opCSeq(std::deque< ::Test::CPtr>& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>&, std::deque< ::Test::CPtr>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opCSeq_async(const ::Test::AMI_TestIntf_opCSeqPtr&, const std::deque< ::Test::CPtr>&);
    bool opCSeq_async(const ::Test::AMI_TestIntf_opCSeqPtr&, const std::deque< ::Test::CPtr>&, const ::Ice::Context&);

    ::Test::CList opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq)
    {
        return opCList(inSeq, outSeq, 0);
    }
    ::Test::CList opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context& __ctx)
    {
        return opCList(inSeq, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opCList(const ::Test::CList& inSeq, const ::IceInternal::Function<void (const ::Test::CList&, const ::Test::CList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCList(inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCList(const ::Test::CList& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCList(inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::CList&, const ::Test::CList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCList(inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCList(inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::CList&, const ::Test::CList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::CList&, const ::Test::CList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::CList outSeq;
                ::Test::CList __ret;
                try
                {
                    __ret = __proxy->end_opCList(outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::CList&, const ::Test::CList&)> _response;
        };
        return begin_opCList(inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq)
    {
        return begin_opCList(inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opCList(inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCList(inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Test::Callback_TestIntf_opCListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCList(inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opCListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCList(inSeq, &__ctx, __del, __cookie);
    }

    ::Test::CList end_opCList(::Test::CList& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::CList opCList(const ::Test::CList&, ::Test::CList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opCList_async(const ::Test::AMI_TestIntf_opCListPtr&, const ::Test::CList&);
    bool opCList_async(const ::Test::AMI_TestIntf_opCListPtr&, const ::Test::CList&, const ::Ice::Context&);

    ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq)
    {
        return opClassStruct(inS, inSeq, outS, outSeq, 0);
    }
    ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context& __ctx)
    {
        return opClassStruct(inS, inSeq, outS, outSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::IceInternal::Function<void (const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opClassStruct(inS, inSeq, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opClassStruct(inS, inSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opClassStruct(inS, inSeq, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opClassStruct(inS, inSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::ClassStructPtr outS;
                ::Test::ClassStructSeq outSeq;
                ::Test::ClassStructPtr __ret;
                try
                {
                    __ret = __proxy->end_opClassStruct(outS, outSeq, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outS, outSeq);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&)> _response;
        };
        return begin_opClassStruct(inS, inSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq)
    {
        return begin_opClassStruct(inS, inSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& __ctx)
    {
        return begin_opClassStruct(inS, inSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassStruct(inS, inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassStruct(inS, inSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Test::Callback_TestIntf_opClassStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassStruct(inS, inSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opClassStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassStruct(inS, inSeq, &__ctx, __del, __cookie);
    }

    ::Test::ClassStructPtr end_opClassStruct(::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, ::Test::ClassStructPtr&, ::Test::ClassStructSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opClassStruct_async(const ::Test::AMI_TestIntf_opClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&);
    bool opClassStruct_async(const ::Test::AMI_TestIntf_opClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, const ::Ice::Context&);

    void opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy)
    {
        opOutArrayByteSeq(org, copy, 0);
    }
    void opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context& __ctx)
    {
        opOutArrayByteSeq(org, copy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOutArrayByteSeq(org, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOutArrayByteSeq(org, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOutArrayByteSeq(org, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOutArrayByteSeq(org, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> copy;
                try
                {
                    __proxy->___end_opOutArrayByteSeq(copy, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(copy);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&)> _response;
        };
        return begin_opOutArrayByteSeq(org, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org)
    {
        return begin_opOutArrayByteSeq(org, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx)
    {
        return begin_opOutArrayByteSeq(org, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutArrayByteSeq(org, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutArrayByteSeq(org, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Test::Callback_TestIntf_opOutArrayByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutArrayByteSeq(org, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opOutArrayByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutArrayByteSeq(org, &__ctx, __del, __cookie);
    }

    void end_opOutArrayByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr&);

     void ___end_opOutArrayByteSeq(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& copy, const ::Ice::AsyncResultPtr&);
    
private:

    void opOutArrayByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opOutArrayByteSeq_async(const ::Test::AMI_TestIntf_opOutArrayByteSeqPtr&, const ::Test::ByteSeq&);
    bool opOutArrayByteSeq_async(const ::Test::AMI_TestIntf_opOutArrayByteSeqPtr&, const ::Test::ByteSeq&, const ::Ice::Context&);

    void opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy)
    {
        opOutRangeByteSeq(org, copy, 0);
    }
    void opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context& __ctx)
    {
        opOutRangeByteSeq(org, copy, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOutRangeByteSeq(org, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOutRangeByteSeq(org, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOutRangeByteSeq(org, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOutRangeByteSeq(org, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator> copy;
                ::Test::ByteSeq ___copy;
                try
                {
                    __proxy->end_opOutRangeByteSeq(___copy, __result);
                    copy.first = ___copy.begin();
                    copy.second = ___copy.end();
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(copy);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&)> _response;
        };
        return begin_opOutRangeByteSeq(org, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org)
    {
        return begin_opOutRangeByteSeq(org, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx)
    {
        return begin_opOutRangeByteSeq(org, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutRangeByteSeq(org, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutRangeByteSeq(org, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Test::Callback_TestIntf_opOutRangeByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutRangeByteSeq(org, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opOutRangeByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOutRangeByteSeq(org, &__ctx, __del, __cookie);
    }

    void end_opOutRangeByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr&);
    
private:

    void opOutRangeByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opOutRangeByteSeq_async(const ::Test::AMI_TestIntf_opOutRangeByteSeqPtr&, const ::Test::ByteSeq&);
    bool opOutRangeByteSeq_async(const ::Test::AMI_TestIntf_opOutRangeByteSeqPtr&, const ::Test::ByteSeq&, const ::Ice::Context&);

    ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict)
    {
        return opIntStringDict(idict, odict, 0);
    }
    ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context& __ctx)
    {
        return opIntStringDict(idict, odict, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::IceInternal::Function<void (const ::Test::IntStringDict&, const ::Test::IntStringDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntStringDict(idict, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntStringDict(idict, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::IntStringDict&, const ::Test::IntStringDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntStringDict(idict, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntStringDict(idict, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::IntStringDict&, const ::Test::IntStringDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::IntStringDict&, const ::Test::IntStringDict&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::IntStringDict odict;
                ::Test::IntStringDict __ret;
                try
                {
                    __ret = __proxy->end_opIntStringDict(odict, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, odict);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::IntStringDict&, const ::Test::IntStringDict&)> _response;
        };
        return begin_opIntStringDict(idict, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict)
    {
        return begin_opIntStringDict(idict, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& __ctx)
    {
        return begin_opIntStringDict(idict, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntStringDict(idict, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntStringDict(idict, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Test::Callback_TestIntf_opIntStringDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntStringDict(idict, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opIntStringDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntStringDict(idict, &__ctx, __del, __cookie);
    }

    ::Test::IntStringDict end_opIntStringDict(::Test::IntStringDict& odict, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict&, ::Test::IntStringDict&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opIntStringDict_async(const ::Test::AMI_TestIntf_opIntStringDictPtr&, const ::Test::IntStringDict&);
    bool opIntStringDict_async(const ::Test::AMI_TestIntf_opIntStringDictPtr&, const ::Test::IntStringDict&, const ::Ice::Context&);

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict)
    {
        return opVarDict(idict, odict, 0);
    }
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context& __ctx)
    {
        return opVarDict(idict, odict, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::IceInternal::Function<void (const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVarDict(idict, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVarDict(idict, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVarDict(idict, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVarDict(idict, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::CustomMap<std::string, ::Ice::Int> odict;
                ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret;
                try
                {
                    __ret = __proxy->end_opVarDict(odict, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, odict);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&)> _response;
        };
        return begin_opVarDict(idict, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict)
    {
        return begin_opVarDict(idict, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& __ctx)
    {
        return begin_opVarDict(idict, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarDict(idict, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarDict(idict, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Test::Callback_TestIntf_opVarDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarDict(idict, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opVarDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarDict(idict, &__ctx, __del, __cookie);
    }

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opVarDict_async(const ::Test::AMI_TestIntf_opVarDictPtr&, const ::Test::CustomMap<std::string, ::Ice::Int>&);
    bool opVarDict_async(const ::Test::AMI_TestIntf_opVarDictPtr&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context&);

    ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS)
    {
        return opShortBuffer(inS, outS, 0);
    }
    ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context& __ctx)
    {
        return opShortBuffer(inS, outS, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::IceInternal::Function<void (const ::Test::ShortBuffer&, const ::Test::ShortBuffer&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortBuffer(inS, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortBuffer(inS, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ShortBuffer&, const ::Test::ShortBuffer&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortBuffer(inS, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortBuffer(inS, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ShortBuffer&, const ::Test::ShortBuffer&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ShortBuffer&, const ::Test::ShortBuffer&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::ShortBuffer outS;
                ::Test::ShortBuffer __ret;
                try
                {
                    __ret = __proxy->end_opShortBuffer(outS, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outS);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ShortBuffer&, const ::Test::ShortBuffer&)> _response;
        };
        return begin_opShortBuffer(inS, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS)
    {
        return begin_opShortBuffer(inS, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& __ctx)
    {
        return begin_opShortBuffer(inS, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortBuffer(inS, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortBuffer(inS, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Test::Callback_TestIntf_opShortBufferPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortBuffer(inS, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opShortBufferPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortBuffer(inS, &__ctx, __del, __cookie);
    }

    ::Test::ShortBuffer end_opShortBuffer(::Test::ShortBuffer& outS, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer&, ::Test::ShortBuffer&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opShortBuffer_async(const ::Test::AMI_TestIntf_opShortBufferPtr&, const ::Test::ShortBuffer&);
    bool opShortBuffer_async(const ::Test::AMI_TestIntf_opShortBufferPtr&, const ::Test::ShortBuffer&, const ::Ice::Context&);

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS)
    {
        return opBoolBuffer(inS, outS, 0);
    }
    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context& __ctx)
    {
        return opBoolBuffer(inS, outS, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::IceInternal::Function<void (const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolBuffer(inS, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolBuffer(inS, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolBuffer(inS, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolBuffer(inS, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::CustomBuffer<bool> outS;
                ::Test::CustomBuffer<bool> __ret;
                try
                {
                    __ret = __proxy->end_opBoolBuffer(outS, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, outS);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&)> _response;
        };
        return begin_opBoolBuffer(inS, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS)
    {
        return begin_opBoolBuffer(inS, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& __ctx)
    {
        return begin_opBoolBuffer(inS, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolBuffer(inS, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolBuffer(inS, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Test::Callback_TestIntf_opBoolBufferPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolBuffer(inS, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBoolBufferPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolBuffer(inS, &__ctx, __del, __cookie);
    }

    ::Test::CustomBuffer<bool> end_opBoolBuffer(::Test::CustomBuffer<bool>& outS, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>&, ::Test::CustomBuffer<bool>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBoolBuffer_async(const ::Test::AMI_TestIntf_opBoolBufferPtr&, const ::Test::CustomBuffer<bool>&);
    bool opBoolBuffer_async(const ::Test::AMI_TestIntf_opBoolBufferPtr&, const ::Test::CustomBuffer<bool>&, const ::Ice::Context&);

    ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct& s)
    {
        return opBufferStruct(s, 0);
    }
    ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& __ctx)
    {
        return opBufferStruct(s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBufferStruct(const ::Test::BufferStruct& s, const ::IceInternal::Function<void (const ::Test::BufferStruct&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBufferStruct(s, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBufferStruct(const ::Test::BufferStruct& s, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBufferStruct(s, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BufferStruct&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBufferStruct(s, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBufferStruct(s, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BufferStruct&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BufferStruct&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BufferStruct __ret;
                try
                {
                    __ret = __proxy->end_opBufferStruct(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BufferStruct&)> _response;
        };
        return begin_opBufferStruct(s, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s)
    {
        return begin_opBufferStruct(s, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& __ctx)
    {
        return begin_opBufferStruct(s, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBufferStruct(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBufferStruct(s, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Test::Callback_TestIntf_opBufferStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBufferStruct(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_opBufferStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBufferStruct(s, &__ctx, __del, __cookie);
    }

    ::Test::BufferStruct end_opBufferStruct(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool opBufferStruct_async(const ::Test::AMI_TestIntf_opBufferStructPtr&, const ::Test::BufferStruct&);
    bool opBufferStruct_async(const ::Test::AMI_TestIntf_opBufferStructPtr&, const ::Test::BufferStruct&, const ::Ice::Context&);

    void shutdown()
    {
        shutdown(0);
    }
    void shutdown(const ::Ice::Context& __ctx)
    {
        shutdown(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_shutdown()
    {
        return begin_shutdown(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx)
    {
        return begin_shutdown(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);
    
private:

    void shutdown(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool shutdown_async(const ::Test::AMI_TestIntf_shutdownPtr&);
    bool shutdown_async(const ::Test::AMI_TestIntf_shutdownPtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<TestIntf> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_secure(bool __secure) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_twoway() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_oneway() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_batchOneway() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_datagram() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_batchDatagram() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_compress(bool __compress) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_timeout(int __timeout) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Test
{

class C : virtual public ::IceDelegate::Ice::Object
{
public:
};

class DictClass : virtual public ::IceDelegate::Ice::Object
{
public:
};

class TestIntf : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, ::Test::DoubleSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolSeq opBoolRangeType(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque<bool> opBoolSeq(const std::deque<bool>&, std::deque<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolList opBoolList(const ::Test::BoolList&, ::Test::BoolList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>&, std::deque< ::Ice::Byte>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ByteList opByteList(const ::Test::ByteList&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual MyByteSeq opMyByteSeq(const MyByteSeq&, MyByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque<std::string> opStringSeq(const std::deque<std::string>&, std::deque<std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::StringList opStringList(const ::Test::StringList&, ::Test::StringList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>&, std::deque< ::Test::Fixed>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::FixedList opFixedList(const ::Test::FixedList&, ::Test::FixedList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>&, std::deque< ::Test::Variable>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::VariableList opVariableList(const ::Test::VariableList&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, std::deque< ::Test::StringStringDict>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList&, ::Test::StringStringDictList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>&, std::deque< ::Test::E>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::EList opEList(const ::Test::EList&, ::Test::EList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque< ::Test::CPrx> opCPrxSeq(const std::deque< ::Test::CPrx>&, std::deque< ::Test::CPrx>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::CPrxList opCPrxList(const ::Test::CPrxList&, ::Test::CPrxList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>&, std::deque< ::Test::CPtr>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::CList opCList(const ::Test::CList&, ::Test::CList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, ::Test::ClassStructPtr&, ::Test::ClassStructSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void opOutArrayByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void opOutRangeByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict&, ::Test::IntStringDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer&, ::Test::ShortBuffer&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>&, ::Test::CustomBuffer<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

namespace IceDelegateM
{

namespace Test
{

class C : virtual public ::IceDelegate::Test::C,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class DictClass : virtual public ::IceDelegate::Test::DictClass,
                  virtual public ::IceDelegateM::Ice::Object
{
public:
};

class TestIntf : virtual public ::IceDelegate::Test::TestIntf,
                 virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, ::Test::DoubleSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSeq opBoolRangeType(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque<bool> opBoolSeq(const std::deque<bool>&, std::deque<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolList opBoolList(const ::Test::BoolList&, ::Test::BoolList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>&, std::deque< ::Ice::Byte>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteList(const ::Test::ByteList&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual MyByteSeq opMyByteSeq(const MyByteSeq&, MyByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque<std::string> opStringSeq(const std::deque<std::string>&, std::deque<std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringList opStringList(const ::Test::StringList&, ::Test::StringList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>&, std::deque< ::Test::Fixed>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::FixedList opFixedList(const ::Test::FixedList&, ::Test::FixedList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>&, std::deque< ::Test::Variable>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableList(const ::Test::VariableList&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, std::deque< ::Test::StringStringDict>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList&, ::Test::StringStringDictList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>&, std::deque< ::Test::E>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::EList opEList(const ::Test::EList&, ::Test::EList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::CPrx> opCPrxSeq(const std::deque< ::Test::CPrx>&, std::deque< ::Test::CPrx>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CPrxList opCPrxList(const ::Test::CPrxList&, ::Test::CPrxList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>&, std::deque< ::Test::CPtr>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CList opCList(const ::Test::CList&, ::Test::CList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, ::Test::ClassStructPtr&, ::Test::ClassStructSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opOutArrayByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opOutRangeByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict&, ::Test::IntStringDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer&, ::Test::ShortBuffer&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>&, ::Test::CustomBuffer<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceDelegateD
{

namespace Test
{

class C : virtual public ::IceDelegate::Test::C,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class DictClass : virtual public ::IceDelegate::Test::DictClass,
                  virtual public ::IceDelegateD::Ice::Object
{
public:
};

class TestIntf : virtual public ::IceDelegate::Test::TestIntf,
                 virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, ::Test::DoubleSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolSeq opBoolRangeType(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque<bool> opBoolSeq(const std::deque<bool>&, std::deque<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolList opBoolList(const ::Test::BoolList&, ::Test::BoolList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, ::Test::BoolDequeList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>&, std::deque< ::Ice::Byte>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ByteList opByteList(const ::Test::ByteList&, ::Test::ByteList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual MyByteSeq opMyByteSeq(const MyByteSeq&, MyByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque<std::string> opStringSeq(const std::deque<std::string>&, std::deque<std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringList opStringList(const ::Test::StringList&, ::Test::StringList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>&, std::deque< ::Test::Fixed>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::FixedList opFixedList(const ::Test::FixedList&, ::Test::FixedList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>&, std::deque< ::Test::Variable>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::VariableList opVariableList(const ::Test::VariableList&, ::Test::VariableList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, std::deque< ::Test::StringStringDict>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList&, ::Test::StringStringDictList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>&, std::deque< ::Test::E>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::EList opEList(const ::Test::EList&, ::Test::EList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::CPrx> opCPrxSeq(const std::deque< ::Test::CPrx>&, std::deque< ::Test::CPrx>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CPrxList opCPrxList(const ::Test::CPrxList&, ::Test::CPrxList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>&, std::deque< ::Test::CPtr>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CList opCList(const ::Test::CList&, ::Test::CList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, ::Test::ClassStructPtr&, ::Test::ClassStructSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opOutArrayByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void opOutRangeByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict&, ::Test::IntStringDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer&, ::Test::ShortBuffer&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>&, ::Test::CustomBuffer<bool>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace Test
{

class C : virtual public ::Ice::Object
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~C() {}

    friend class C__staticInit;
};

class C__staticInit
{
public:

    ::Test::C _init;
};

static C__staticInit _C_init;

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class DictClass : virtual public ::Ice::Object
{
public:

    typedef DictClassPrx ProxyType;
    typedef DictClassPtr PointerType;

    DictClass()
    {
    }

    explicit DictClass(const ::Test::IntStringDict& __ice_isdict) :
        isdict(__ice_isdict)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::IntStringDict isdict;

protected:

    virtual ~DictClass() {}
};

inline bool operator==(const DictClass& l, const DictClass& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const DictClass& l, const DictClass& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class TestIntf : virtual public ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;
    typedef TestIntfPtr PointerType;

    TestIntf()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, ::Test::DoubleSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opDoubleArray(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolArray(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, ::Test::ByteList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteArray(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, ::Test::VariableList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVariableArray(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, ::Test::BoolSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolRange(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteRange(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, ::Test::VariableList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVariableRange(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolSeq opBoolRangeType(const ::std::pair<const bool*, const bool*>&, ::Test::BoolSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolRangeType(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, ::Test::ByteList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteRangeType(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, ::Test::VariableList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVariableRangeType(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque<bool> opBoolSeq(const std::deque<bool>&, std::deque<bool>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolList opBoolList(const ::Test::BoolList&, ::Test::BoolList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList&, ::Test::BoolDequeList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolDequeList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, ::Test::BoolDequeList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolDequeListArray(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, ::Test::BoolDequeList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolDequeListRange(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>&, std::deque< ::Ice::Byte>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ByteList opByteList(const ::Test::ByteList&, ::Test::ByteList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual MyByteSeq opMyByteSeq(const MyByteSeq&, MyByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opMyByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque<std::string> opStringSeq(const std::deque<std::string>&, std::deque<std::string>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::StringList opStringList(const ::Test::StringList&, ::Test::StringList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>&, std::deque< ::Test::Fixed>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFixedSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::FixedList opFixedList(const ::Test::FixedList&, ::Test::FixedList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFixedList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>&, std::deque< ::Test::Variable>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVariableSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::VariableList opVariableList(const ::Test::VariableList&, ::Test::VariableList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVariableList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, std::deque< ::Test::StringStringDict>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringStringDictSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList&, ::Test::StringStringDictList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringStringDictList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>&, std::deque< ::Test::E>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opESeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::EList opEList(const ::Test::EList&, ::Test::EList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opEList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque< ::Test::CPrx> opCPrxSeq(const std::deque< ::Test::CPrx>&, std::deque< ::Test::CPrx>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opCPrxSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::CPrxList opCPrxList(const ::Test::CPrxList&, ::Test::CPrxList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opCPrxList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>&, std::deque< ::Test::CPtr>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::CList opCList(const ::Test::CList&, ::Test::CList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opCList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, ::Test::ClassStructPtr&, ::Test::ClassStructSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opClassStruct(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opOutArrayByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opOutArrayByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opOutRangeByteSeq(const ::Test::ByteSeq&, ::Test::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opOutRangeByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict&, ::Test::IntStringDict&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVarDict(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer&, ::Test::ShortBuffer&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opShortBuffer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>&, ::Test::CustomBuffer<bool>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolBuffer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBufferStruct(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void shutdown(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const TestIntf& l, const TestIntf& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const TestIntf& l, const TestIntf& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Test
{

template<class T>
class CallbackNC_TestIntf_opDoubleArray : public Callback_TestIntf_opDoubleArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&);

    CallbackNC_TestIntf_opDoubleArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> outSeq;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ___outSeq;
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> __ret;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > _____ret;
        try
        {
            __proxy->___end_opDoubleArray(___outSeq, _____ret, __result);
            outSeq = ___outSeq.second;
            __ret = _____ret.second;
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleArray<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opDoubleArray : public Callback_TestIntf_opDoubleArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const CT&);

    Callback_TestIntf_opDoubleArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> outSeq;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ___outSeq;
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> __ret;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > _____ret;
        try
        {
            __proxy->___end_opDoubleArray(___outSeq, _____ret, __result);
            outSeq = ___outSeq.second;
            __ret = _____ret.second;
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolArray : public Callback_TestIntf_opBoolArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&);

    CallbackNC_TestIntf_opBoolArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const bool*, const bool*> outSeq;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___outSeq;
        ::std::pair<const bool*, const bool*> __ret;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > _____ret;
        try
        {
            __proxy->___end_opBoolArray(___outSeq, _____ret, __result);
            outSeq = ___outSeq.second;
            __ret = _____ret.second;
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(T* instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolArray<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolArray : public Callback_TestIntf_opBoolArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&);

    Callback_TestIntf_opBoolArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const bool*, const bool*> outSeq;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___outSeq;
        ::std::pair<const bool*, const bool*> __ret;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > _____ret;
        try
        {
            __proxy->___end_opBoolArray(___outSeq, _____ret, __result);
            outSeq = ___outSeq.second;
            __ret = _____ret.second;
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(T* instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opByteArray : public Callback_TestIntf_opByteArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);

    CallbackNC_TestIntf_opByteArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> outSeq;
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> __ret;
        try
        {
            __proxy->___end_opByteArray(outSeq, __ret, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteArray<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opByteArray : public Callback_TestIntf_opByteArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&);

    Callback_TestIntf_opByteArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> outSeq;
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> __ret;
        try
        {
            __proxy->___end_opByteArray(outSeq, __ret, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opVariableArray : public Callback_TestIntf_opVariableArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&);

    CallbackNC_TestIntf_opVariableArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Test::Variable*, const ::Test::Variable*> outSeq;
        ::std::vector< ::Test::Variable> ___outSeq;
        ::std::pair<const ::Test::Variable*, const ::Test::Variable*> __ret;
        ::std::vector< ::Test::Variable> _____ret;
        try
        {
            __proxy->___end_opVariableArray(___outSeq, _____ret, __result);
            if(!___outSeq.empty())
            {
                outSeq.first = &___outSeq[0];
                outSeq.second = outSeq.first + ___outSeq.size();
            }
            else
            {
                outSeq.first = outSeq.second = 0;
            }
            if(!_____ret.empty())
            {
                __ret.first = &_____ret[0];
                __ret.second = __ret.first + _____ret.size();
            }
            else
            {
                __ret.first = __ret.second = 0;
            }
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(T* instance, void (T::*cb)(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableArray<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opVariableArray : public Callback_TestIntf_opVariableArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const CT&);

    Callback_TestIntf_opVariableArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Test::Variable*, const ::Test::Variable*> outSeq;
        ::std::vector< ::Test::Variable> ___outSeq;
        ::std::pair<const ::Test::Variable*, const ::Test::Variable*> __ret;
        ::std::vector< ::Test::Variable> _____ret;
        try
        {
            __proxy->___end_opVariableArray(___outSeq, _____ret, __result);
            if(!___outSeq.empty())
            {
                outSeq.first = &___outSeq[0];
                outSeq.second = outSeq.first + ___outSeq.size();
            }
            else
            {
                outSeq.first = outSeq.second = 0;
            }
            if(!_____ret.empty())
            {
                __ret.first = &_____ret[0];
                __ret.second = __ret.first + _____ret.size();
            }
            else
            {
                __ret.first = __ret.second = 0;
            }
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(T* instance, void (T::*cb)(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolRange : public Callback_TestIntf_opBoolRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&);

    CallbackNC_TestIntf_opBoolRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> outSeq;
        ::Test::BoolSeq ___outSeq;
        ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> __ret;
        ::Test::BoolSeq _____ret;
        try
        {
            _____ret = __proxy->end_opBoolRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRange<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRange<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolRange : public Callback_TestIntf_opBoolRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const CT&);

    Callback_TestIntf_opBoolRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> outSeq;
        ::Test::BoolSeq ___outSeq;
        ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator> __ret;
        ::Test::BoolSeq _____ret;
        try
        {
            _____ret = __proxy->end_opBoolRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opByteRange : public Callback_TestIntf_opByteRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&);

    CallbackNC_TestIntf_opByteRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> outSeq;
        ::Test::ByteList ___outSeq;
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> __ret;
        ::Test::ByteList _____ret;
        try
        {
            _____ret = __proxy->end_opByteRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRange<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRange<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opByteRange : public Callback_TestIntf_opByteRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&);

    Callback_TestIntf_opByteRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> outSeq;
        ::Test::ByteList ___outSeq;
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> __ret;
        ::Test::ByteList _____ret;
        try
        {
            _____ret = __proxy->end_opByteRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opVariableRange : public Callback_TestIntf_opVariableRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&);

    CallbackNC_TestIntf_opVariableRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> outSeq;
        ::Test::VariableList ___outSeq;
        ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> __ret;
        ::Test::VariableList _____ret;
        try
        {
            _____ret = __proxy->end_opVariableRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRange<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRange<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opVariableRange : public Callback_TestIntf_opVariableRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const CT&);

    Callback_TestIntf_opVariableRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> outSeq;
        ::Test::VariableList ___outSeq;
        ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator> __ret;
        ::Test::VariableList _____ret;
        try
        {
            _____ret = __proxy->end_opVariableRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolRangeType : public Callback_TestIntf_opBoolRangeType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&);

    CallbackNC_TestIntf_opBoolRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const bool*, const bool*> outSeq;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___outSeq;
        ::std::pair<const bool*, const bool*> __ret;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > _____ret;
        try
        {
            __proxy->___end_opBoolRangeType(___outSeq, _____ret, __result);
            outSeq = ___outSeq.second;
            __ret = _____ret.second;
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolRangeTypePtr
newCallback_TestIntf_opBoolRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRangeType<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolRangeTypePtr
newCallback_TestIntf_opBoolRangeType(T* instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRangeType<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolRangeType : public Callback_TestIntf_opBoolRangeType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&);

    Callback_TestIntf_opBoolRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const bool*, const bool*> outSeq;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ___outSeq;
        ::std::pair<const bool*, const bool*> __ret;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > _____ret;
        try
        {
            __proxy->___end_opBoolRangeType(___outSeq, _____ret, __result);
            outSeq = ___outSeq.second;
            __ret = _____ret.second;
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolRangeTypePtr
newCallback_TestIntf_opBoolRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRangeType<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolRangeTypePtr
newCallback_TestIntf_opBoolRangeType(T* instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRangeType<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opByteRangeType : public Callback_TestIntf_opByteRangeType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&);

    CallbackNC_TestIntf_opByteRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> outSeq;
        ::Test::ByteList ___outSeq;
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> __ret;
        ::Test::ByteList _____ret;
        try
        {
            _____ret = __proxy->end_opByteRangeType(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRangeType<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRangeType<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opByteRangeType : public Callback_TestIntf_opByteRangeType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&);

    Callback_TestIntf_opByteRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> outSeq;
        ::Test::ByteList ___outSeq;
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> __ret;
        ::Test::ByteList _____ret;
        try
        {
            _____ret = __proxy->end_opByteRangeType(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRangeType<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRangeType<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opVariableRangeType : public Callback_TestIntf_opVariableRangeType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&);

    CallbackNC_TestIntf_opVariableRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> outSeq;
        std::deque< ::Test::Variable> ___outSeq;
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> __ret;
        std::deque< ::Test::Variable> _____ret;
        try
        {
            __proxy->___end_opVariableRangeType(___outSeq, _____ret, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRangeType<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(T* instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRangeType<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opVariableRangeType : public Callback_TestIntf_opVariableRangeType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const CT&);

    Callback_TestIntf_opVariableRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> outSeq;
        std::deque< ::Test::Variable> ___outSeq;
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> __ret;
        std::deque< ::Test::Variable> _____ret;
        try
        {
            __proxy->___end_opVariableRangeType(___outSeq, _____ret, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRangeType<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(T* instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRangeType<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque<bool>&, const std::deque<bool>&);

    CallbackNC_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque<bool> outSeq;
        std::deque<bool> __ret;
        try
        {
            __ret = __proxy->end_opBoolSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque<bool>&, const std::deque<bool>&, const CT&);

    Callback_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque<bool> outSeq;
        std::deque<bool> __ret;
        try
        {
            __ret = __proxy->end_opBoolSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolList : public Callback_TestIntf_opBoolList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BoolList&, const ::Test::BoolList&);

    CallbackNC_TestIntf_opBoolList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolList outSeq;
        ::Test::BoolList __ret;
        try
        {
            __ret = __proxy->end_opBoolList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolList&, const ::Test::BoolList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(T* instance, void (T::*cb)(const ::Test::BoolList&, const ::Test::BoolList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolList : public Callback_TestIntf_opBoolList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BoolList&, const ::Test::BoolList&, const CT&);

    Callback_TestIntf_opBoolList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolList outSeq;
        ::Test::BoolList __ret;
        try
        {
            __ret = __proxy->end_opBoolList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolList&, const ::Test::BoolList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(T* instance, void (T::*cb)(const ::Test::BoolList&, const ::Test::BoolList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolDequeList : public Callback_TestIntf_opBoolDequeList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BoolDequeList&, const ::Test::BoolDequeList&);

    CallbackNC_TestIntf_opBoolDequeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolDequeList outSeq;
        ::Test::BoolDequeList __ret;
        try
        {
            __ret = __proxy->end_opBoolDequeList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolDequeList&, const ::Test::BoolDequeList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(T* instance, void (T::*cb)(const ::Test::BoolDequeList&, const ::Test::BoolDequeList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolDequeList : public Callback_TestIntf_opBoolDequeList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BoolDequeList&, const ::Test::BoolDequeList&, const CT&);

    Callback_TestIntf_opBoolDequeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BoolDequeList outSeq;
        ::Test::BoolDequeList __ret;
        try
        {
            __ret = __proxy->end_opBoolDequeList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BoolDequeList&, const ::Test::BoolDequeList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(T* instance, void (T::*cb)(const ::Test::BoolDequeList&, const ::Test::BoolDequeList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolDequeListArray : public Callback_TestIntf_opBoolDequeListArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&);

    CallbackNC_TestIntf_opBoolDequeListArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> outSeq;
        ::std::vector<std::deque<bool> > ___outSeq;
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> __ret;
        ::std::vector<std::deque<bool> > _____ret;
        try
        {
            __proxy->___end_opBoolDequeListArray(___outSeq, _____ret, __result);
            if(!___outSeq.empty())
            {
                outSeq.first = &___outSeq[0];
                outSeq.second = outSeq.first + ___outSeq.size();
            }
            else
            {
                outSeq.first = outSeq.second = 0;
            }
            if(!_____ret.empty())
            {
                __ret.first = &_____ret[0];
                __ret.second = __ret.first + _____ret.size();
            }
            else
            {
                __ret.first = __ret.second = 0;
            }
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(T* instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListArray<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolDequeListArray : public Callback_TestIntf_opBoolDequeListArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const CT&);

    Callback_TestIntf_opBoolDequeListArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> outSeq;
        ::std::vector<std::deque<bool> > ___outSeq;
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> __ret;
        ::std::vector<std::deque<bool> > _____ret;
        try
        {
            __proxy->___end_opBoolDequeListArray(___outSeq, _____ret, __result);
            if(!___outSeq.empty())
            {
                outSeq.first = &___outSeq[0];
                outSeq.second = outSeq.first + ___outSeq.size();
            }
            else
            {
                outSeq.first = outSeq.second = 0;
            }
            if(!_____ret.empty())
            {
                __ret.first = &_____ret[0];
                __ret.second = __ret.first + _____ret.size();
            }
            else
            {
                __ret.first = __ret.second = 0;
            }
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(T* instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolDequeListRange : public Callback_TestIntf_opBoolDequeListRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&);

    CallbackNC_TestIntf_opBoolDequeListRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator> outSeq;
        ::Test::BoolDequeList ___outSeq;
        ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator> __ret;
        ::Test::BoolDequeList _____ret;
        try
        {
            _____ret = __proxy->end_opBoolDequeListRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListRange<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListRange<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolDequeListRange : public Callback_TestIntf_opBoolDequeListRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const CT&);

    Callback_TestIntf_opBoolDequeListRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator> outSeq;
        ::Test::BoolDequeList ___outSeq;
        ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator> __ret;
        ::Test::BoolDequeList _____ret;
        try
        {
            _____ret = __proxy->end_opBoolDequeListRange(___outSeq, __result);
            outSeq.first = ___outSeq.begin();
            outSeq.second = ___outSeq.end();
            __ret.first = _____ret.begin();
            __ret.second = _____ret.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(T* instance, void (T::*cb)(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&);

    CallbackNC_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Ice::Byte> outSeq;
        std::deque< ::Ice::Byte> __ret;
        try
        {
            __ret = __proxy->end_opByteSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&);

    Callback_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Ice::Byte> outSeq;
        std::deque< ::Ice::Byte> __ret;
        try
        {
            __ret = __proxy->end_opByteSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opByteList : public Callback_TestIntf_opByteList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ByteList&, const ::Test::ByteList&);

    CallbackNC_TestIntf_opByteList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteList outSeq;
        ::Test::ByteList __ret;
        try
        {
            __ret = __proxy->end_opByteList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteList&, const ::Test::ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(T* instance, void (T::*cb)(const ::Test::ByteList&, const ::Test::ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opByteList : public Callback_TestIntf_opByteList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ByteList&, const ::Test::ByteList&, const CT&);

    Callback_TestIntf_opByteList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ByteList outSeq;
        ::Test::ByteList __ret;
        try
        {
            __ret = __proxy->end_opByteList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ByteList&, const ::Test::ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(T* instance, void (T::*cb)(const ::Test::ByteList&, const ::Test::ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opMyByteSeq : public Callback_TestIntf_opMyByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyByteSeq&, const MyByteSeq&);

    CallbackNC_TestIntf_opMyByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        MyByteSeq outSeq;
        MyByteSeq __ret;
        try
        {
            __ret = __proxy->end_opMyByteSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opMyByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(T* instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opMyByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opMyByteSeq : public Callback_TestIntf_opMyByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyByteSeq&, const MyByteSeq&, const CT&);

    Callback_TestIntf_opMyByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        MyByteSeq outSeq;
        MyByteSeq __ret;
        try
        {
            __ret = __proxy->end_opMyByteSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opMyByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(T* instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opMyByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque<std::string>&, const std::deque<std::string>&);

    CallbackNC_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque<std::string> outSeq;
        std::deque<std::string> __ret;
        try
        {
            __ret = __proxy->end_opStringSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&);

    Callback_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque<std::string> outSeq;
        std::deque<std::string> __ret;
        try
        {
            __ret = __proxy->end_opStringSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opStringList : public Callback_TestIntf_opStringList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::StringList&, const ::Test::StringList&);

    CallbackNC_TestIntf_opStringList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::StringList outSeq;
        ::Test::StringList __ret;
        try
        {
            __ret = __proxy->end_opStringList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringList&, const ::Test::StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(T* instance, void (T::*cb)(const ::Test::StringList&, const ::Test::StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opStringList : public Callback_TestIntf_opStringList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::StringList&, const ::Test::StringList&, const CT&);

    Callback_TestIntf_opStringList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::StringList outSeq;
        ::Test::StringList __ret;
        try
        {
            __ret = __proxy->end_opStringList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringList&, const ::Test::StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(T* instance, void (T::*cb)(const ::Test::StringList&, const ::Test::StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opFixedSeq : public Callback_TestIntf_opFixedSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&);

    CallbackNC_TestIntf_opFixedSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::Fixed> outSeq;
        std::deque< ::Test::Fixed> __ret;
        try
        {
            __ret = __proxy->end_opFixedSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opFixedSeq : public Callback_TestIntf_opFixedSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&);

    Callback_TestIntf_opFixedSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::Fixed> outSeq;
        std::deque< ::Test::Fixed> __ret;
        try
        {
            __ret = __proxy->end_opFixedSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opFixedList : public Callback_TestIntf_opFixedList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::FixedList&, const ::Test::FixedList&);

    CallbackNC_TestIntf_opFixedList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::FixedList outSeq;
        ::Test::FixedList __ret;
        try
        {
            __ret = __proxy->end_opFixedList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::FixedList&, const ::Test::FixedList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(T* instance, void (T::*cb)(const ::Test::FixedList&, const ::Test::FixedList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opFixedList : public Callback_TestIntf_opFixedList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::FixedList&, const ::Test::FixedList&, const CT&);

    Callback_TestIntf_opFixedList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::FixedList outSeq;
        ::Test::FixedList __ret;
        try
        {
            __ret = __proxy->end_opFixedList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::FixedList&, const ::Test::FixedList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(T* instance, void (T::*cb)(const ::Test::FixedList&, const ::Test::FixedList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opVariableSeq : public Callback_TestIntf_opVariableSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&);

    CallbackNC_TestIntf_opVariableSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::Variable> outSeq;
        std::deque< ::Test::Variable> __ret;
        try
        {
            __ret = __proxy->end_opVariableSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opVariableSeq : public Callback_TestIntf_opVariableSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&);

    Callback_TestIntf_opVariableSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::Variable> outSeq;
        std::deque< ::Test::Variable> __ret;
        try
        {
            __ret = __proxy->end_opVariableSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opVariableList : public Callback_TestIntf_opVariableList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::VariableList&, const ::Test::VariableList&);

    CallbackNC_TestIntf_opVariableList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::VariableList outSeq;
        ::Test::VariableList __ret;
        try
        {
            __ret = __proxy->end_opVariableList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::VariableList&, const ::Test::VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(T* instance, void (T::*cb)(const ::Test::VariableList&, const ::Test::VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opVariableList : public Callback_TestIntf_opVariableList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::VariableList&, const ::Test::VariableList&, const CT&);

    Callback_TestIntf_opVariableList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::VariableList outSeq;
        ::Test::VariableList __ret;
        try
        {
            __ret = __proxy->end_opVariableList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::VariableList&, const ::Test::VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(T* instance, void (T::*cb)(const ::Test::VariableList&, const ::Test::VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opStringStringDictSeq : public Callback_TestIntf_opStringStringDictSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&);

    CallbackNC_TestIntf_opStringStringDictSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::StringStringDict> outSeq;
        std::deque< ::Test::StringStringDict> __ret;
        try
        {
            __ret = __proxy->end_opStringStringDictSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(T* instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opStringStringDictSeq : public Callback_TestIntf_opStringStringDictSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&);

    Callback_TestIntf_opStringStringDictSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::StringStringDict> outSeq;
        std::deque< ::Test::StringStringDict> __ret;
        try
        {
            __ret = __proxy->end_opStringStringDictSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(T* instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opStringStringDictList : public Callback_TestIntf_opStringStringDictList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&);

    CallbackNC_TestIntf_opStringStringDictList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::StringStringDictList outSeq;
        ::Test::StringStringDictList __ret;
        try
        {
            __ret = __proxy->end_opStringStringDictList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(T* instance, void (T::*cb)(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opStringStringDictList : public Callback_TestIntf_opStringStringDictList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&, const CT&);

    Callback_TestIntf_opStringStringDictList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::StringStringDictList outSeq;
        ::Test::StringStringDictList __ret;
        try
        {
            __ret = __proxy->end_opStringStringDictList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(T* instance, void (T::*cb)(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&);

    CallbackNC_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::E> outSeq;
        std::deque< ::Test::E> __ret;
        try
        {
            __ret = __proxy->end_opESeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&);

    Callback_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::E> outSeq;
        std::deque< ::Test::E> __ret;
        try
        {
            __ret = __proxy->end_opESeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opEList : public Callback_TestIntf_opEList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::EList&, const ::Test::EList&);

    CallbackNC_TestIntf_opEList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::EList outSeq;
        ::Test::EList __ret;
        try
        {
            __ret = __proxy->end_opEList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::EList&, const ::Test::EList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opEList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(T* instance, void (T::*cb)(const ::Test::EList&, const ::Test::EList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opEList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opEList : public Callback_TestIntf_opEList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::EList&, const ::Test::EList&, const CT&);

    Callback_TestIntf_opEList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::EList outSeq;
        ::Test::EList __ret;
        try
        {
            __ret = __proxy->end_opEList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::EList&, const ::Test::EList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opEList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(T* instance, void (T::*cb)(const ::Test::EList&, const ::Test::EList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opEList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opCPrxSeq : public Callback_TestIntf_opCPrxSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&);

    CallbackNC_TestIntf_opCPrxSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::CPrx> outSeq;
        std::deque< ::Test::CPrx> __ret;
        try
        {
            __ret = __proxy->end_opCPrxSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opCPrxSeqPtr
newCallback_TestIntf_opCPrxSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCPrxSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opCPrxSeqPtr
newCallback_TestIntf_opCPrxSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCPrxSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opCPrxSeq : public Callback_TestIntf_opCPrxSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&, const CT&);

    Callback_TestIntf_opCPrxSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::CPrx> outSeq;
        std::deque< ::Test::CPrx> __ret;
        try
        {
            __ret = __proxy->end_opCPrxSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opCPrxSeqPtr
newCallback_TestIntf_opCPrxSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCPrxSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opCPrxSeqPtr
newCallback_TestIntf_opCPrxSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPrx>&, const std::deque< ::Test::CPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCPrxSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opCPrxList : public Callback_TestIntf_opCPrxList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CPrxList&, const ::Test::CPrxList&);

    CallbackNC_TestIntf_opCPrxList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CPrxList outSeq;
        ::Test::CPrxList __ret;
        try
        {
            __ret = __proxy->end_opCPrxList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opCPrxListPtr
newCallback_TestIntf_opCPrxList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CPrxList&, const ::Test::CPrxList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCPrxList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opCPrxListPtr
newCallback_TestIntf_opCPrxList(T* instance, void (T::*cb)(const ::Test::CPrxList&, const ::Test::CPrxList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCPrxList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opCPrxList : public Callback_TestIntf_opCPrxList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CPrxList&, const ::Test::CPrxList&, const CT&);

    Callback_TestIntf_opCPrxList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CPrxList outSeq;
        ::Test::CPrxList __ret;
        try
        {
            __ret = __proxy->end_opCPrxList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opCPrxListPtr
newCallback_TestIntf_opCPrxList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CPrxList&, const ::Test::CPrxList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCPrxList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opCPrxListPtr
newCallback_TestIntf_opCPrxList(T* instance, void (T::*cb)(const ::Test::CPrxList&, const ::Test::CPrxList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCPrxList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&);

    CallbackNC_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::CPtr> outSeq;
        std::deque< ::Test::CPtr> __ret;
        try
        {
            __ret = __proxy->end_opCSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&);

    Callback_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        std::deque< ::Test::CPtr> outSeq;
        std::deque< ::Test::CPtr> __ret;
        try
        {
            __ret = __proxy->end_opCSeq(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CList&, const ::Test::CList&);

    CallbackNC_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CList outSeq;
        ::Test::CList __ret;
        try
        {
            __ret = __proxy->end_opCList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CList&, const ::Test::CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const ::Test::CList&, const ::Test::CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CList&, const ::Test::CList&, const CT&);

    Callback_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CList outSeq;
        ::Test::CList __ret;
        try
        {
            __ret = __proxy->end_opCList(outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CList&, const ::Test::CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const ::Test::CList&, const ::Test::CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opClassStruct : public Callback_TestIntf_opClassStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&);

    CallbackNC_TestIntf_opClassStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ClassStructPtr outS;
        ::Test::ClassStructSeq outSeq;
        ::Test::ClassStructPtr __ret;
        try
        {
            __ret = __proxy->end_opClassStruct(outS, outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outS, outSeq);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opClassStruct<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(T* instance, void (T::*cb)(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opClassStruct<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opClassStruct : public Callback_TestIntf_opClassStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, const CT&);

    Callback_TestIntf_opClassStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ClassStructPtr outS;
        ::Test::ClassStructSeq outSeq;
        ::Test::ClassStructPtr __ret;
        try
        {
            __ret = __proxy->end_opClassStruct(outS, outSeq, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outS, outSeq, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opClassStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(T* instance, void (T::*cb)(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opClassStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opOutArrayByteSeq : public Callback_TestIntf_opOutArrayByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);

    CallbackNC_TestIntf_opOutArrayByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> copy;
        try
        {
            __proxy->___end_opOutArrayByteSeq(copy, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(copy);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutArrayByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutArrayByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opOutArrayByteSeq : public Callback_TestIntf_opOutArrayByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&);

    Callback_TestIntf_opOutArrayByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> copy;
        try
        {
            __proxy->___end_opOutArrayByteSeq(copy, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(copy, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutArrayByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutArrayByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opOutRangeByteSeq : public Callback_TestIntf_opOutRangeByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&);

    CallbackNC_TestIntf_opOutRangeByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator> copy;
        ::Test::ByteSeq ___copy;
        try
        {
            __proxy->end_opOutRangeByteSeq(___copy, __result);
            copy.first = ___copy.begin();
            copy.second = ___copy.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(copy);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutRangeByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutRangeByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opOutRangeByteSeq : public Callback_TestIntf_opOutRangeByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&, const CT&);

    Callback_TestIntf_opOutRangeByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator> copy;
        ::Test::ByteSeq ___copy;
        try
        {
            __proxy->end_opOutRangeByteSeq(___copy, __result);
            copy.first = ___copy.begin();
            copy.second = ___copy.end();
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(copy, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutRangeByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutRangeByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opIntStringDict : public Callback_TestIntf_opIntStringDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::IntStringDict&, const ::Test::IntStringDict&);

    CallbackNC_TestIntf_opIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::IntStringDict odict;
        ::Test::IntStringDict __ret;
        try
        {
            __ret = __proxy->end_opIntStringDict(odict, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, odict);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::IntStringDict&, const ::Test::IntStringDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntStringDict<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(T* instance, void (T::*cb)(const ::Test::IntStringDict&, const ::Test::IntStringDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntStringDict<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opIntStringDict : public Callback_TestIntf_opIntStringDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::IntStringDict&, const ::Test::IntStringDict&, const CT&);

    Callback_TestIntf_opIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::IntStringDict odict;
        ::Test::IntStringDict __ret;
        try
        {
            __ret = __proxy->end_opIntStringDict(odict, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, odict, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::IntStringDict&, const ::Test::IntStringDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(T* instance, void (T::*cb)(const ::Test::IntStringDict&, const ::Test::IntStringDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opVarDict : public Callback_TestIntf_opVarDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&);

    CallbackNC_TestIntf_opVarDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CustomMap<std::string, ::Ice::Int> odict;
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret;
        try
        {
            __ret = __proxy->end_opVarDict(odict, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, odict);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVarDict<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(T* instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVarDict<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opVarDict : public Callback_TestIntf_opVarDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&);

    Callback_TestIntf_opVarDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CustomMap<std::string, ::Ice::Int> odict;
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> __ret;
        try
        {
            __ret = __proxy->end_opVarDict(odict, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, odict, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVarDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(T* instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVarDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opShortBuffer : public Callback_TestIntf_opShortBuffer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&);

    CallbackNC_TestIntf_opShortBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortBuffer outS;
        ::Test::ShortBuffer __ret;
        try
        {
            __ret = __proxy->end_opShortBuffer(outS, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outS);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBuffer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(T* instance, void (T::*cb)(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBuffer<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opShortBuffer : public Callback_TestIntf_opShortBuffer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&, const CT&);

    Callback_TestIntf_opShortBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ShortBuffer outS;
        ::Test::ShortBuffer __ret;
        try
        {
            __ret = __proxy->end_opShortBuffer(outS, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outS, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBuffer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(T* instance, void (T::*cb)(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBuffer<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBoolBuffer : public Callback_TestIntf_opBoolBuffer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&);

    CallbackNC_TestIntf_opBoolBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CustomBuffer<bool> outS;
        ::Test::CustomBuffer<bool> __ret;
        try
        {
            __ret = __proxy->end_opBoolBuffer(outS, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, outS);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolBuffer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(T* instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolBuffer<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBoolBuffer : public Callback_TestIntf_opBoolBuffer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&);

    Callback_TestIntf_opBoolBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::CustomBuffer<bool> outS;
        ::Test::CustomBuffer<bool> __ret;
        try
        {
            __ret = __proxy->end_opBoolBuffer(outS, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, outS, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolBuffer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(T* instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolBuffer<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_opBufferStruct : public Callback_TestIntf_opBufferStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BufferStruct&);

    CallbackNC_TestIntf_opBufferStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BufferStruct __ret;
        try
        {
            __ret = __proxy->end_opBufferStruct(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BufferStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBufferStruct<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(T* instance, void (T::*cb)(const ::Test::BufferStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBufferStruct<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_opBufferStruct : public Callback_TestIntf_opBufferStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BufferStruct&, const CT&);

    Callback_TestIntf_opBufferStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BufferStruct __ret;
        try
        {
            __ret = __proxy->end_opBufferStruct(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BufferStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBufferStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(T* instance, void (T::*cb)(const ::Test::BufferStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBufferStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif
