// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Types.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Types_h__
#define __Types_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class Interface1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Interface1*);

class Interface2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Interface2*);

class Interface3;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface3>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Interface3*);

class Interface4;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface4>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Interface4*);

class EmptyClass1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::EmptyClass1*);

class EmptyClass2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::EmptyClass2*);

class EmptyClass3;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass3>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::EmptyClass3*);

class EmptyClass4;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass4>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::EmptyClass4*);

class EmptyClass5;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass5>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::EmptyClass5*);

class SimpleClass1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SimpleClass1*);

class SimpleClass2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SimpleClass2*);

class SimpleClass3;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass3>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SimpleClass3*);

class SimpleClass4;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass4>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SimpleClass4*);

class SimpleClass5;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass5>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SimpleClass5*);

class SimpleClass6;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass6>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SimpleClass6*);

class SimpleClass7;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass7>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SimpleClass7*);

class BaseClass1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass1*);

class BaseClass2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass2*);

class BaseClass3;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass3>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass3*);

class BaseClass4;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass4>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass4*);

class BaseClass5;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass5>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass5*);

class BaseClass6;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass6>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass6*);

class BaseClass7;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass7>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass7*);

class BaseClass8;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass8>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass8*);

class BaseClass9;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass9>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass9*);

class BaseClass10;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass10>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass10*);

class BaseClass11;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass11>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::BaseClass11*);

class Compact1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Compact1*);

class Derived1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Derived1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Derived1*);

class Compact2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Compact2*);

class Optional0;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional0>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Optional0*);

class Optional1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Optional1*);

class Optional2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Optional2*);

class Optional3;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional3>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Optional3*);

class Optional4;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional4>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Optional4*);

class OptionalParameters0;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters0>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalParameters0*);

class OptionalParameters1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalParameters1*);

class OptionalParameters2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalParameters2*);

class OptionalParameters3;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters3>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalParameters3*);

class OptionalReturn0;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn0>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalReturn0*);

class OptionalReturn2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalReturn2*);

}

}

namespace Test
{

class Interface1;
bool operator==(const Interface1&, const Interface1&);
bool operator<(const Interface1&, const Interface1&);
::Ice::Object* upCast(::Test::Interface1*);
typedef ::IceInternal::Handle< ::Test::Interface1> Interface1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface1> Interface1Prx;
void __patch(Interface1Ptr&, const ::Ice::ObjectPtr&);

class Interface2;
bool operator==(const Interface2&, const Interface2&);
bool operator<(const Interface2&, const Interface2&);
::Ice::Object* upCast(::Test::Interface2*);
typedef ::IceInternal::Handle< ::Test::Interface2> Interface2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface2> Interface2Prx;
void __patch(Interface2Ptr&, const ::Ice::ObjectPtr&);

class Interface3;
bool operator==(const Interface3&, const Interface3&);
bool operator<(const Interface3&, const Interface3&);
::Ice::Object* upCast(::Test::Interface3*);
typedef ::IceInternal::Handle< ::Test::Interface3> Interface3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface3> Interface3Prx;
void __patch(Interface3Ptr&, const ::Ice::ObjectPtr&);

class Interface4;
bool operator==(const Interface4&, const Interface4&);
bool operator<(const Interface4&, const Interface4&);
::Ice::Object* upCast(::Test::Interface4*);
typedef ::IceInternal::Handle< ::Test::Interface4> Interface4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface4> Interface4Prx;
void __patch(Interface4Ptr&, const ::Ice::ObjectPtr&);

class EmptyClass1;
bool operator==(const EmptyClass1&, const EmptyClass1&);
bool operator<(const EmptyClass1&, const EmptyClass1&);
::Ice::Object* upCast(::Test::EmptyClass1*);
typedef ::IceInternal::Handle< ::Test::EmptyClass1> EmptyClass1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass1> EmptyClass1Prx;
void __patch(EmptyClass1Ptr&, const ::Ice::ObjectPtr&);

class EmptyClass2;
bool operator==(const EmptyClass2&, const EmptyClass2&);
bool operator<(const EmptyClass2&, const EmptyClass2&);
::Ice::Object* upCast(::Test::EmptyClass2*);
typedef ::IceInternal::Handle< ::Test::EmptyClass2> EmptyClass2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass2> EmptyClass2Prx;
void __patch(EmptyClass2Ptr&, const ::Ice::ObjectPtr&);

class EmptyClass3;
bool operator==(const EmptyClass3&, const EmptyClass3&);
bool operator<(const EmptyClass3&, const EmptyClass3&);
::Ice::Object* upCast(::Test::EmptyClass3*);
typedef ::IceInternal::Handle< ::Test::EmptyClass3> EmptyClass3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass3> EmptyClass3Prx;
void __patch(EmptyClass3Ptr&, const ::Ice::ObjectPtr&);

class EmptyClass4;
bool operator==(const EmptyClass4&, const EmptyClass4&);
bool operator<(const EmptyClass4&, const EmptyClass4&);
::Ice::Object* upCast(::Test::EmptyClass4*);
typedef ::IceInternal::Handle< ::Test::EmptyClass4> EmptyClass4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass4> EmptyClass4Prx;
void __patch(EmptyClass4Ptr&, const ::Ice::ObjectPtr&);

class EmptyClass5;
bool operator==(const EmptyClass5&, const EmptyClass5&);
bool operator<(const EmptyClass5&, const EmptyClass5&);
::Ice::Object* upCast(::Test::EmptyClass5*);
typedef ::IceInternal::Handle< ::Test::EmptyClass5> EmptyClass5Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass5> EmptyClass5Prx;
void __patch(EmptyClass5Ptr&, const ::Ice::ObjectPtr&);

class SimpleClass1;
bool operator==(const SimpleClass1&, const SimpleClass1&);
bool operator<(const SimpleClass1&, const SimpleClass1&);
::Ice::Object* upCast(::Test::SimpleClass1*);
typedef ::IceInternal::Handle< ::Test::SimpleClass1> SimpleClass1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass1> SimpleClass1Prx;
void __patch(SimpleClass1Ptr&, const ::Ice::ObjectPtr&);

class SimpleClass2;
bool operator==(const SimpleClass2&, const SimpleClass2&);
bool operator<(const SimpleClass2&, const SimpleClass2&);
::Ice::Object* upCast(::Test::SimpleClass2*);
typedef ::IceInternal::Handle< ::Test::SimpleClass2> SimpleClass2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass2> SimpleClass2Prx;
void __patch(SimpleClass2Ptr&, const ::Ice::ObjectPtr&);

class SimpleClass3;
bool operator==(const SimpleClass3&, const SimpleClass3&);
bool operator<(const SimpleClass3&, const SimpleClass3&);
::Ice::Object* upCast(::Test::SimpleClass3*);
typedef ::IceInternal::Handle< ::Test::SimpleClass3> SimpleClass3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass3> SimpleClass3Prx;
void __patch(SimpleClass3Ptr&, const ::Ice::ObjectPtr&);

class SimpleClass4;
bool operator==(const SimpleClass4&, const SimpleClass4&);
bool operator<(const SimpleClass4&, const SimpleClass4&);
::Ice::Object* upCast(::Test::SimpleClass4*);
typedef ::IceInternal::Handle< ::Test::SimpleClass4> SimpleClass4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass4> SimpleClass4Prx;
void __patch(SimpleClass4Ptr&, const ::Ice::ObjectPtr&);

class SimpleClass5;
bool operator==(const SimpleClass5&, const SimpleClass5&);
bool operator<(const SimpleClass5&, const SimpleClass5&);
::Ice::Object* upCast(::Test::SimpleClass5*);
typedef ::IceInternal::Handle< ::Test::SimpleClass5> SimpleClass5Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass5> SimpleClass5Prx;
void __patch(SimpleClass5Ptr&, const ::Ice::ObjectPtr&);

class SimpleClass6;
bool operator==(const SimpleClass6&, const SimpleClass6&);
bool operator<(const SimpleClass6&, const SimpleClass6&);
::Ice::Object* upCast(::Test::SimpleClass6*);
typedef ::IceInternal::Handle< ::Test::SimpleClass6> SimpleClass6Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass6> SimpleClass6Prx;
void __patch(SimpleClass6Ptr&, const ::Ice::ObjectPtr&);

class SimpleClass7;
bool operator==(const SimpleClass7&, const SimpleClass7&);
bool operator<(const SimpleClass7&, const SimpleClass7&);
::Ice::Object* upCast(::Test::SimpleClass7*);
typedef ::IceInternal::Handle< ::Test::SimpleClass7> SimpleClass7Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass7> SimpleClass7Prx;
void __patch(SimpleClass7Ptr&, const ::Ice::ObjectPtr&);

class BaseClass1;
bool operator==(const BaseClass1&, const BaseClass1&);
bool operator<(const BaseClass1&, const BaseClass1&);
::Ice::Object* upCast(::Test::BaseClass1*);
typedef ::IceInternal::Handle< ::Test::BaseClass1> BaseClass1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass1> BaseClass1Prx;
void __patch(BaseClass1Ptr&, const ::Ice::ObjectPtr&);

class BaseClass2;
bool operator==(const BaseClass2&, const BaseClass2&);
bool operator<(const BaseClass2&, const BaseClass2&);
::Ice::Object* upCast(::Test::BaseClass2*);
typedef ::IceInternal::Handle< ::Test::BaseClass2> BaseClass2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass2> BaseClass2Prx;
void __patch(BaseClass2Ptr&, const ::Ice::ObjectPtr&);

class BaseClass3;
bool operator==(const BaseClass3&, const BaseClass3&);
bool operator<(const BaseClass3&, const BaseClass3&);
::Ice::Object* upCast(::Test::BaseClass3*);
typedef ::IceInternal::Handle< ::Test::BaseClass3> BaseClass3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass3> BaseClass3Prx;
void __patch(BaseClass3Ptr&, const ::Ice::ObjectPtr&);

class BaseClass4;
bool operator==(const BaseClass4&, const BaseClass4&);
bool operator<(const BaseClass4&, const BaseClass4&);
::Ice::Object* upCast(::Test::BaseClass4*);
typedef ::IceInternal::Handle< ::Test::BaseClass4> BaseClass4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass4> BaseClass4Prx;
void __patch(BaseClass4Ptr&, const ::Ice::ObjectPtr&);

class BaseClass5;
bool operator==(const BaseClass5&, const BaseClass5&);
bool operator<(const BaseClass5&, const BaseClass5&);
::Ice::Object* upCast(::Test::BaseClass5*);
typedef ::IceInternal::Handle< ::Test::BaseClass5> BaseClass5Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass5> BaseClass5Prx;
void __patch(BaseClass5Ptr&, const ::Ice::ObjectPtr&);

class BaseClass6;
bool operator==(const BaseClass6&, const BaseClass6&);
bool operator<(const BaseClass6&, const BaseClass6&);
::Ice::Object* upCast(::Test::BaseClass6*);
typedef ::IceInternal::Handle< ::Test::BaseClass6> BaseClass6Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass6> BaseClass6Prx;
void __patch(BaseClass6Ptr&, const ::Ice::ObjectPtr&);

class BaseClass7;
bool operator==(const BaseClass7&, const BaseClass7&);
bool operator<(const BaseClass7&, const BaseClass7&);
::Ice::Object* upCast(::Test::BaseClass7*);
typedef ::IceInternal::Handle< ::Test::BaseClass7> BaseClass7Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass7> BaseClass7Prx;
void __patch(BaseClass7Ptr&, const ::Ice::ObjectPtr&);

class BaseClass8;
bool operator==(const BaseClass8&, const BaseClass8&);
bool operator<(const BaseClass8&, const BaseClass8&);
::Ice::Object* upCast(::Test::BaseClass8*);
typedef ::IceInternal::Handle< ::Test::BaseClass8> BaseClass8Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass8> BaseClass8Prx;
void __patch(BaseClass8Ptr&, const ::Ice::ObjectPtr&);

class BaseClass9;
bool operator==(const BaseClass9&, const BaseClass9&);
bool operator<(const BaseClass9&, const BaseClass9&);
::Ice::Object* upCast(::Test::BaseClass9*);
typedef ::IceInternal::Handle< ::Test::BaseClass9> BaseClass9Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass9> BaseClass9Prx;
void __patch(BaseClass9Ptr&, const ::Ice::ObjectPtr&);

class BaseClass10;
bool operator==(const BaseClass10&, const BaseClass10&);
bool operator<(const BaseClass10&, const BaseClass10&);
::Ice::Object* upCast(::Test::BaseClass10*);
typedef ::IceInternal::Handle< ::Test::BaseClass10> BaseClass10Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass10> BaseClass10Prx;
void __patch(BaseClass10Ptr&, const ::Ice::ObjectPtr&);

class BaseClass11;
bool operator==(const BaseClass11&, const BaseClass11&);
bool operator<(const BaseClass11&, const BaseClass11&);
::Ice::Object* upCast(::Test::BaseClass11*);
typedef ::IceInternal::Handle< ::Test::BaseClass11> BaseClass11Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass11> BaseClass11Prx;
void __patch(BaseClass11Ptr&, const ::Ice::ObjectPtr&);

class Compact1;
bool operator==(const Compact1&, const Compact1&);
bool operator<(const Compact1&, const Compact1&);
::Ice::Object* upCast(::Test::Compact1*);
typedef ::IceInternal::Handle< ::Test::Compact1> Compact1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact1> Compact1Prx;
void __patch(Compact1Ptr&, const ::Ice::ObjectPtr&);

class Derived1;
bool operator==(const Derived1&, const Derived1&);
bool operator<(const Derived1&, const Derived1&);
::Ice::Object* upCast(::Test::Derived1*);
typedef ::IceInternal::Handle< ::Test::Derived1> Derived1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Derived1> Derived1Prx;
void __patch(Derived1Ptr&, const ::Ice::ObjectPtr&);

class Compact2;
bool operator==(const Compact2&, const Compact2&);
bool operator<(const Compact2&, const Compact2&);
::Ice::Object* upCast(::Test::Compact2*);
typedef ::IceInternal::Handle< ::Test::Compact2> Compact2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact2> Compact2Prx;
void __patch(Compact2Ptr&, const ::Ice::ObjectPtr&);

class Optional0;
bool operator==(const Optional0&, const Optional0&);
bool operator<(const Optional0&, const Optional0&);
::Ice::Object* upCast(::Test::Optional0*);
typedef ::IceInternal::Handle< ::Test::Optional0> Optional0Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional0> Optional0Prx;
void __patch(Optional0Ptr&, const ::Ice::ObjectPtr&);

class Optional1;
bool operator==(const Optional1&, const Optional1&);
bool operator<(const Optional1&, const Optional1&);
::Ice::Object* upCast(::Test::Optional1*);
typedef ::IceInternal::Handle< ::Test::Optional1> Optional1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional1> Optional1Prx;
void __patch(Optional1Ptr&, const ::Ice::ObjectPtr&);

class Optional2;
bool operator==(const Optional2&, const Optional2&);
bool operator<(const Optional2&, const Optional2&);
::Ice::Object* upCast(::Test::Optional2*);
typedef ::IceInternal::Handle< ::Test::Optional2> Optional2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional2> Optional2Prx;
void __patch(Optional2Ptr&, const ::Ice::ObjectPtr&);

class Optional3;
bool operator==(const Optional3&, const Optional3&);
bool operator<(const Optional3&, const Optional3&);
::Ice::Object* upCast(::Test::Optional3*);
typedef ::IceInternal::Handle< ::Test::Optional3> Optional3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional3> Optional3Prx;
void __patch(Optional3Ptr&, const ::Ice::ObjectPtr&);

class Optional4;
bool operator==(const Optional4&, const Optional4&);
bool operator<(const Optional4&, const Optional4&);
::Ice::Object* upCast(::Test::Optional4*);
typedef ::IceInternal::Handle< ::Test::Optional4> Optional4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional4> Optional4Prx;
void __patch(Optional4Ptr&, const ::Ice::ObjectPtr&);

class OptionalParameters0;
bool operator==(const OptionalParameters0&, const OptionalParameters0&);
bool operator<(const OptionalParameters0&, const OptionalParameters0&);
::Ice::Object* upCast(::Test::OptionalParameters0*);
typedef ::IceInternal::Handle< ::Test::OptionalParameters0> OptionalParameters0Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters0> OptionalParameters0Prx;
void __patch(OptionalParameters0Ptr&, const ::Ice::ObjectPtr&);

class OptionalParameters1;
bool operator==(const OptionalParameters1&, const OptionalParameters1&);
bool operator<(const OptionalParameters1&, const OptionalParameters1&);
::Ice::Object* upCast(::Test::OptionalParameters1*);
typedef ::IceInternal::Handle< ::Test::OptionalParameters1> OptionalParameters1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters1> OptionalParameters1Prx;
void __patch(OptionalParameters1Ptr&, const ::Ice::ObjectPtr&);

class OptionalParameters2;
bool operator==(const OptionalParameters2&, const OptionalParameters2&);
bool operator<(const OptionalParameters2&, const OptionalParameters2&);
::Ice::Object* upCast(::Test::OptionalParameters2*);
typedef ::IceInternal::Handle< ::Test::OptionalParameters2> OptionalParameters2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters2> OptionalParameters2Prx;
void __patch(OptionalParameters2Ptr&, const ::Ice::ObjectPtr&);

class OptionalParameters3;
bool operator==(const OptionalParameters3&, const OptionalParameters3&);
bool operator<(const OptionalParameters3&, const OptionalParameters3&);
::Ice::Object* upCast(::Test::OptionalParameters3*);
typedef ::IceInternal::Handle< ::Test::OptionalParameters3> OptionalParameters3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters3> OptionalParameters3Prx;
void __patch(OptionalParameters3Ptr&, const ::Ice::ObjectPtr&);

class OptionalReturn0;
bool operator==(const OptionalReturn0&, const OptionalReturn0&);
bool operator<(const OptionalReturn0&, const OptionalReturn0&);
::Ice::Object* upCast(::Test::OptionalReturn0*);
typedef ::IceInternal::Handle< ::Test::OptionalReturn0> OptionalReturn0Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn0> OptionalReturn0Prx;
void __patch(OptionalReturn0Ptr&, const ::Ice::ObjectPtr&);

class OptionalReturn2;
bool operator==(const OptionalReturn2&, const OptionalReturn2&);
bool operator<(const OptionalReturn2&, const OptionalReturn2&);
::Ice::Object* upCast(::Test::OptionalReturn2*);
typedef ::IceInternal::Handle< ::Test::OptionalReturn2> OptionalReturn2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn2> OptionalReturn2Prx;
void __patch(OptionalReturn2Ptr&, const ::Ice::ObjectPtr&);

class LocalClass;
bool operator==(const LocalClass&, const LocalClass&);
bool operator<(const LocalClass&, const LocalClass&);
::Ice::LocalObject* upCast(::Test::LocalClass*);
typedef ::IceInternal::Handle< ::Test::LocalClass> LocalClassPtr;

}

namespace Test
{

const ::Ice::Int IntConst1 = 100;

const ::Ice::Int IntConst2 = 100;

const ::Ice::Int IntConst3 = 100;

enum Enum1
{
    Enum11,
    Enum12,
    Enum13
};

enum Enum2
{
    Enum21,
    Enum22,
    Enum23
};

enum Enum3
{
    Enum31,
    Enum32,
    Enum33
};

enum Enum4
{
    Enum41,
    Enum42,
    Enum43
};

enum EnumExplicit0
{
    EnumExplicit01 = 1,
    EnumExplicit02 = 2,
    EnumExplicit03 = 3
};

enum EnumExplicit1
{
    EnumExplicit11 = 1,
    EnumExplicit12 = 2,
    EnumExplicit13 = 3
};

enum EnumExplicit2
{
    EnumExplicit21 = 1,
    EnumExplicit22 = 2,
    EnumExplicit23 = 3
};

enum EnumExplicit3
{
    EnumExplicit31 = 1,
    EnumExplicit32 = 2,
    EnumExplicit33 = 3
};

typedef ::std::vector< ::Ice::Int> Sequence1;

typedef ::std::vector< ::Ice::Int> Sequence2;

typedef ::std::vector< ::Ice::Int> Sequence3;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary1;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary2;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary3;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary4;

struct Struct1
{
    ::std::string str;
    bool b;

    bool operator==(const Struct1& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(b != __rhs.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct1& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(b < __rhs.b)
        {
            return true;
        }
        else if(__rhs.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct1& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Struct1& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Struct1& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Struct1& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Struct2
{
    ::std::string str;
    bool b;

    bool operator==(const Struct2& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(b != __rhs.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct2& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(b < __rhs.b)
        {
            return true;
        }
        else if(__rhs.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct2& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Struct2& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Struct2& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Struct2& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Struct3
{
    ::std::string str;
    bool b;

    bool operator==(const Struct3& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(b != __rhs.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct3& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(b < __rhs.b)
        {
            return true;
        }
        else if(__rhs.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct3& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Struct3& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Struct3& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Struct3& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Struct4
{
    ::std::string str;
    bool b;

    bool operator==(const Struct4& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(b != __rhs.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct4& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(b < __rhs.b)
        {
            return true;
        }
        else if(__rhs.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct4& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Struct4& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Struct4& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Struct4& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Struct5
{
    ::std::string str;
    bool b;

    bool operator==(const Struct5& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        if(b != __rhs.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct5& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        if(b < __rhs.b)
        {
            return true;
        }
        else if(__rhs.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct5& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Struct5& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Struct5& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Struct5& __rhs) const
    {
        return !operator<(__rhs);
    }
};

class Exception1 : public ::Ice::UserException
{
public:

    Exception1() {}
    Exception1(const ::std::string&, bool);
    virtual ~Exception1() throw();

    virtual ::std::string ice_name() const;
    virtual Exception1* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

static Exception1 __Exception1_init;

class Exception2 : public ::Ice::UserException
{
public:

    Exception2() {}
    Exception2(const ::std::string&, bool);
    virtual ~Exception2() throw();

    virtual ::std::string ice_name() const;
    virtual Exception2* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class Exception3 : public ::Ice::UserException
{
public:

    Exception3() {}
    Exception3(const ::std::string&, bool);
    virtual ~Exception3() throw();

    virtual ::std::string ice_name() const;
    virtual Exception3* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class Exception4 : public ::Ice::UserException
{
public:

    Exception4() {}
    Exception4(const ::std::string&, bool);
    virtual ~Exception4() throw();

    virtual ::std::string ice_name() const;
    virtual Exception4* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class Exception5 : public ::Ice::UserException
{
public:

    Exception5() {}
    virtual ~Exception5() throw();

    virtual ::std::string ice_name() const;
    virtual Exception5* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class Exception6 : public ::Ice::UserException
{
public:

    Exception6() {}
    Exception6(const ::std::string&, bool);
    virtual ~Exception6() throw();

    virtual ::std::string ice_name() const;
    virtual Exception6* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class OptionalEx0 : public ::Ice::UserException
{
public:

    OptionalEx0() {}
    OptionalEx0(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);
    virtual ~OptionalEx0() throw();

    virtual ::std::string ice_name() const;
    virtual OptionalEx0* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class OptionalEx1 : public ::Ice::UserException
{
public:

    OptionalEx1() {}
    OptionalEx1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);
    virtual ~OptionalEx1() throw();

    virtual ::std::string ice_name() const;
    virtual OptionalEx1* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class OptionalEx2 : public ::Ice::UserException
{
public:

    OptionalEx2() {}
    OptionalEx2(const ::std::string&, const ::std::string&, const IceUtil::Optional< ::std::string>&);
    virtual ~OptionalEx2() throw();

    virtual ::std::string ice_name() const;
    virtual OptionalEx2* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string firstName;
    ::std::string secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class OptionalEx3 : public ::Ice::UserException
{
public:

    OptionalEx3() {}
    OptionalEx3(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);
    virtual ~OptionalEx3() throw();

    virtual ::std::string ice_name() const;
    virtual OptionalEx3* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class OptionalEx4 : public ::Ice::UserException
{
public:

    OptionalEx4() {}
    OptionalEx4(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);
    virtual ~OptionalEx4() throw();

    virtual ::std::string ice_name() const;
    virtual OptionalEx4* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

enum LocalEnum
{
    LocalEnum1,
    LocalEnum2,
    LocalEnum3
};

typedef ::std::vector< ::std::string> LocalSequence;

typedef ::std::map< ::std::string, ::std::string> LocalDictionary;

struct LocalStruct
{
    ::std::string str;

    bool operator==(const LocalStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(str != __rhs.str)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LocalStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(str < __rhs.str)
        {
            return true;
        }
        else if(__rhs.str < str)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LocalStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const LocalStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const LocalStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const LocalStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::Enum1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit0>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Struct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Struct1, S>
{
    static void write(S* __os, const ::Test::Struct1& v)
    {
        __os->write(v.str);
        __os->write(v.b);
    }
};

template<class S>
struct StreamReader< ::Test::Struct1, S>
{
    static void read(S* __is, ::Test::Struct1& v)
    {
        __is->read(v.str);
        __is->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Struct2, S>
{
    static void write(S* __os, const ::Test::Struct2& v)
    {
        __os->write(v.str);
        __os->write(v.b);
    }
};

template<class S>
struct StreamReader< ::Test::Struct2, S>
{
    static void read(S* __is, ::Test::Struct2& v)
    {
        __is->read(v.str);
        __is->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Struct3, S>
{
    static void write(S* __os, const ::Test::Struct3& v)
    {
        __os->write(v.str);
        __os->write(v.b);
    }
};

template<class S>
struct StreamReader< ::Test::Struct3, S>
{
    static void read(S* __is, ::Test::Struct3& v)
    {
        __is->read(v.str);
        __is->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Struct4, S>
{
    static void write(S* __os, const ::Test::Struct4& v)
    {
        __os->write(v.str);
        __os->write(v.b);
    }
};

template<class S>
struct StreamReader< ::Test::Struct4, S>
{
    static void read(S* __is, ::Test::Struct4& v)
    {
        __is->read(v.str);
        __is->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::Struct5, S>
{
    static void write(S* __os, const ::Test::Struct5& v)
    {
        __os->write(v.str);
        __os->write(v.b);
    }
};

template<class S>
struct StreamReader< ::Test::Struct5, S>
{
    static void read(S* __is, ::Test::Struct5& v)
    {
        __is->read(v.str);
        __is->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Exception1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::Exception2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::Exception3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::Exception4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::Exception5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::Exception6>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::OptionalEx0>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::OptionalEx1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::OptionalEx2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::OptionalEx3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::OptionalEx4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Test
{

class Callback_BaseClass1_baseOp1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass1_baseOp1_Base> Callback_BaseClass1_baseOp1Ptr;

class Callback_BaseClass1_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass1_baseOp2_Base> Callback_BaseClass1_baseOp2Ptr;

class Callback_BaseClass2_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass2_baseOp_Base> Callback_BaseClass2_baseOpPtr;

class Callback_BaseClass2_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass2_baseOp2_Base> Callback_BaseClass2_baseOp2Ptr;

class Callback_BaseClass3_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass3_baseOp_Base> Callback_BaseClass3_baseOpPtr;

class Callback_BaseClass3_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass3_baseOp2_Base> Callback_BaseClass3_baseOp2Ptr;

class Callback_BaseClass4_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass4_baseOp_Base> Callback_BaseClass4_baseOpPtr;

class Callback_BaseClass4_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass4_baseOp2_Base> Callback_BaseClass4_baseOp2Ptr;

class Callback_BaseClass5_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass5_baseOp_Base> Callback_BaseClass5_baseOpPtr;

class Callback_BaseClass5_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass5_baseOp2_Base> Callback_BaseClass5_baseOp2Ptr;

class Callback_BaseClass6_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass6_baseOp_Base> Callback_BaseClass6_baseOpPtr;

class Callback_BaseClass6_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass6_baseOp2_Base> Callback_BaseClass6_baseOp2Ptr;

class Callback_BaseClass7_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass7_baseOp_Base> Callback_BaseClass7_baseOpPtr;

class Callback_BaseClass7_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass7_baseOp2_Base> Callback_BaseClass7_baseOp2Ptr;

class Callback_BaseClass8_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass8_baseOp_Base> Callback_BaseClass8_baseOpPtr;

class Callback_BaseClass8_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass8_baseOp2_Base> Callback_BaseClass8_baseOp2Ptr;

class Callback_BaseClass9_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass9_baseOp_Base> Callback_BaseClass9_baseOpPtr;

class Callback_BaseClass9_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass9_baseOp2_Base> Callback_BaseClass9_baseOp2Ptr;

class Callback_BaseClass10_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass10_baseOp_Base> Callback_BaseClass10_baseOpPtr;

class Callback_BaseClass10_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass10_baseOp2_Base> Callback_BaseClass10_baseOp2Ptr;

class Callback_BaseClass11_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass11_baseOp_Base> Callback_BaseClass11_baseOpPtr;

class Callback_BaseClass11_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseClass11_baseOp2_Base> Callback_BaseClass11_baseOp2Ptr;

class Callback_Compact1_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Compact1_baseOp_Base> Callback_Compact1_baseOpPtr;

class Callback_Compact1_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Compact1_baseOp2_Base> Callback_Compact1_baseOp2Ptr;

class Callback_Compact2_baseOp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Compact2_baseOp_Base> Callback_Compact2_baseOpPtr;

class Callback_Compact2_baseOp2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Compact2_baseOp2_Base> Callback_Compact2_baseOp2Ptr;

class Callback_OptionalParameters0_op1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters0_op1_Base> Callback_OptionalParameters0_op1Ptr;

class Callback_OptionalParameters1_op1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters1_op1_Base> Callback_OptionalParameters1_op1Ptr;

class Callback_OptionalParameters2_op1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters2_op1_Base> Callback_OptionalParameters2_op1Ptr;

class Callback_OptionalParameters3_op1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters3_op1_Base> Callback_OptionalParameters3_op1Ptr;

class Callback_OptionalReturn0_op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalReturn0_op_Base> Callback_OptionalReturn0_opPtr;

class Callback_OptionalReturn2_op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalReturn2_op_Base> Callback_OptionalReturn2_opPtr;

}

namespace IceProxy
{

namespace Test
{

class Interface1 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Interface1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_secure(bool __secure) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_twoway() const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_oneway() const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_batchOneway() const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_datagram() const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_batchDatagram() const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_compress(bool __compress) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Interface1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Interface2 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Interface2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_secure(bool __secure) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_twoway() const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_oneway() const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_batchOneway() const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_datagram() const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_batchDatagram() const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_compress(bool __compress) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Interface2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Interface3 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Interface3> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_secure(bool __secure) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_twoway() const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_oneway() const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_batchOneway() const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_datagram() const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_batchDatagram() const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_compress(bool __compress) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface3> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Interface3*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Interface4 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Interface4> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_secure(bool __secure) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_twoway() const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_oneway() const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_batchOneway() const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_datagram() const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_batchDatagram() const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_compress(bool __compress) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Interface4> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Interface4*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class EmptyClass1 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_secure(bool __secure) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_twoway() const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_oneway() const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_batchOneway() const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_datagram() const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_batchDatagram() const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_compress(bool __compress) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<EmptyClass1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class EmptyClass2 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_secure(bool __secure) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_twoway() const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_oneway() const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_batchOneway() const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_datagram() const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_batchDatagram() const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_compress(bool __compress) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<EmptyClass2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class EmptyClass3 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_secure(bool __secure) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_twoway() const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_oneway() const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_batchOneway() const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_datagram() const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_batchDatagram() const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_compress(bool __compress) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_timeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass3> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<EmptyClass3*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class EmptyClass4 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_secure(bool __secure) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_twoway() const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_oneway() const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_batchOneway() const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_datagram() const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_batchDatagram() const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_compress(bool __compress) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_timeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass4> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<EmptyClass4*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class EmptyClass5 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_secure(bool __secure) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_twoway() const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_oneway() const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_batchOneway() const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_datagram() const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_batchDatagram() const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_compress(bool __compress) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_timeout(int __timeout) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<EmptyClass5> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<EmptyClass5*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SimpleClass1 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_secure(bool __secure) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_twoway() const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_oneway() const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_batchOneway() const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_datagram() const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_batchDatagram() const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_compress(bool __compress) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SimpleClass1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SimpleClass2 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_secure(bool __secure) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_twoway() const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_oneway() const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_batchOneway() const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_datagram() const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_batchDatagram() const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_compress(bool __compress) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SimpleClass2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SimpleClass3 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_secure(bool __secure) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_twoway() const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_oneway() const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_batchOneway() const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_datagram() const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_batchDatagram() const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_compress(bool __compress) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass3> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SimpleClass3*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SimpleClass4 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_secure(bool __secure) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_twoway() const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_oneway() const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_batchOneway() const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_datagram() const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_batchDatagram() const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_compress(bool __compress) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass4> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SimpleClass4*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SimpleClass5 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_secure(bool __secure) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_twoway() const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_oneway() const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_batchOneway() const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_datagram() const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_batchDatagram() const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_compress(bool __compress) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass5> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SimpleClass5*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SimpleClass6 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_secure(bool __secure) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_twoway() const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_oneway() const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_batchOneway() const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_datagram() const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_batchDatagram() const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_compress(bool __compress) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass6> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SimpleClass6*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SimpleClass7 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_secure(bool __secure) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_twoway() const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_oneway() const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_batchOneway() const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_datagram() const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_batchDatagram() const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_compress(bool __compress) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SimpleClass7> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SimpleClass7*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass1 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp1()
    {
        baseOp1(0);
    }
    void baseOp1(const ::Ice::Context& __ctx)
    {
        baseOp1(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp1(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp1(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp1(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp1(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp1(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp1(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp1()
    {
        return begin_baseOp1(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::Context& __ctx)
    {
        return begin_baseOp1(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp1(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Test::Callback_BaseClass1_baseOp1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass1_baseOp1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp1(&__ctx, __del, __cookie);
    }

    void end_baseOp1(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp1(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass1Prx __proxy = ::Test::BaseClass1Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass1_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass1_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_twoway() const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_oneway() const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_datagram() const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass2 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass2_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass2_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass2Prx __proxy = ::Test::BaseClass2Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass2_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass2_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_twoway() const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_oneway() const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_datagram() const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass3 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass3_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass3_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass3Prx __proxy = ::Test::BaseClass3Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass3_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass3_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_twoway() const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_oneway() const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_datagram() const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass3> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass3*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass4 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass4_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass4_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass4Prx __proxy = ::Test::BaseClass4Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass4_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass4_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_twoway() const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_oneway() const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_datagram() const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass4> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass4*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass5 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass5_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass5_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass5Prx __proxy = ::Test::BaseClass5Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass5_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass5_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_twoway() const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_oneway() const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_datagram() const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass5> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass5*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass6 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass6_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass6_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass6Prx __proxy = ::Test::BaseClass6Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass6_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass6_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_twoway() const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_oneway() const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_datagram() const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass6> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass6*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass7 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass7_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass7_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass7Prx __proxy = ::Test::BaseClass7Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass7_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass7_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_twoway() const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_oneway() const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_datagram() const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass7> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass7*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass8 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass8_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass8_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass8Prx __proxy = ::Test::BaseClass8Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass8_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass8_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_twoway() const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_oneway() const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_datagram() const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass8> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass8*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass9 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass9_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass9_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass9Prx __proxy = ::Test::BaseClass9Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass9_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass9_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_twoway() const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_oneway() const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_datagram() const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass9> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass9*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass10 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass10_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass10_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass10Prx __proxy = ::Test::BaseClass10Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass10_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass10_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_twoway() const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_oneway() const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_datagram() const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass10> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass10*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BaseClass11 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseClass11_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass11_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::BaseClass11Prx __proxy = ::Test::BaseClass11Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseClass11_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_BaseClass11_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_secure(bool __secure) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_twoway() const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_oneway() const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_batchOneway() const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_datagram() const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_batchDatagram() const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_compress(bool __compress) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BaseClass11> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BaseClass11*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Compact1 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_Compact1_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_Compact1_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::Compact1Prx __proxy = ::Test::Compact1Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_Compact1_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_Compact1_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Compact1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_secure(bool __secure) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_twoway() const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_oneway() const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_batchOneway() const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_datagram() const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_batchDatagram() const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_compress(bool __compress) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Compact1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Compact1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Derived1 : virtual public ::IceProxy::Test::Compact1
{
public:
    
    ::IceInternal::ProxyHandle<Derived1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_secure(bool __secure) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_twoway() const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_oneway() const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_batchOneway() const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_datagram() const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_batchDatagram() const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_compress(bool __compress) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Derived1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Derived1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Compact2 : virtual public ::IceProxy::Ice::Object
{
public:

    void baseOp()
    {
        baseOp(0);
    }
    void baseOp(const ::Ice::Context& __ctx)
    {
        baseOp(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_baseOp(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_baseOp()
    {
        return begin_baseOp(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx)
    {
        return begin_baseOp(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_Compact2_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& __ctx, const ::Test::Callback_Compact2_baseOpPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp(&__ctx, __del, __cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void baseOp2(::Ice::Int i, ::std::string& s)
    {
        baseOp2(i, s, 0);
    }
    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& __ctx)
    {
        baseOp2(i, s, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_baseOp2(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_baseOp2(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::Compact2Prx __proxy = ::Test::Compact2Prx::uncheckedCast(__result->getProxy());
                ::std::string s;
                try
                {
                    __proxy->end_baseOp2(s, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(s);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_baseOp2(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i)
    {
        return begin_baseOp2(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_baseOp2(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_Compact2_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& __ctx, const ::Test::Callback_Compact2_baseOp2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_baseOp2(i, &__ctx, __del, __cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr&);
    
private:

    void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Compact2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_secure(bool __secure) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_twoway() const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_oneway() const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_batchOneway() const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_datagram() const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_batchDatagram() const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_compress(bool __compress) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Compact2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Compact2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Optional0 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Optional0> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_secure(bool __secure) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_twoway() const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_oneway() const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_batchOneway() const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_datagram() const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_batchDatagram() const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_compress(bool __compress) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional0> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Optional0*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Optional1 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Optional1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_secure(bool __secure) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_twoway() const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_oneway() const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_batchOneway() const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_datagram() const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_batchDatagram() const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_compress(bool __compress) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Optional1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Optional2 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Optional2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_secure(bool __secure) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_twoway() const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_oneway() const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_batchOneway() const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_datagram() const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_batchDatagram() const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_compress(bool __compress) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Optional2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Optional3 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Optional3> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_secure(bool __secure) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_twoway() const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_oneway() const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_batchOneway() const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_datagram() const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_batchDatagram() const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_compress(bool __compress) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional3> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Optional3*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Optional4 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Optional4> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_secure(bool __secure) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_twoway() const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_oneway() const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_batchOneway() const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_datagram() const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_batchDatagram() const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_compress(bool __compress) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Optional4> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Optional4*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OptionalParameters0 : virtual public ::IceProxy::Ice::Object
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress)
    {
        op1(firstName, secondName, emailAddress, 0);
    }
    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx)
    {
        op1(firstName, secondName, emailAddress, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, secondName, emailAddress, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, secondName, emailAddress, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress)
    {
        return begin_op1(firstName, secondName, emailAddress, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx)
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Test::Callback_OptionalParameters0_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::Test::Callback_OptionalParameters0_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, __del, __cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr&);
    
private:

    void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_twoway() const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_oneway() const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_batchOneway() const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_datagram() const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters0> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalParameters0*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OptionalParameters1 : virtual public ::IceProxy::Ice::Object
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress)
    {
        op1(firstName, secondName, emailAddress, 0);
    }
    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx)
    {
        op1(firstName, secondName, emailAddress, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, secondName, emailAddress, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, secondName, emailAddress, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress)
    {
        return begin_op1(firstName, secondName, emailAddress, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx)
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Test::Callback_OptionalParameters1_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& __ctx, const ::Test::Callback_OptionalParameters1_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, secondName, emailAddress, &__ctx, __del, __cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr&);
    
private:

    void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_twoway() const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_oneway() const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_batchOneway() const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_datagram() const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalParameters1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OptionalParameters2 : virtual public ::IceProxy::Ice::Object
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName)
    {
        op1(firstName, emailAddress, secondName, 0);
    }
    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& __ctx)
    {
        op1(firstName, emailAddress, secondName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, emailAddress, secondName, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, emailAddress, secondName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName)
    {
        return begin_op1(firstName, emailAddress, secondName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& __ctx)
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Test::Callback_OptionalParameters2_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& __ctx, const ::Test::Callback_OptionalParameters2_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, __del, __cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr&);
    
private:

    void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_twoway() const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_oneway() const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_batchOneway() const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_datagram() const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalParameters2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OptionalParameters3 : virtual public ::IceProxy::Ice::Object
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName)
    {
        op1(firstName, emailAddress, secondName, 0);
    }
    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& __ctx)
    {
        op1(firstName, emailAddress, secondName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, emailAddress, secondName, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, emailAddress, secondName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName)
    {
        return begin_op1(firstName, emailAddress, secondName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& __ctx)
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Test::Callback_OptionalParameters3_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& __ctx, const ::Test::Callback_OptionalParameters3_op1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op1(firstName, emailAddress, secondName, &__ctx, __del, __cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr&);
    
private:

    void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_twoway() const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_oneway() const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_batchOneway() const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_datagram() const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalParameters3> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalParameters3*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OptionalReturn0 : virtual public ::IceProxy::Ice::Object
{
public:

    IceUtil::Optional< ::Ice::Int> op()
    {
        return op(0);
    }
    IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context& __ctx)
    {
        return op(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_op(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_op(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_op(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const IceUtil::Optional< ::Ice::Int>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::OptionalReturn0Prx __proxy = ::Test::OptionalReturn0Prx::uncheckedCast(__result->getProxy());
                IceUtil::Optional< ::Ice::Int> __ret;
                try
                {
                    __ret = __proxy->end_op(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const IceUtil::Optional< ::Ice::Int>&)> _response;
        };
        return begin_op(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_op()
    {
        return begin_op(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx)
    {
        return begin_op(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::Callback_OptionalReturn0_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Test::Callback_OptionalReturn0_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Int> end_op(const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_twoway() const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_oneway() const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_batchOneway() const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_datagram() const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn0> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalReturn0*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OptionalReturn2 : virtual public ::IceProxy::Ice::Object
{
public:

    IceUtil::Optional< ::Ice::Int> op()
    {
        return op(0);
    }
    IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context& __ctx)
    {
        return op(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_op(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_op(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_op(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_op(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const IceUtil::Optional< ::Ice::Int>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::OptionalReturn2Prx __proxy = ::Test::OptionalReturn2Prx::uncheckedCast(__result->getProxy());
                IceUtil::Optional< ::Ice::Int> __ret;
                try
                {
                    __ret = __proxy->end_op(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const IceUtil::Optional< ::Ice::Int>&)> _response;
        };
        return begin_op(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_op()
    {
        return begin_op(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx)
    {
        return begin_op(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::Callback_OptionalReturn2_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& __ctx, const ::Test::Callback_OptionalReturn2_opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_op(&__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Int> end_op(const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_twoway() const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_oneway() const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_batchOneway() const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_datagram() const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalReturn2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalReturn2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Test
{

class Interface1 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Interface2 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Interface3 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Interface4 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class EmptyClass1 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class EmptyClass2 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class EmptyClass3 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class EmptyClass4 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class EmptyClass5 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SimpleClass1 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SimpleClass2 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SimpleClass3 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SimpleClass4 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SimpleClass5 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SimpleClass6 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SimpleClass7 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class BaseClass1 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp1(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass2 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass3 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass4 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass5 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass6 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass7 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass8 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass9 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass10 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class BaseClass11 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class Compact1 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class Derived1 : virtual public ::IceDelegate::Test::Compact1
{
public:
};

class Compact2 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class Optional0 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Optional1 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Optional2 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Optional3 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Optional4 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class OptionalParameters0 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class OptionalParameters1 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class OptionalParameters2 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class OptionalParameters3 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class OptionalReturn0 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class OptionalReturn2 : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

namespace IceDelegateM
{

namespace Test
{

class Interface1 : virtual public ::IceDelegate::Test::Interface1,
                   virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Interface2 : virtual public ::IceDelegate::Test::Interface2,
                   virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Interface3 : virtual public ::IceDelegate::Test::Interface3,
                   virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Interface4 : virtual public ::IceDelegate::Test::Interface4,
                   virtual public ::IceDelegateM::Ice::Object
{
public:
};

class EmptyClass1 : virtual public ::IceDelegate::Test::EmptyClass1,
                    virtual public ::IceDelegateM::Ice::Object
{
public:
};

class EmptyClass2 : virtual public ::IceDelegate::Test::EmptyClass2,
                    virtual public ::IceDelegateM::Ice::Object
{
public:
};

class EmptyClass3 : virtual public ::IceDelegate::Test::EmptyClass3,
                    virtual public ::IceDelegateM::Ice::Object
{
public:
};

class EmptyClass4 : virtual public ::IceDelegate::Test::EmptyClass4,
                    virtual public ::IceDelegateM::Ice::Object
{
public:
};

class EmptyClass5 : virtual public ::IceDelegate::Test::EmptyClass5,
                    virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SimpleClass1 : virtual public ::IceDelegate::Test::SimpleClass1,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SimpleClass2 : virtual public ::IceDelegate::Test::SimpleClass2,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SimpleClass3 : virtual public ::IceDelegate::Test::SimpleClass3,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SimpleClass4 : virtual public ::IceDelegate::Test::SimpleClass4,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SimpleClass5 : virtual public ::IceDelegate::Test::SimpleClass5,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SimpleClass6 : virtual public ::IceDelegate::Test::SimpleClass6,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SimpleClass7 : virtual public ::IceDelegate::Test::SimpleClass7,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class BaseClass1 : virtual public ::IceDelegate::Test::BaseClass1,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp1(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass2 : virtual public ::IceDelegate::Test::BaseClass2,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass3 : virtual public ::IceDelegate::Test::BaseClass3,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass4 : virtual public ::IceDelegate::Test::BaseClass4,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass5 : virtual public ::IceDelegate::Test::BaseClass5,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass6 : virtual public ::IceDelegate::Test::BaseClass6,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass7 : virtual public ::IceDelegate::Test::BaseClass7,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass8 : virtual public ::IceDelegate::Test::BaseClass8,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass9 : virtual public ::IceDelegate::Test::BaseClass9,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass10 : virtual public ::IceDelegate::Test::BaseClass10,
                    virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass11 : virtual public ::IceDelegate::Test::BaseClass11,
                    virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Compact1 : virtual public ::IceDelegate::Test::Compact1,
                 virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Derived1 : virtual public ::IceDelegate::Test::Derived1,
                 virtual public ::IceDelegateM::Test::Compact1
{
public:
};

class Compact2 : virtual public ::IceDelegate::Test::Compact2,
                 virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Optional0 : virtual public ::IceDelegate::Test::Optional0,
                  virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Optional1 : virtual public ::IceDelegate::Test::Optional1,
                  virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Optional2 : virtual public ::IceDelegate::Test::Optional2,
                  virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Optional3 : virtual public ::IceDelegate::Test::Optional3,
                  virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Optional4 : virtual public ::IceDelegate::Test::Optional4,
                  virtual public ::IceDelegateM::Ice::Object
{
public:
};

class OptionalParameters0 : virtual public ::IceDelegate::Test::OptionalParameters0,
                            virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalParameters1 : virtual public ::IceDelegate::Test::OptionalParameters1,
                            virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalParameters2 : virtual public ::IceDelegate::Test::OptionalParameters2,
                            virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalParameters3 : virtual public ::IceDelegate::Test::OptionalParameters3,
                            virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalReturn0 : virtual public ::IceDelegate::Test::OptionalReturn0,
                        virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalReturn2 : virtual public ::IceDelegate::Test::OptionalReturn2,
                        virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceDelegateD
{

namespace Test
{

class Interface1 : virtual public ::IceDelegate::Test::Interface1,
                   virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Interface2 : virtual public ::IceDelegate::Test::Interface2,
                   virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Interface3 : virtual public ::IceDelegate::Test::Interface3,
                   virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Interface4 : virtual public ::IceDelegate::Test::Interface4,
                   virtual public ::IceDelegateD::Ice::Object
{
public:
};

class EmptyClass1 : virtual public ::IceDelegate::Test::EmptyClass1,
                    virtual public ::IceDelegateD::Ice::Object
{
public:
};

class EmptyClass2 : virtual public ::IceDelegate::Test::EmptyClass2,
                    virtual public ::IceDelegateD::Ice::Object
{
public:
};

class EmptyClass3 : virtual public ::IceDelegate::Test::EmptyClass3,
                    virtual public ::IceDelegateD::Ice::Object
{
public:
};

class EmptyClass4 : virtual public ::IceDelegate::Test::EmptyClass4,
                    virtual public ::IceDelegateD::Ice::Object
{
public:
};

class EmptyClass5 : virtual public ::IceDelegate::Test::EmptyClass5,
                    virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SimpleClass1 : virtual public ::IceDelegate::Test::SimpleClass1,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SimpleClass2 : virtual public ::IceDelegate::Test::SimpleClass2,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SimpleClass3 : virtual public ::IceDelegate::Test::SimpleClass3,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SimpleClass4 : virtual public ::IceDelegate::Test::SimpleClass4,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SimpleClass5 : virtual public ::IceDelegate::Test::SimpleClass5,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SimpleClass6 : virtual public ::IceDelegate::Test::SimpleClass6,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SimpleClass7 : virtual public ::IceDelegate::Test::SimpleClass7,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class BaseClass1 : virtual public ::IceDelegate::Test::BaseClass1,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp1(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass2 : virtual public ::IceDelegate::Test::BaseClass2,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass3 : virtual public ::IceDelegate::Test::BaseClass3,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass4 : virtual public ::IceDelegate::Test::BaseClass4,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass5 : virtual public ::IceDelegate::Test::BaseClass5,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass6 : virtual public ::IceDelegate::Test::BaseClass6,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass7 : virtual public ::IceDelegate::Test::BaseClass7,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass8 : virtual public ::IceDelegate::Test::BaseClass8,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass9 : virtual public ::IceDelegate::Test::BaseClass9,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass10 : virtual public ::IceDelegate::Test::BaseClass10,
                    virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class BaseClass11 : virtual public ::IceDelegate::Test::BaseClass11,
                    virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Compact1 : virtual public ::IceDelegate::Test::Compact1,
                 virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Derived1 : virtual public ::IceDelegate::Test::Derived1,
                 virtual public ::IceDelegateD::Test::Compact1
{
public:
};

class Compact2 : virtual public ::IceDelegate::Test::Compact2,
                 virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void baseOp(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Optional0 : virtual public ::IceDelegate::Test::Optional0,
                  virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Optional1 : virtual public ::IceDelegate::Test::Optional1,
                  virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Optional2 : virtual public ::IceDelegate::Test::Optional2,
                  virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Optional3 : virtual public ::IceDelegate::Test::Optional3,
                  virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Optional4 : virtual public ::IceDelegate::Test::Optional4,
                  virtual public ::IceDelegateD::Ice::Object
{
public:
};

class OptionalParameters0 : virtual public ::IceDelegate::Test::OptionalParameters0,
                            virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalParameters1 : virtual public ::IceDelegate::Test::OptionalParameters1,
                            virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalParameters2 : virtual public ::IceDelegate::Test::OptionalParameters2,
                            virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalParameters3 : virtual public ::IceDelegate::Test::OptionalParameters3,
                            virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalReturn0 : virtual public ::IceDelegate::Test::OptionalReturn0,
                        virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class OptionalReturn2 : virtual public ::IceDelegate::Test::OptionalReturn2,
                        virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace Test
{

class Interface1 : virtual public ::Ice::Object
{
public:

    typedef Interface1Prx ProxyType;
    typedef Interface1Ptr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Interface1& l, const Interface1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Interface1& l, const Interface1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Interface2 : virtual public ::Ice::Object
{
public:

    typedef Interface2Prx ProxyType;
    typedef Interface2Ptr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Interface2& l, const Interface2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Interface2& l, const Interface2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Interface3 : virtual public ::Ice::Object
{
public:

    typedef Interface3Prx ProxyType;
    typedef Interface3Ptr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Interface3& l, const Interface3& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Interface3& l, const Interface3& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Interface4 : virtual public ::Ice::Object
{
public:

    typedef Interface4Prx ProxyType;
    typedef Interface4Ptr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Interface4& l, const Interface4& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Interface4& l, const Interface4& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class EmptyClass1 : virtual public ::Ice::Object
{
public:

    typedef EmptyClass1Prx ProxyType;
    typedef EmptyClass1Ptr PointerType;

    EmptyClass1()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~EmptyClass1() {}

    friend class EmptyClass1__staticInit;
};

class EmptyClass1__staticInit
{
public:

    ::Test::EmptyClass1 _init;
};

static EmptyClass1__staticInit _EmptyClass1_init;

inline bool operator==(const EmptyClass1& l, const EmptyClass1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const EmptyClass1& l, const EmptyClass1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class EmptyClass2 : virtual public ::Ice::Object
{
public:

    typedef EmptyClass2Prx ProxyType;
    typedef EmptyClass2Ptr PointerType;

    EmptyClass2()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~EmptyClass2() {}
};

inline bool operator==(const EmptyClass2& l, const EmptyClass2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const EmptyClass2& l, const EmptyClass2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class EmptyClass3 : virtual public ::Ice::Object
{
public:

    typedef EmptyClass3Prx ProxyType;
    typedef EmptyClass3Ptr PointerType;

    EmptyClass3()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~EmptyClass3() {}
};

inline bool operator==(const EmptyClass3& l, const EmptyClass3& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const EmptyClass3& l, const EmptyClass3& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class EmptyClass4 : virtual public ::Ice::Object
{
public:

    typedef EmptyClass4Prx ProxyType;
    typedef EmptyClass4Ptr PointerType;

    EmptyClass4()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~EmptyClass4() {}
};

inline bool operator==(const EmptyClass4& l, const EmptyClass4& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const EmptyClass4& l, const EmptyClass4& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class EmptyClass5 : virtual public ::Ice::Object
{
public:

    typedef EmptyClass5Prx ProxyType;
    typedef EmptyClass5Ptr PointerType;

    EmptyClass5()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

    virtual ~EmptyClass5() {}
};

inline bool operator==(const EmptyClass5& l, const EmptyClass5& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const EmptyClass5& l, const EmptyClass5& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SimpleClass1 : virtual public ::Ice::Object
{
public:

    typedef SimpleClass1Prx ProxyType;
    typedef SimpleClass1Ptr PointerType;

    SimpleClass1()
    {
    }

    SimpleClass1(const ::std::string& __ice_str, ::Ice::Float __ice_f) :
        str(__ice_str),
        f(__ice_f)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string str;

    ::Ice::Float f;

protected:

    virtual ~SimpleClass1() {}
};

inline bool operator==(const SimpleClass1& l, const SimpleClass1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SimpleClass1& l, const SimpleClass1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SimpleClass2 : virtual public ::Ice::Object
{
public:

    typedef SimpleClass2Prx ProxyType;
    typedef SimpleClass2Ptr PointerType;

    SimpleClass2()
    {
    }

    SimpleClass2(const ::std::string& __ice_str, ::Ice::Float __ice_f) :
        str(__ice_str),
        f(__ice_f)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string str;

    ::Ice::Float f;

protected:

    virtual ~SimpleClass2() {}
};

inline bool operator==(const SimpleClass2& l, const SimpleClass2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SimpleClass2& l, const SimpleClass2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SimpleClass3 : virtual public ::Ice::Object
{
public:

    typedef SimpleClass3Prx ProxyType;
    typedef SimpleClass3Ptr PointerType;

    SimpleClass3()
    {
    }

    SimpleClass3(const ::std::string& __ice_str, ::Ice::Float __ice_f) :
        str(__ice_str),
        f(__ice_f)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string str;

    ::Ice::Float f;

protected:

    virtual ~SimpleClass3() {}
};

inline bool operator==(const SimpleClass3& l, const SimpleClass3& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SimpleClass3& l, const SimpleClass3& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SimpleClass4 : virtual public ::Ice::Object
{
public:

    typedef SimpleClass4Prx ProxyType;
    typedef SimpleClass4Ptr PointerType;

    SimpleClass4()
    {
    }

    SimpleClass4(const ::std::string& __ice_str, ::Ice::Float __ice_f) :
        str(__ice_str),
        f(__ice_f)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string str;

    ::Ice::Float f;

protected:

    virtual ~SimpleClass4() {}
};

inline bool operator==(const SimpleClass4& l, const SimpleClass4& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SimpleClass4& l, const SimpleClass4& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SimpleClass5 : virtual public ::Ice::Object
{
public:

    typedef SimpleClass5Prx ProxyType;
    typedef SimpleClass5Ptr PointerType;

    SimpleClass5()
    {
    }

    SimpleClass5(const ::std::string& __ice_str, ::Ice::Float __ice_f) :
        str(__ice_str),
        f(__ice_f)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string str;

    ::Ice::Float f;

protected:

    virtual ~SimpleClass5() {}
};

inline bool operator==(const SimpleClass5& l, const SimpleClass5& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SimpleClass5& l, const SimpleClass5& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SimpleClass6 : virtual public ::Ice::Object
{
public:

    typedef SimpleClass6Prx ProxyType;
    typedef SimpleClass6Ptr PointerType;

    SimpleClass6()
    {
    }

    SimpleClass6(const ::std::string& __ice_str, ::Ice::Float __ice_f) :
        str(__ice_str),
        f(__ice_f)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string str;

    ::Ice::Float f;

protected:

    virtual ~SimpleClass6() {}
};

inline bool operator==(const SimpleClass6& l, const SimpleClass6& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SimpleClass6& l, const SimpleClass6& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SimpleClass7 : virtual public ::Ice::Object
{
public:

    typedef SimpleClass7Prx ProxyType;
    typedef SimpleClass7Ptr PointerType;

    SimpleClass7()
    {
    }

    SimpleClass7(const ::std::string& __ice_str, ::Ice::Float __ice_f) :
        str(__ice_str),
        f(__ice_f)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string str;

    ::Ice::Float f;

protected:

    virtual ~SimpleClass7() {}
};

inline bool operator==(const SimpleClass7& l, const SimpleClass7& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SimpleClass7& l, const SimpleClass7& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass1 : virtual public ::Ice::Object
{
public:

    typedef BaseClass1Prx ProxyType;
    typedef BaseClass1Ptr PointerType;

    BaseClass1()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp1(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass1& l, const BaseClass1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass1& l, const BaseClass1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass2 : virtual public ::Ice::Object
{
public:

    typedef BaseClass2Prx ProxyType;
    typedef BaseClass2Ptr PointerType;

    BaseClass2()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass2& l, const BaseClass2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass2& l, const BaseClass2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass3 : virtual public ::Ice::Object
{
public:

    typedef BaseClass3Prx ProxyType;
    typedef BaseClass3Ptr PointerType;

    BaseClass3()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass3& l, const BaseClass3& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass3& l, const BaseClass3& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass4 : virtual public ::Ice::Object
{
public:

    typedef BaseClass4Prx ProxyType;
    typedef BaseClass4Ptr PointerType;

    BaseClass4()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass4& l, const BaseClass4& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass4& l, const BaseClass4& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass5 : virtual public ::Ice::Object
{
public:

    typedef BaseClass5Prx ProxyType;
    typedef BaseClass5Ptr PointerType;

    BaseClass5()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass5& l, const BaseClass5& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass5& l, const BaseClass5& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass6 : virtual public ::Ice::Object
{
public:

    typedef BaseClass6Prx ProxyType;
    typedef BaseClass6Ptr PointerType;

    BaseClass6()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass6& l, const BaseClass6& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass6& l, const BaseClass6& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass7 : virtual public ::Ice::Object
{
public:

    typedef BaseClass7Prx ProxyType;
    typedef BaseClass7Ptr PointerType;

    BaseClass7()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass7& l, const BaseClass7& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass7& l, const BaseClass7& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass8 : virtual public ::Ice::Object
{
public:

    typedef BaseClass8Prx ProxyType;
    typedef BaseClass8Ptr PointerType;

    BaseClass8()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass8& l, const BaseClass8& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass8& l, const BaseClass8& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass9 : virtual public ::Ice::Object
{
public:

    typedef BaseClass9Prx ProxyType;
    typedef BaseClass9Ptr PointerType;

    BaseClass9()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass9& l, const BaseClass9& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass9& l, const BaseClass9& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass10 : virtual public ::Ice::Object
{
public:

    typedef BaseClass10Prx ProxyType;
    typedef BaseClass10Ptr PointerType;

    BaseClass10()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass10& l, const BaseClass10& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass10& l, const BaseClass10& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BaseClass11 : virtual public ::Ice::Object
{
public:

    typedef BaseClass11Prx ProxyType;
    typedef BaseClass11Ptr PointerType;

    BaseClass11()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const BaseClass11& l, const BaseClass11& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BaseClass11& l, const BaseClass11& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Compact1 : virtual public ::Ice::Object
{
public:

    typedef Compact1Prx ProxyType;
    typedef Compact1Ptr PointerType;

    Compact1()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Compact1& l, const Compact1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Compact1& l, const Compact1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Derived1 : public ::Test::Compact1
{
public:

    typedef Derived1Prx ProxyType;
    typedef Derived1Ptr PointerType;

    Derived1()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::Compact1::__writeImpl;
    using ::Test::Compact1::__readImpl;
    #endif
};

inline bool operator==(const Derived1& l, const Derived1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Derived1& l, const Derived1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Compact2 : virtual public ::Ice::Object
{
public:

    typedef Compact2Prx ProxyType;
    typedef Compact2Ptr PointerType;

    Compact2()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void baseOp2(::Ice::Int, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Compact2& l, const Compact2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Compact2& l, const Compact2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Optional0 : virtual public ::Ice::Object
{
public:

    typedef Optional0Prx ProxyType;
    typedef Optional0Ptr PointerType;

    Optional0()
    {
    }

    Optional0(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
        firstName(__ice_firstName),
        secondName(__ice_secondName),
        emailAddress(__ice_emailAddress)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string firstName;

    IceUtil::Optional< ::std::string> secondName;

    IceUtil::Optional< ::std::string> emailAddress;

protected:

    virtual ~Optional0() {}
};

inline bool operator==(const Optional0& l, const Optional0& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Optional0& l, const Optional0& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Optional1 : virtual public ::Ice::Object
{
public:

    typedef Optional1Prx ProxyType;
    typedef Optional1Ptr PointerType;

    Optional1()
    {
    }

    Optional1(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
        firstName(__ice_firstName),
        secondName(__ice_secondName),
        emailAddress(__ice_emailAddress)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string firstName;

    IceUtil::Optional< ::std::string> secondName;

    IceUtil::Optional< ::std::string> emailAddress;

protected:

    virtual ~Optional1() {}
};

inline bool operator==(const Optional1& l, const Optional1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Optional1& l, const Optional1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Optional2 : virtual public ::Ice::Object
{
public:

    typedef Optional2Prx ProxyType;
    typedef Optional2Ptr PointerType;

    Optional2()
    {
    }

    Optional2(const ::std::string& __ice_firstName, const ::std::string& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
        firstName(__ice_firstName),
        secondName(__ice_secondName),
        emailAddress(__ice_emailAddress)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string firstName;

    ::std::string secondName;

    IceUtil::Optional< ::std::string> emailAddress;

protected:

    virtual ~Optional2() {}
};

inline bool operator==(const Optional2& l, const Optional2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Optional2& l, const Optional2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Optional3 : virtual public ::Ice::Object
{
public:

    typedef Optional3Prx ProxyType;
    typedef Optional3Ptr PointerType;

    Optional3()
    {
    }

    Optional3(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
        firstName(__ice_firstName),
        secondName(__ice_secondName),
        emailAddress(__ice_emailAddress)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string firstName;

    IceUtil::Optional< ::std::string> secondName;

    IceUtil::Optional< ::std::string> emailAddress;

protected:

    virtual ~Optional3() {}
};

inline bool operator==(const Optional3& l, const Optional3& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Optional3& l, const Optional3& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Optional4 : virtual public ::Ice::Object
{
public:

    typedef Optional4Prx ProxyType;
    typedef Optional4Ptr PointerType;

    Optional4()
    {
    }

    Optional4(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
        firstName(__ice_firstName),
        secondName(__ice_secondName),
        emailAddress(__ice_emailAddress)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string firstName;

    IceUtil::Optional< ::std::string> secondName;

    IceUtil::Optional< ::std::string> emailAddress;

protected:

    virtual ~Optional4() {}
};

inline bool operator==(const Optional4& l, const Optional4& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Optional4& l, const Optional4& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class OptionalParameters0 : virtual public ::Ice::Object
{
public:

    typedef OptionalParameters0Prx ProxyType;
    typedef OptionalParameters0Ptr PointerType;

    OptionalParameters0()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const OptionalParameters0& l, const OptionalParameters0& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalParameters0& l, const OptionalParameters0& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class OptionalParameters1 : virtual public ::Ice::Object
{
public:

    typedef OptionalParameters1Prx ProxyType;
    typedef OptionalParameters1Ptr PointerType;

    OptionalParameters1()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const OptionalParameters1& l, const OptionalParameters1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalParameters1& l, const OptionalParameters1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class OptionalParameters2 : virtual public ::Ice::Object
{
public:

    typedef OptionalParameters2Prx ProxyType;
    typedef OptionalParameters2Ptr PointerType;

    OptionalParameters2()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const OptionalParameters2& l, const OptionalParameters2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalParameters2& l, const OptionalParameters2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class OptionalParameters3 : virtual public ::Ice::Object
{
public:

    typedef OptionalParameters3Prx ProxyType;
    typedef OptionalParameters3Ptr PointerType;

    OptionalParameters3()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const OptionalParameters3& l, const OptionalParameters3& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalParameters3& l, const OptionalParameters3& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class OptionalReturn0 : virtual public ::Ice::Object
{
public:

    typedef OptionalReturn0Prx ProxyType;
    typedef OptionalReturn0Ptr PointerType;

    OptionalReturn0()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const OptionalReturn0& l, const OptionalReturn0& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalReturn0& l, const OptionalReturn0& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class OptionalReturn2 : virtual public ::Ice::Object
{
public:

    typedef OptionalReturn2Prx ProxyType;
    typedef OptionalReturn2Ptr PointerType;

    OptionalReturn2()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const OptionalReturn2& l, const OptionalReturn2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalReturn2& l, const OptionalReturn2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LocalClass : virtual public ::Ice::LocalObject
{
public:

    typedef LocalClassPtr PointerType;

    LocalClass()
    {
    }


    virtual ~LocalClass() {}
};

inline bool operator==(const LocalClass& l, const LocalClass& r)
{
    return static_cast<const ::Ice::LocalObject&>(l) == static_cast<const ::Ice::LocalObject&>(r);
}

inline bool operator<(const LocalClass& l, const LocalClass& r)
{
    return static_cast<const ::Ice::LocalObject&>(l) < static_cast<const ::Ice::LocalObject&>(r);
}

}

namespace Test
{

template<class T>
class CallbackNC_BaseClass1_baseOp1 : public Callback_BaseClass1_baseOp1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass1_baseOp1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass1_baseOp1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass1_baseOp1<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass1_baseOp1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass1_baseOp1<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass1_baseOp1 : public Callback_BaseClass1_baseOp1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass1_baseOp1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass1_baseOp1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass1_baseOp1<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass1_baseOp1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass1_baseOp1Ptr
newCallback_BaseClass1_baseOp1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass1_baseOp1<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass1_baseOp2 : public Callback_BaseClass1_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass1_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass1Prx __proxy = ::Test::BaseClass1Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass1_baseOp2Ptr
newCallback_BaseClass1_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass1_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass1_baseOp2Ptr
newCallback_BaseClass1_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass1_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass1_baseOp2 : public Callback_BaseClass1_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass1_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass1Prx __proxy = ::Test::BaseClass1Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass1_baseOp2Ptr
newCallback_BaseClass1_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass1_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass1_baseOp2Ptr
newCallback_BaseClass1_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass1_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass2_baseOp : public Callback_BaseClass2_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass2_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass2_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass2_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass2_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass2_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass2_baseOp : public Callback_BaseClass2_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass2_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass2_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass2_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass2_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass2_baseOpPtr
newCallback_BaseClass2_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass2_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass2_baseOp2 : public Callback_BaseClass2_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass2_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass2Prx __proxy = ::Test::BaseClass2Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass2_baseOp2Ptr
newCallback_BaseClass2_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass2_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass2_baseOp2Ptr
newCallback_BaseClass2_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass2_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass2_baseOp2 : public Callback_BaseClass2_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass2_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass2Prx __proxy = ::Test::BaseClass2Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass2_baseOp2Ptr
newCallback_BaseClass2_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass2_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass2_baseOp2Ptr
newCallback_BaseClass2_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass2_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass3_baseOp : public Callback_BaseClass3_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass3_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass3_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass3_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass3_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass3_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass3_baseOp : public Callback_BaseClass3_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass3_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass3_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass3_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass3_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass3_baseOpPtr
newCallback_BaseClass3_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass3_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass3_baseOp2 : public Callback_BaseClass3_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass3_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass3Prx __proxy = ::Test::BaseClass3Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass3_baseOp2Ptr
newCallback_BaseClass3_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass3_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass3_baseOp2Ptr
newCallback_BaseClass3_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass3_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass3_baseOp2 : public Callback_BaseClass3_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass3_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass3Prx __proxy = ::Test::BaseClass3Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass3_baseOp2Ptr
newCallback_BaseClass3_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass3_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass3_baseOp2Ptr
newCallback_BaseClass3_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass3_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass4_baseOp : public Callback_BaseClass4_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass4_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass4_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass4_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass4_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass4_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass4_baseOp : public Callback_BaseClass4_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass4_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass4_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass4_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass4_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass4_baseOpPtr
newCallback_BaseClass4_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass4_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass4_baseOp2 : public Callback_BaseClass4_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass4_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass4Prx __proxy = ::Test::BaseClass4Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass4_baseOp2Ptr
newCallback_BaseClass4_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass4_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass4_baseOp2Ptr
newCallback_BaseClass4_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass4_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass4_baseOp2 : public Callback_BaseClass4_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass4_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass4Prx __proxy = ::Test::BaseClass4Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass4_baseOp2Ptr
newCallback_BaseClass4_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass4_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass4_baseOp2Ptr
newCallback_BaseClass4_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass4_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass5_baseOp : public Callback_BaseClass5_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass5_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass5_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass5_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass5_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass5_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass5_baseOp : public Callback_BaseClass5_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass5_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass5_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass5_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass5_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass5_baseOpPtr
newCallback_BaseClass5_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass5_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass5_baseOp2 : public Callback_BaseClass5_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass5_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass5Prx __proxy = ::Test::BaseClass5Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass5_baseOp2Ptr
newCallback_BaseClass5_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass5_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass5_baseOp2Ptr
newCallback_BaseClass5_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass5_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass5_baseOp2 : public Callback_BaseClass5_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass5_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass5Prx __proxy = ::Test::BaseClass5Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass5_baseOp2Ptr
newCallback_BaseClass5_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass5_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass5_baseOp2Ptr
newCallback_BaseClass5_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass5_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass6_baseOp : public Callback_BaseClass6_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass6_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass6_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass6_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass6_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass6_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass6_baseOp : public Callback_BaseClass6_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass6_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass6_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass6_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass6_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass6_baseOpPtr
newCallback_BaseClass6_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass6_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass6_baseOp2 : public Callback_BaseClass6_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass6_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass6Prx __proxy = ::Test::BaseClass6Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass6_baseOp2Ptr
newCallback_BaseClass6_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass6_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass6_baseOp2Ptr
newCallback_BaseClass6_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass6_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass6_baseOp2 : public Callback_BaseClass6_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass6_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass6Prx __proxy = ::Test::BaseClass6Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass6_baseOp2Ptr
newCallback_BaseClass6_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass6_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass6_baseOp2Ptr
newCallback_BaseClass6_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass6_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass7_baseOp : public Callback_BaseClass7_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass7_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass7_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass7_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass7_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass7_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass7_baseOp : public Callback_BaseClass7_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass7_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass7_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass7_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass7_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass7_baseOpPtr
newCallback_BaseClass7_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass7_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass7_baseOp2 : public Callback_BaseClass7_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass7_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass7Prx __proxy = ::Test::BaseClass7Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass7_baseOp2Ptr
newCallback_BaseClass7_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass7_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass7_baseOp2Ptr
newCallback_BaseClass7_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass7_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass7_baseOp2 : public Callback_BaseClass7_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass7_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass7Prx __proxy = ::Test::BaseClass7Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass7_baseOp2Ptr
newCallback_BaseClass7_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass7_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass7_baseOp2Ptr
newCallback_BaseClass7_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass7_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass8_baseOp : public Callback_BaseClass8_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass8_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass8_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass8_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass8_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass8_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass8_baseOp : public Callback_BaseClass8_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass8_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass8_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass8_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass8_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass8_baseOpPtr
newCallback_BaseClass8_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass8_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass8_baseOp2 : public Callback_BaseClass8_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass8_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass8Prx __proxy = ::Test::BaseClass8Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass8_baseOp2Ptr
newCallback_BaseClass8_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass8_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass8_baseOp2Ptr
newCallback_BaseClass8_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass8_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass8_baseOp2 : public Callback_BaseClass8_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass8_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass8Prx __proxy = ::Test::BaseClass8Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass8_baseOp2Ptr
newCallback_BaseClass8_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass8_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass8_baseOp2Ptr
newCallback_BaseClass8_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass8_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass9_baseOp : public Callback_BaseClass9_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass9_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass9_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass9_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass9_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass9_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass9_baseOp : public Callback_BaseClass9_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass9_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass9_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass9_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass9_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass9_baseOpPtr
newCallback_BaseClass9_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass9_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass9_baseOp2 : public Callback_BaseClass9_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass9_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass9Prx __proxy = ::Test::BaseClass9Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass9_baseOp2Ptr
newCallback_BaseClass9_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass9_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass9_baseOp2Ptr
newCallback_BaseClass9_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass9_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass9_baseOp2 : public Callback_BaseClass9_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass9_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass9Prx __proxy = ::Test::BaseClass9Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass9_baseOp2Ptr
newCallback_BaseClass9_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass9_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass9_baseOp2Ptr
newCallback_BaseClass9_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass9_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass10_baseOp : public Callback_BaseClass10_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass10_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass10_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass10_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass10_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass10_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass10_baseOp : public Callback_BaseClass10_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass10_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass10_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass10_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass10_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass10_baseOpPtr
newCallback_BaseClass10_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass10_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass10_baseOp2 : public Callback_BaseClass10_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass10_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass10Prx __proxy = ::Test::BaseClass10Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass10_baseOp2Ptr
newCallback_BaseClass10_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass10_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass10_baseOp2Ptr
newCallback_BaseClass10_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass10_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass10_baseOp2 : public Callback_BaseClass10_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass10_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass10Prx __proxy = ::Test::BaseClass10Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass10_baseOp2Ptr
newCallback_BaseClass10_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass10_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass10_baseOp2Ptr
newCallback_BaseClass10_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass10_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass11_baseOp : public Callback_BaseClass11_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseClass11_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass11_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass11_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass11_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass11_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass11_baseOp : public Callback_BaseClass11_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseClass11_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass11_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass11_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass11_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass11_baseOpPtr
newCallback_BaseClass11_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass11_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_BaseClass11_baseOp2 : public Callback_BaseClass11_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseClass11_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass11Prx __proxy = ::Test::BaseClass11Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_BaseClass11_baseOp2Ptr
newCallback_BaseClass11_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass11_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BaseClass11_baseOp2Ptr
newCallback_BaseClass11_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseClass11_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_BaseClass11_baseOp2 : public Callback_BaseClass11_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseClass11_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::BaseClass11Prx __proxy = ::Test::BaseClass11Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_BaseClass11_baseOp2Ptr
newCallback_BaseClass11_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass11_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BaseClass11_baseOp2Ptr
newCallback_BaseClass11_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseClass11_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Compact1_baseOp : public Callback_Compact1_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Compact1_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact1_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact1_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact1_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact1_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Compact1_baseOp : public Callback_Compact1_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Compact1_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact1_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact1_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact1_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Compact1_baseOpPtr
newCallback_Compact1_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact1_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Compact1_baseOp2 : public Callback_Compact1_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Compact1_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::Compact1Prx __proxy = ::Test::Compact1Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_Compact1_baseOp2Ptr
newCallback_Compact1_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact1_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Compact1_baseOp2Ptr
newCallback_Compact1_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact1_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Compact1_baseOp2 : public Callback_Compact1_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Compact1_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::Compact1Prx __proxy = ::Test::Compact1Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Compact1_baseOp2Ptr
newCallback_Compact1_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact1_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Compact1_baseOp2Ptr
newCallback_Compact1_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact1_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Compact2_baseOp : public Callback_Compact2_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Compact2_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact2_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact2_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact2_baseOp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact2_baseOp<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Compact2_baseOp : public Callback_Compact2_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Compact2_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact2_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact2_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact2_baseOp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Compact2_baseOpPtr
newCallback_Compact2_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact2_baseOp<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Compact2_baseOp2 : public Callback_Compact2_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Compact2_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::Compact2Prx __proxy = ::Test::Compact2Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(s);
        }
    }

    Response response;
};

template<class T> Callback_Compact2_baseOp2Ptr
newCallback_Compact2_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact2_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Compact2_baseOp2Ptr
newCallback_Compact2_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Compact2_baseOp2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Compact2_baseOp2 : public Callback_Compact2_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Compact2_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::Compact2Prx __proxy = ::Test::Compact2Prx::uncheckedCast(__result->getProxy());
        ::std::string s;
        try
        {
            __proxy->end_baseOp2(s, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(s, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Compact2_baseOp2Ptr
newCallback_Compact2_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact2_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Compact2_baseOp2Ptr
newCallback_Compact2_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Compact2_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_OptionalParameters0_op1 : public Callback_OptionalParameters0_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters0_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_OptionalParameters0_op1 : public Callback_OptionalParameters0_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters0_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_OptionalParameters1_op1 : public Callback_OptionalParameters1_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters1_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_OptionalParameters1_op1 : public Callback_OptionalParameters1_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters1_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_OptionalParameters2_op1 : public Callback_OptionalParameters2_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters2_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_OptionalParameters2_op1 : public Callback_OptionalParameters2_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters2_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_OptionalParameters3_op1 : public Callback_OptionalParameters3_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters3_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_OptionalParameters3_op1 : public Callback_OptionalParameters3_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters3_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_OptionalReturn0_op : public Callback_OptionalReturn0_op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&);

    CallbackNC_OptionalReturn0_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::OptionalReturn0Prx __proxy = ::Test::OptionalReturn0Prx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Int> __ret;
        try
        {
            __ret = __proxy->end_op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn0_op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn0_op<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_OptionalReturn0_op : public Callback_OptionalReturn0_op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const CT&);

    Callback_OptionalReturn0_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::OptionalReturn0Prx __proxy = ::Test::OptionalReturn0Prx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Int> __ret;
        try
        {
            __ret = __proxy->end_op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn0_op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn0_op<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_OptionalReturn2_op : public Callback_OptionalReturn2_op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&);

    CallbackNC_OptionalReturn2_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::OptionalReturn2Prx __proxy = ::Test::OptionalReturn2Prx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Int> __ret;
        try
        {
            __ret = __proxy->end_op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn2_op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn2_op<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_OptionalReturn2_op : public Callback_OptionalReturn2_op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const CT&);

    Callback_OptionalReturn2_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::OptionalReturn2Prx __proxy = ::Test::OptionalReturn2Prx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Int> __ret;
        try
        {
            __ret = __proxy->end_op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn2_op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn2_op<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
