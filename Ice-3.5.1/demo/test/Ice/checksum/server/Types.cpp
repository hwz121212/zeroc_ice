// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Types.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Types.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SliceChecksums.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Test__Interface4__opInterface4_name = "opInterface4";

const ::std::string __Test__EmptyClass3__newOp_name = "newOp";

const ::std::string __Test__SimpleClass2__newOp_name = "newOp";

const ::std::string __Test__BaseClass1__baseOp1_name = "baseOp1";

const ::std::string __Test__BaseClass1__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass2__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass2__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass3__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass3__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass4__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass4__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass5__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass5__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass6__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass6__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass7__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass7__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass8__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass9__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass9__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass10__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass10__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass11__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass11__baseOp2_name = "baseOp2";

const ::std::string __Test__Compact1__baseOp_name = "baseOp";

const ::std::string __Test__Compact1__baseOp2_name = "baseOp2";

const ::std::string __Test__Compact2__baseOp_name = "baseOp";

const ::std::string __Test__Compact2__baseOp2_name = "baseOp2";

const ::std::string __Test__OptionalParameters0__op1_name = "op1";

const ::std::string __Test__OptionalParameters1__op1_name = "op1";

const ::std::string __Test__OptionalParameters2__op1_name = "op1";

const ::std::string __Test__OptionalParameters3__op1_name = "op1";

const ::std::string __Test__OptionalReturn0__op_name = "op";

const ::std::string __Test__OptionalReturn2__op_name = "op";

}

namespace
{

const char* __Test__Exception1_name = "Test::Exception1";

struct __F__Test__Exception1 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception1();
    }
};

class __F__Test__Exception1__Init
{
public:

    __F__Test__Exception1__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception1", new __F__Test__Exception1);
    }

    ~__F__Test__Exception1__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception1");
    }
};

const __F__Test__Exception1__Init __F__Test__Exception1__i;

}

Test::Exception1::Exception1(const ::std::string& __ice_str, bool __ice_b) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b)
{
}

Test::Exception1::~Exception1() throw()
{
}

::std::string
Test::Exception1::ice_name() const
{
    return __Test__Exception1_name;
}

Test::Exception1*
Test::Exception1::ice_clone() const
{
    return new Exception1(*this);
}

void
Test::Exception1::ice_throw() const
{
    throw *this;
}

void
Test::Exception1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception1", -1, true);
    __os->write(str);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception2_name = "Test::Exception2";

struct __F__Test__Exception2 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception2();
    }
};

class __F__Test__Exception2__Init
{
public:

    __F__Test__Exception2__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception2", new __F__Test__Exception2);
    }

    ~__F__Test__Exception2__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception2");
    }
};

const __F__Test__Exception2__Init __F__Test__Exception2__i;

}

Test::Exception2::Exception2(const ::std::string& __ice_str, bool __ice_b, ::Ice::Float __ice_f) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b),
    f(__ice_f)
{
}

Test::Exception2::~Exception2() throw()
{
}

::std::string
Test::Exception2::ice_name() const
{
    return __Test__Exception2_name;
}

Test::Exception2*
Test::Exception2::ice_clone() const
{
    return new Exception2(*this);
}

void
Test::Exception2::ice_throw() const
{
    throw *this;
}

void
Test::Exception2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception2", -1, true);
    __os->write(str);
    __os->write(b);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::Exception2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception3_name = "Test::Exception3";

struct __F__Test__Exception3 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception3();
    }
};

class __F__Test__Exception3__Init
{
public:

    __F__Test__Exception3__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception3", new __F__Test__Exception3);
    }

    ~__F__Test__Exception3__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception3");
    }
};

const __F__Test__Exception3__Init __F__Test__Exception3__i;

}

Test::Exception3::Exception3(const ::std::string& __ice_str, ::Ice::Double __ice_b) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b)
{
}

Test::Exception3::~Exception3() throw()
{
}

::std::string
Test::Exception3::ice_name() const
{
    return __Test__Exception3_name;
}

Test::Exception3*
Test::Exception3::ice_clone() const
{
    return new Exception3(*this);
}

void
Test::Exception3::ice_throw() const
{
    throw *this;
}

void
Test::Exception3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception3", -1, true);
    __os->write(str);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception4_name = "Test::Exception4";

struct __F__Test__Exception4 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception4();
    }
};

class __F__Test__Exception4__Init
{
public:

    __F__Test__Exception4__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception4", new __F__Test__Exception4);
    }

    ~__F__Test__Exception4__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception4");
    }
};

const __F__Test__Exception4__Init __F__Test__Exception4__i;

}

Test::Exception4::Exception4(bool __ice_b) :
    ::Ice::UserException(),
    b(__ice_b)
{
}

Test::Exception4::~Exception4() throw()
{
}

::std::string
Test::Exception4::ice_name() const
{
    return __Test__Exception4_name;
}

Test::Exception4*
Test::Exception4::ice_clone() const
{
    return new Exception4(*this);
}

void
Test::Exception4::ice_throw() const
{
    throw *this;
}

void
Test::Exception4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception4", -1, true);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception5_name = "Test::Exception5";

struct __F__Test__Exception5 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception5();
    }
};

class __F__Test__Exception5__Init
{
public:

    __F__Test__Exception5__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception5", new __F__Test__Exception5);
    }

    ~__F__Test__Exception5__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception5");
    }
};

const __F__Test__Exception5__Init __F__Test__Exception5__i;

}

Test::Exception5::Exception5(const ::std::string& __ice_str, bool __ice_b) :
    ::Test::Exception1(__ice_str, __ice_b)
{
}

Test::Exception5::~Exception5() throw()
{
}

::std::string
Test::Exception5::ice_name() const
{
    return __Test__Exception5_name;
}

Test::Exception5*
Test::Exception5::ice_clone() const
{
    return new Exception5(*this);
}

void
Test::Exception5::ice_throw() const
{
    throw *this;
}

void
Test::Exception5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception5", -1, false);
    __os->endWriteSlice();
    ::Test::Exception1::__writeImpl(__os);
}

void
Test::Exception5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Test::Exception1::__readImpl(__is);
}

namespace
{

const char* __Test__OptionalEx0_name = "Test::OptionalEx0";

struct __F__Test__OptionalEx0 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx0();
    }
};

class __F__Test__OptionalEx0__Init
{
public:

    __F__Test__OptionalEx0__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx0", new __F__Test__OptionalEx0);
    }

    ~__F__Test__OptionalEx0__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx0");
    }
};

const __F__Test__OptionalEx0__Init __F__Test__OptionalEx0__i;

}

Test::OptionalEx0::OptionalEx0(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx0::~OptionalEx0() throw()
{
}

::std::string
Test::OptionalEx0::ice_name() const
{
    return __Test__OptionalEx0_name;
}

Test::OptionalEx0*
Test::OptionalEx0::ice_clone() const
{
    return new OptionalEx0(*this);
}

void
Test::OptionalEx0::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx0", -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::OptionalEx0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx1_name = "Test::OptionalEx1";

struct __F__Test__OptionalEx1 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx1();
    }
};

class __F__Test__OptionalEx1__Init
{
public:

    __F__Test__OptionalEx1__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx1", new __F__Test__OptionalEx1);
    }

    ~__F__Test__OptionalEx1__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx1");
    }
};

const __F__Test__OptionalEx1__Init __F__Test__OptionalEx1__i;

}

Test::OptionalEx1::OptionalEx1(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_emailAddress, const IceUtil::Optional< ::std::string>& __ice_secondName) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    emailAddress(__ice_emailAddress),
    secondName(__ice_secondName)
{
}

Test::OptionalEx1::~OptionalEx1() throw()
{
}

::std::string
Test::OptionalEx1::ice_name() const
{
    return __Test__OptionalEx1_name;
}

Test::OptionalEx1*
Test::OptionalEx1::ice_clone() const
{
    return new OptionalEx1(*this);
}

void
Test::OptionalEx1::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx1", -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::OptionalEx1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx2_name = "Test::OptionalEx2";

struct __F__Test__OptionalEx2 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx2();
    }
};

class __F__Test__OptionalEx2__Init
{
public:

    __F__Test__OptionalEx2__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx2", new __F__Test__OptionalEx2);
    }

    ~__F__Test__OptionalEx2__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx2");
    }
};

const __F__Test__OptionalEx2__Init __F__Test__OptionalEx2__i;

}

Test::OptionalEx2::OptionalEx2(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const ::std::string& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx2::~OptionalEx2() throw()
{
}

::std::string
Test::OptionalEx2::ice_name() const
{
    return __Test__OptionalEx2_name;
}

Test::OptionalEx2*
Test::OptionalEx2::ice_clone() const
{
    return new OptionalEx2(*this);
}

void
Test::OptionalEx2::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx2", -1, true);
    __os->write(firstName);
    __os->write(emailAddress);
    __os->write(1, secondName);
    __os->endWriteSlice();
}

void
Test::OptionalEx2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(emailAddress);
    __is->read(1, secondName);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx3_name = "Test::OptionalEx3";

struct __F__Test__OptionalEx3 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx3();
    }
};

class __F__Test__OptionalEx3__Init
{
public:

    __F__Test__OptionalEx3__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx3", new __F__Test__OptionalEx3);
    }

    ~__F__Test__OptionalEx3__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx3");
    }
};

const __F__Test__OptionalEx3__Init __F__Test__OptionalEx3__i;

}

Test::OptionalEx3::OptionalEx3(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress, const IceUtil::Optional< ::std::string>& __ice_phoneNumber) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress),
    phoneNumber(__ice_phoneNumber)
{
}

Test::OptionalEx3::~OptionalEx3() throw()
{
}

::std::string
Test::OptionalEx3::ice_name() const
{
    return __Test__OptionalEx3_name;
}

Test::OptionalEx3*
Test::OptionalEx3::ice_clone() const
{
    return new OptionalEx3(*this);
}

void
Test::OptionalEx3::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx3", -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->write(3, phoneNumber);
    __os->endWriteSlice();
}

void
Test::OptionalEx3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->read(3, phoneNumber);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx4_name = "Test::OptionalEx4";

struct __F__Test__OptionalEx4 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx4();
    }
};

class __F__Test__OptionalEx4__Init
{
public:

    __F__Test__OptionalEx4__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx4", new __F__Test__OptionalEx4);
    }

    ~__F__Test__OptionalEx4__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx4");
    }
};

const __F__Test__OptionalEx4__Init __F__Test__OptionalEx4__i;

}

Test::OptionalEx4::OptionalEx4(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx4::~OptionalEx4() throw()
{
}

::std::string
Test::OptionalEx4::ice_name() const
{
    return __Test__OptionalEx4_name;
}

Test::OptionalEx4*
Test::OptionalEx4::ice_clone() const
{
    return new OptionalEx4(*this);
}

void
Test::OptionalEx4::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx4", -1, true);
    __os->write(firstName);
    __os->write(1, emailAddress);
    __os->write(2, secondName);
    __os->endWriteSlice();
}

void
Test::OptionalEx4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, emailAddress);
    __is->read(2, secondName);
    __is->endReadSlice();
}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Enum4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Enum4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Enum4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Enum4::ice_staticId()
{
    return ::Test::Enum4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Enum4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Enum4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Enum4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Enum4);
}

::IceProxy::Ice::Object*
IceProxy::Test::Enum4::__newInstance() const
{
    return new Enum4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Sequence3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Sequence3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Sequence3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Sequence3::ice_staticId()
{
    return ::Test::Sequence3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Sequence3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Sequence3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Sequence3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Sequence3);
}

::IceProxy::Ice::Object*
IceProxy::Test::Sequence3::__newInstance() const
{
    return new Sequence3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Dictionary4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Dictionary4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Dictionary4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Dictionary4::ice_staticId()
{
    return ::Test::Dictionary4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Dictionary4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Dictionary4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Dictionary4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Dictionary4);
}

::IceProxy::Ice::Object*
IceProxy::Test::Dictionary4::__newInstance() const
{
    return new Dictionary4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Struct5* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Struct5>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Struct5;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Struct5::ice_staticId()
{
    return ::Test::Struct5::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Struct5::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Struct5);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Struct5::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Struct5);
}

::IceProxy::Ice::Object*
IceProxy::Test::Struct5::__newInstance() const
{
    return new Struct5;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Interface1::ice_staticId()
{
    return ::Test::Interface1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface1::__newInstance() const
{
    return new Interface1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Interface2::ice_staticId()
{
    return ::Test::Interface2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface2);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface2::__newInstance() const
{
    return new Interface2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Interface3::ice_staticId()
{
    return ::Test::Interface3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface3);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface3::__newInstance() const
{
    return new Interface3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface4;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::Interface4::opInterface4(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Interface4__opInterface4_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Interface4* __del = dynamic_cast< ::IceDelegate::Test::Interface4*>(__delBase.get());
            __del->opInterface4(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Interface4::begin_opInterface4(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Interface4__opInterface4_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Interface4__opInterface4_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Interface4::end_opInterface4(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Interface4__opInterface4_name);
}

const ::std::string&
IceProxy::Test::Interface4::ice_staticId()
{
    return ::Test::Interface4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface4);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface4::__newInstance() const
{
    return new Interface4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass1::ice_staticId()
{
    return ::Test::EmptyClass1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass1);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass1::__newInstance() const
{
    return new EmptyClass1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass2::ice_staticId()
{
    return ::Test::EmptyClass2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass2);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass2::__newInstance() const
{
    return new EmptyClass2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass3;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::EmptyClass3::newOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__EmptyClass3__newOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::EmptyClass3* __del = dynamic_cast< ::IceDelegate::Test::EmptyClass3*>(__delBase.get());
            __del->newOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::EmptyClass3::begin_newOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__EmptyClass3__newOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__EmptyClass3__newOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::EmptyClass3::end_newOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__EmptyClass3__newOp_name);
}

const ::std::string&
IceProxy::Test::EmptyClass3::ice_staticId()
{
    return ::Test::EmptyClass3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass3);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass3::__newInstance() const
{
    return new EmptyClass3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass4::ice_staticId()
{
    return ::Test::EmptyClass4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass4);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass4::__newInstance() const
{
    return new EmptyClass4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass5* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass5;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass5::ice_staticId()
{
    return ::Test::EmptyClass5::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass5::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass5);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass5::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass5);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass5::__newInstance() const
{
    return new EmptyClass5;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass1::ice_staticId()
{
    return ::Test::SimpleClass1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass1);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass1::__newInstance() const
{
    return new SimpleClass1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass2;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::SimpleClass2::newOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__SimpleClass2__newOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::SimpleClass2* __del = dynamic_cast< ::IceDelegate::Test::SimpleClass2*>(__delBase.get());
            __del->newOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::SimpleClass2::begin_newOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__SimpleClass2__newOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__SimpleClass2__newOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::SimpleClass2::end_newOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__SimpleClass2__newOp_name);
}

const ::std::string&
IceProxy::Test::SimpleClass2::ice_staticId()
{
    return ::Test::SimpleClass2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass2);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass2::__newInstance() const
{
    return new SimpleClass2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass3::ice_staticId()
{
    return ::Test::SimpleClass3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass3);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass3::__newInstance() const
{
    return new SimpleClass3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass4::ice_staticId()
{
    return ::Test::SimpleClass4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass4);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass4::__newInstance() const
{
    return new SimpleClass4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass5* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass5;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass5::ice_staticId()
{
    return ::Test::SimpleClass5::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass5::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass5);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass5::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass5);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass5::__newInstance() const
{
    return new SimpleClass5;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass6* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass6>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass6;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass6::ice_staticId()
{
    return ::Test::SimpleClass6::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass6::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass6);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass6::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass6);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass6::__newInstance() const
{
    return new SimpleClass6;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass7* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass7>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass7;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass7::ice_staticId()
{
    return ::Test::SimpleClass7::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass7::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass7);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass7::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass7);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass7::__newInstance() const
{
    return new SimpleClass7;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Exception6* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Exception6>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Exception6;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Exception6::ice_staticId()
{
    return ::Test::Exception6::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Exception6::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Exception6);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Exception6::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Exception6);
}

::IceProxy::Ice::Object*
IceProxy::Test::Exception6::__newInstance() const
{
    return new Exception6;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass1;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass1::baseOp1(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass1__baseOp1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass1* __del = dynamic_cast< ::IceDelegate::Test::BaseClass1*>(__delBase.get());
            __del->baseOp1(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass1::begin_baseOp1(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass1__baseOp1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass1__baseOp1_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass1::end_baseOp1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass1__baseOp1_name);
}

void
IceProxy::Test::BaseClass1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass1__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass1__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass1* __del = dynamic_cast< ::IceDelegate::Test::BaseClass1*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass1::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass1__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass1__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass1__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass1::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass1__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass1::ice_staticId()
{
    return ::Test::BaseClass1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass1);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass1::__newInstance() const
{
    return new BaseClass1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass2;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::Test::BaseClass2::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass2__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass2__baseOp_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass2* __del = dynamic_cast< ::IceDelegate::Test::BaseClass2*>(__delBase.get());
            return __del->baseOp(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass2::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass2__baseOp_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass2__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass2__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Test::BaseClass2::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass2__baseOp_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::BaseClass2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass2__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass2__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass2* __del = dynamic_cast< ::IceDelegate::Test::BaseClass2*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass2::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass2__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass2__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass2__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass2::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass2__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass2::ice_staticId()
{
    return ::Test::BaseClass2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass2);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass2::__newInstance() const
{
    return new BaseClass2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass3;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass3::baseOp(const ::Ice::ObjectPtr& o, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass3__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass3* __del = dynamic_cast< ::IceDelegate::Test::BaseClass3*>(__delBase.get());
            __del->baseOp(o, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass3::begin_baseOp(const ::Ice::ObjectPtr& o, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass3__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass3__baseOp_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(o);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass3::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass3__baseOp_name);
}

void
IceProxy::Test::BaseClass3::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass3__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass3__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass3* __del = dynamic_cast< ::IceDelegate::Test::BaseClass3*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass3::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass3__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass3__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass3__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass3::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass3__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass3::ice_staticId()
{
    return ::Test::BaseClass3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass3);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass3::__newInstance() const
{
    return new BaseClass3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass4;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass4::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass4__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass4* __del = dynamic_cast< ::IceDelegate::Test::BaseClass4*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass4::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass4__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass4__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass4::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass4__baseOp_name);
}

void
IceProxy::Test::BaseClass4::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass4__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass4__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass4* __del = dynamic_cast< ::IceDelegate::Test::BaseClass4*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass4::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass4__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass4__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass4__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass4::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass4__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Test::Exception2&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass4::ice_staticId()
{
    return ::Test::BaseClass4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass4);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass4::__newInstance() const
{
    return new BaseClass4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass5* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass5;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass5::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass5__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass5* __del = dynamic_cast< ::IceDelegate::Test::BaseClass5*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass5::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass5__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass5__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass5::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass5__baseOp_name);
}

void
IceProxy::Test::BaseClass5::baseOp2(::Ice::Int i, const ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass5__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass5__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass5* __del = dynamic_cast< ::IceDelegate::Test::BaseClass5*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass5::begin_baseOp2(::Ice::Int i, const ::std::string& s, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass5__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass5__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass5__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __os->write(s);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass5::end_baseOp2(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass5__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass5::ice_staticId()
{
    return ::Test::BaseClass5::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass5::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass5);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass5::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass5);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass5::__newInstance() const
{
    return new BaseClass5;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass6* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass6>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass6;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass6::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass6__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass6* __del = dynamic_cast< ::IceDelegate::Test::BaseClass6*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass6::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass6__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass6__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass6::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass6__baseOp_name);
}

void
IceProxy::Test::BaseClass6::baseOp2(::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass6__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass6__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass6* __del = dynamic_cast< ::IceDelegate::Test::BaseClass6*>(__delBase.get());
            __del->baseOp2(s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass6::begin_baseOp2(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass6__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass6__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass6__baseOp2_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass6::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass6__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass6::ice_staticId()
{
    return ::Test::BaseClass6::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass6::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass6);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass6::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass6);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass6::__newInstance() const
{
    return new BaseClass6;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass7* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass7>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass7;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass7::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass7__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass7* __del = dynamic_cast< ::IceDelegate::Test::BaseClass7*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass7::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass7__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass7__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass7::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass7__baseOp_name);
}

void
IceProxy::Test::BaseClass7::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass7__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass7__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass7* __del = dynamic_cast< ::IceDelegate::Test::BaseClass7*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass7::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass7__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass7__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass7__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass7::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass7__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass7::ice_staticId()
{
    return ::Test::BaseClass7::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass7::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass7);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass7::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass7);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass7::__newInstance() const
{
    return new BaseClass7;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass8* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass8>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass8;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass8::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass8__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass8__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass8* __del = dynamic_cast< ::IceDelegate::Test::BaseClass8*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass8::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass8__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass8__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass8__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass8::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass8__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass8::ice_staticId()
{
    return ::Test::BaseClass8::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass8::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass8);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass8::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass8);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass8::__newInstance() const
{
    return new BaseClass8;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass9* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass9>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass9;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass9::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass9__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass9* __del = dynamic_cast< ::IceDelegate::Test::BaseClass9*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass9::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass9__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass9__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass9::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass9__baseOp_name);
}

void
IceProxy::Test::BaseClass9::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass9__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass9__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass9* __del = dynamic_cast< ::IceDelegate::Test::BaseClass9*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass9::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass9__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass9__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass9__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass9::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass9__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass9::ice_staticId()
{
    return ::Test::BaseClass9::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass9::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass9);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass9::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass9);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass9::__newInstance() const
{
    return new BaseClass9;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass10* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass10>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass10;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass10::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass10__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass10* __del = dynamic_cast< ::IceDelegate::Test::BaseClass10*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass10::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass10__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass10__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass10::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass10__baseOp_name);
}

void
IceProxy::Test::BaseClass10::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass10__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass10__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass10* __del = dynamic_cast< ::IceDelegate::Test::BaseClass10*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass10::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass10__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass10__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass10__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass10::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass10__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass10::ice_staticId()
{
    return ::Test::BaseClass10::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass10::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass10);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass10::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass10);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass10::__newInstance() const
{
    return new BaseClass10;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass11* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass11>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass11;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass11::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass11__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass11* __del = dynamic_cast< ::IceDelegate::Test::BaseClass11*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass11::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass11__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass11__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass11::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass11__baseOp_name);
}

void
IceProxy::Test::BaseClass11::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass11__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass11__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass11* __del = dynamic_cast< ::IceDelegate::Test::BaseClass11*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass11::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass11__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass11__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass11__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass11::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass11__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass11::ice_staticId()
{
    return ::Test::BaseClass11::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass11::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass11);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass11::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass11);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass11::__newInstance() const
{
    return new BaseClass11;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Compact1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Compact1;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::Compact1::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact1__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact1* __del = dynamic_cast< ::IceDelegate::Test::Compact1*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact1::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact1__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact1__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact1::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Compact1__baseOp_name);
}

void
IceProxy::Test::Compact1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact1__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Compact1__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact1* __del = dynamic_cast< ::IceDelegate::Test::Compact1*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact1::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Compact1__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact1__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact1__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact1::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Compact1__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::Compact1::ice_staticId()
{
    return ::Test::Compact1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Compact1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Compact1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Compact1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Compact1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Compact1::__newInstance() const
{
    return new Compact1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Derived1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Derived1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Derived1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Derived1::ice_staticId()
{
    return ::Test::Derived1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Derived1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Derived1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Derived1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Derived1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Derived1::__newInstance() const
{
    return new Derived1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Compact2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Compact2;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::Compact2::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact2__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact2* __del = dynamic_cast< ::IceDelegate::Test::Compact2*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact2::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact2__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact2__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact2::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Compact2__baseOp_name);
}

void
IceProxy::Test::Compact2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact2__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Compact2__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact2* __del = dynamic_cast< ::IceDelegate::Test::Compact2*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact2::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Compact2__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact2__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact2__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact2::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Compact2__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::Compact2::ice_staticId()
{
    return ::Test::Compact2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Compact2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Compact2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Compact2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Compact2);
}

::IceProxy::Ice::Object*
IceProxy::Test::Compact2::__newInstance() const
{
    return new Compact2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional0* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional0>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional0;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional0::ice_staticId()
{
    return ::Test::Optional0::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional0::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional0);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional0::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional0);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional0::__newInstance() const
{
    return new Optional0;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional1::ice_staticId()
{
    return ::Test::Optional1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional1::__newInstance() const
{
    return new Optional1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional2::ice_staticId()
{
    return ::Test::Optional2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional2);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional2::__newInstance() const
{
    return new Optional2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional3::ice_staticId()
{
    return ::Test::Optional3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional3);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional3::__newInstance() const
{
    return new Optional3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional4::ice_staticId()
{
    return ::Test::Optional4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional4);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional4::__newInstance() const
{
    return new Optional4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters0* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters0>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters0;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters0::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters0__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters0* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters0*>(__delBase.get());
            __del->op1(firstName, secondName, emailAddress, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters0::begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters0__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters0__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters0::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters0__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters0::ice_staticId()
{
    return ::Test::OptionalParameters0::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters0::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters0);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters0::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters0);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters0::__newInstance() const
{
    return new OptionalParameters0;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters1;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters1::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters1__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters1* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters1*>(__delBase.get());
            __del->op1(firstName, emailAddress, secondName, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters1::begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters1__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters1__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters1::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters1__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters1::ice_staticId()
{
    return ::Test::OptionalParameters1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters1);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters1::__newInstance() const
{
    return new OptionalParameters1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters2;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters2::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters2__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters2* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters2*>(__delBase.get());
            __del->op1(firstName, emailAddress, secondName, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters2::begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters2__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters2__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters2::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters2__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters2::ice_staticId()
{
    return ::Test::OptionalParameters2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters2);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters2::__newInstance() const
{
    return new OptionalParameters2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters3;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters3::op1(const ::std::string& firstName, const ::std::string& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters3__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters3* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters3*>(__delBase.get());
            __del->op1(firstName, emailAddress, secondName, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters3::begin_op1(const ::std::string& firstName, const ::std::string& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters3__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters3__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(emailAddress);
        __os->write(1, secondName);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters3::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters3__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters3::ice_staticId()
{
    return ::Test::OptionalParameters3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters3);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters3::__newInstance() const
{
    return new OptionalParameters3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalReturn0* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn0>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalReturn0;
        v->__copyFrom(proxy);
    }
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn0::op(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalReturn0__op_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__OptionalReturn0__op_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalReturn0* __del = dynamic_cast< ::IceDelegate::Test::OptionalReturn0*>(__delBase.get());
            return __del->op(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalReturn0::begin_op(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__OptionalReturn0__op_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalReturn0__op_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalReturn0__op_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn0::end_op(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__OptionalReturn0__op_name);
    IceUtil::Optional< ::Ice::Int> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(1, __ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::OptionalReturn0::ice_staticId()
{
    return ::Test::OptionalReturn0::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalReturn0::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalReturn0);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalReturn0::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalReturn0);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalReturn0::__newInstance() const
{
    return new OptionalReturn0;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalReturn2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalReturn2;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::Test::OptionalReturn2::op(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalReturn2__op_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__OptionalReturn2__op_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalReturn2* __del = dynamic_cast< ::IceDelegate::Test::OptionalReturn2*>(__delBase.get());
            return __del->op(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalReturn2::begin_op(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__OptionalReturn2__op_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalReturn2__op_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalReturn2__op_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Test::OptionalReturn2::end_op(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__OptionalReturn2__op_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::OptionalReturn2::ice_staticId()
{
    return ::Test::OptionalReturn2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalReturn2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalReturn2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalReturn2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalReturn2);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalReturn2::__newInstance() const
{
    return new OptionalReturn2;
}

void
IceDelegateM::Test::Interface4::opInterface4(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Interface4__opInterface4_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::EmptyClass3::newOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__EmptyClass3__newOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::SimpleClass2::newOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__SimpleClass2__newOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass1::baseOp1(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass1__baseOp1_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass1__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Test::BaseClass2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass2__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass2__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass3::baseOp(const ::Ice::ObjectPtr& o, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass3__baseOp_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(o);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass3::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass3__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass4::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass4__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass4::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass4__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Test::Exception2&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass5::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass5__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass5::baseOp2(::Ice::Int i, const ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass5__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __os->write(s);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass6::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass6__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass6::baseOp2(::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass6__baseOp2_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass7::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass7__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass7::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass7__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass8::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass8__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass9::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass9__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass9::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass9__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass10::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass10__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass10::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass10__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass11::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass11__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass11::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass11__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Compact1::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact1__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Compact1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact1__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Compact2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact2__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Compact2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact2__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::OptionalParameters0::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters0__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::OptionalParameters1::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters1__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::OptionalParameters2::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters2__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::OptionalParameters3::op1(const ::std::string& firstName, const ::std::string& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters3__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(emailAddress);
        __os->write(1, secondName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

IceUtil::Optional< ::Ice::Int>
IceDelegateM::Test::OptionalReturn0::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalReturn0__op_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    IceUtil::Optional< ::Ice::Int> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(1, __ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Test::OptionalReturn2::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalReturn2__op_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::Test::Interface4::opInterface4(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Interface4* servant = dynamic_cast< ::Test::Interface4*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->opInterface4(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Interface4__opInterface4_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::EmptyClass3::newOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::EmptyClass3* servant = dynamic_cast< ::Test::EmptyClass3*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->newOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__EmptyClass3__newOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::SimpleClass2::newOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::SimpleClass2* servant = dynamic_cast< ::Test::SimpleClass2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->newOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__SimpleClass2__newOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass1::baseOp1(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass1* servant = dynamic_cast< ::Test::BaseClass1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp1(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass1__baseOp1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass1* servant = dynamic_cast< ::Test::BaseClass1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass1__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::Test::BaseClass2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass2* servant = dynamic_cast< ::Test::BaseClass2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass2__baseOp_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Test::BaseClass2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass2* servant = dynamic_cast< ::Test::BaseClass2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass2__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass3::baseOp(const ::Ice::ObjectPtr& o, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::ObjectPtr& __p_o, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_o(__p_o)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass3* servant = dynamic_cast< ::Test::BaseClass3*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_m_o, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Ice::ObjectPtr& _m_o;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass3__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(o, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass3::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass3* servant = dynamic_cast< ::Test::BaseClass3*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass3__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass4::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass4* servant = dynamic_cast< ::Test::BaseClass4*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass4__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass4::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass4* servant = dynamic_cast< ::Test::BaseClass4*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass4__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Test::Exception2&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass5::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass5* servant = dynamic_cast< ::Test::BaseClass5*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass5__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass5::baseOp2(::Ice::Int i, const ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, const ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass5* servant = dynamic_cast< ::Test::BaseClass5*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        const ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass5__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass6::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass6* servant = dynamic_cast< ::Test::BaseClass6*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass6__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass6::baseOp2(::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass6* servant = dynamic_cast< ::Test::BaseClass6*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass6__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass7::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass7* servant = dynamic_cast< ::Test::BaseClass7*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass7__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass7::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass7* servant = dynamic_cast< ::Test::BaseClass7*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp2(_m_i, _m_s, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass7__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass8::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass8* servant = dynamic_cast< ::Test::BaseClass8*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass8__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass9::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass9* servant = dynamic_cast< ::Test::BaseClass9*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass9__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass9::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass9* servant = dynamic_cast< ::Test::BaseClass9*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass9__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass10::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass10* servant = dynamic_cast< ::Test::BaseClass10*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass10__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass10::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass10* servant = dynamic_cast< ::Test::BaseClass10*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass10__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass11::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass11* servant = dynamic_cast< ::Test::BaseClass11*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass11__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass11::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass11* servant = dynamic_cast< ::Test::BaseClass11*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass11__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact1::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact1* servant = dynamic_cast< ::Test::Compact1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact1__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact1* servant = dynamic_cast< ::Test::Compact1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact1__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact2* servant = dynamic_cast< ::Test::Compact2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact2__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact2* servant = dynamic_cast< ::Test::Compact2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact2__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters0::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const IceUtil::Optional< ::std::string>& __p_secondName, const IceUtil::Optional< ::std::string>& __p_emailAddress, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_secondName(__p_secondName),
            _m_emailAddress(__p_emailAddress)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters0* servant = dynamic_cast< ::Test::OptionalParameters0*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_secondName, _m_emailAddress, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const IceUtil::Optional< ::std::string>& _m_secondName;
        const IceUtil::Optional< ::std::string>& _m_emailAddress;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters0__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, secondName, emailAddress, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters1::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const IceUtil::Optional< ::std::string>& __p_emailAddress, const IceUtil::Optional< ::std::string>& __p_secondName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_emailAddress(__p_emailAddress),
            _m_secondName(__p_secondName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters1* servant = dynamic_cast< ::Test::OptionalParameters1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_emailAddress, _m_secondName, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const IceUtil::Optional< ::std::string>& _m_emailAddress;
        const IceUtil::Optional< ::std::string>& _m_secondName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters1__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, emailAddress, secondName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters2::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const IceUtil::Optional< ::std::string>& __p_emailAddress, const IceUtil::Optional< ::std::string>& __p_secondName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_emailAddress(__p_emailAddress),
            _m_secondName(__p_secondName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters2* servant = dynamic_cast< ::Test::OptionalParameters2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_emailAddress, _m_secondName, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const IceUtil::Optional< ::std::string>& _m_emailAddress;
        const IceUtil::Optional< ::std::string>& _m_secondName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters2__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, emailAddress, secondName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters3::op1(const ::std::string& firstName, const ::std::string& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const ::std::string& __p_emailAddress, const IceUtil::Optional< ::std::string>& __p_secondName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_emailAddress(__p_emailAddress),
            _m_secondName(__p_secondName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters3* servant = dynamic_cast< ::Test::OptionalParameters3*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_emailAddress, _m_secondName, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const ::std::string& _m_emailAddress;
        const IceUtil::Optional< ::std::string>& _m_secondName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters3__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, emailAddress, secondName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

IceUtil::Optional< ::Ice::Int>
IceDelegateD::Test::OptionalReturn0::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(IceUtil::Optional< ::Ice::Int>& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalReturn0* servant = dynamic_cast< ::Test::OptionalReturn0*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->op(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        IceUtil::Optional< ::Ice::Int>& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalReturn0__op_name, ::Ice::Normal, __context);
    IceUtil::Optional< ::Ice::Int> __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Test::OptionalReturn2::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalReturn2* servant = dynamic_cast< ::Test::OptionalReturn2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->op(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalReturn2__op_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Object* Test::upCast(::Test::Enum4* p) { return p; }
::Ice::ObjectPtr
Test::Enum4::ice_clone() const
{
    ::Ice::Object* __p = new Enum4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Enum4_ids[2] =
{
    "::Ice::Object",
    "::Test::Enum4"
};

}

bool
Test::Enum4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Enum4_ids, __Test__Enum4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Enum4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Enum4_ids[0], &__Test__Enum4_ids[2]);
}

const ::std::string&
Test::Enum4::ice_id(const ::Ice::Current&) const
{
    return __Test__Enum4_ids[1];
}

const ::std::string&
Test::Enum4::ice_staticId()
{
    return __Test__Enum4_ids[1];
}

void
Test::Enum4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Enum4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Enum4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Enum4::ice_staticId());
        return new ::Test::Enum4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Enum4_Ptr = new __F__Test__Enum4;

class __F__Test__Enum4__Init
{
public:

    __F__Test__Enum4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Enum4::ice_staticId(), __F__Test__Enum4_Ptr);
    }

    ~__F__Test__Enum4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Enum4::ice_staticId());
    }
};

const __F__Test__Enum4__Init __F__Test__Enum4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Enum4::ice_factory()
{
    return __F__Test__Enum4_Ptr;
}

void 
Test::__patch(Enum4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Enum4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Enum4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Sequence3* p) { return p; }
::Ice::ObjectPtr
Test::Sequence3::ice_clone() const
{
    ::Ice::Object* __p = new Sequence3(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Sequence3_ids[2] =
{
    "::Ice::Object",
    "::Test::Sequence3"
};

}

bool
Test::Sequence3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Sequence3_ids, __Test__Sequence3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Sequence3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Sequence3_ids[0], &__Test__Sequence3_ids[2]);
}

const ::std::string&
Test::Sequence3::ice_id(const ::Ice::Current&) const
{
    return __Test__Sequence3_ids[1];
}

const ::std::string&
Test::Sequence3::ice_staticId()
{
    return __Test__Sequence3_ids[1];
}

void
Test::Sequence3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Sequence3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Sequence3 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Sequence3::ice_staticId());
        return new ::Test::Sequence3;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Sequence3_Ptr = new __F__Test__Sequence3;

class __F__Test__Sequence3__Init
{
public:

    __F__Test__Sequence3__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Sequence3::ice_staticId(), __F__Test__Sequence3_Ptr);
    }

    ~__F__Test__Sequence3__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Sequence3::ice_staticId());
    }
};

const __F__Test__Sequence3__Init __F__Test__Sequence3__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Sequence3::ice_factory()
{
    return __F__Test__Sequence3_Ptr;
}

void 
Test::__patch(Sequence3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Sequence3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Sequence3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Dictionary4* p) { return p; }
::Ice::ObjectPtr
Test::Dictionary4::ice_clone() const
{
    ::Ice::Object* __p = new Dictionary4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Dictionary4_ids[2] =
{
    "::Ice::Object",
    "::Test::Dictionary4"
};

}

bool
Test::Dictionary4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Dictionary4_ids, __Test__Dictionary4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Dictionary4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Dictionary4_ids[0], &__Test__Dictionary4_ids[2]);
}

const ::std::string&
Test::Dictionary4::ice_id(const ::Ice::Current&) const
{
    return __Test__Dictionary4_ids[1];
}

const ::std::string&
Test::Dictionary4::ice_staticId()
{
    return __Test__Dictionary4_ids[1];
}

void
Test::Dictionary4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Dictionary4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Dictionary4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Dictionary4::ice_staticId());
        return new ::Test::Dictionary4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Dictionary4_Ptr = new __F__Test__Dictionary4;

class __F__Test__Dictionary4__Init
{
public:

    __F__Test__Dictionary4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Dictionary4::ice_staticId(), __F__Test__Dictionary4_Ptr);
    }

    ~__F__Test__Dictionary4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Dictionary4::ice_staticId());
    }
};

const __F__Test__Dictionary4__Init __F__Test__Dictionary4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Dictionary4::ice_factory()
{
    return __F__Test__Dictionary4_Ptr;
}

void 
Test::__patch(Dictionary4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Dictionary4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Dictionary4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Struct5* p) { return p; }
::Ice::ObjectPtr
Test::Struct5::ice_clone() const
{
    ::Ice::Object* __p = new Struct5(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Struct5_ids[2] =
{
    "::Ice::Object",
    "::Test::Struct5"
};

}

bool
Test::Struct5::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Struct5_ids, __Test__Struct5_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Struct5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Struct5_ids[0], &__Test__Struct5_ids[2]);
}

const ::std::string&
Test::Struct5::ice_id(const ::Ice::Current&) const
{
    return __Test__Struct5_ids[1];
}

const ::std::string&
Test::Struct5::ice_staticId()
{
    return __Test__Struct5_ids[1];
}

void
Test::Struct5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Struct5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Struct5 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Struct5::ice_staticId());
        return new ::Test::Struct5;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Struct5_Ptr = new __F__Test__Struct5;

class __F__Test__Struct5__Init
{
public:

    __F__Test__Struct5__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Struct5::ice_staticId(), __F__Test__Struct5_Ptr);
    }

    ~__F__Test__Struct5__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Struct5::ice_staticId());
    }
};

const __F__Test__Struct5__Init __F__Test__Struct5__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Struct5::ice_factory()
{
    return __F__Test__Struct5_Ptr;
}

void 
Test::__patch(Struct5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Struct5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Struct5::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Interface1* p) { return p; }

namespace
{
const ::std::string __Test__Interface1_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface1"
};

}

bool
Test::Interface1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface1_ids, __Test__Interface1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Interface1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface1_ids[0], &__Test__Interface1_ids[2]);
}

const ::std::string&
Test::Interface1::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface1_ids[1];
}

const ::std::string&
Test::Interface1::ice_staticId()
{
    return __Test__Interface1_ids[1];
}

void
Test::Interface1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(Interface1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Interface2* p) { return p; }
::Ice::ObjectPtr
Test::Interface2::ice_clone() const
{
    ::Ice::Object* __p = new Interface2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Interface2_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface2"
};

}

bool
Test::Interface2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface2_ids, __Test__Interface2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Interface2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface2_ids[0], &__Test__Interface2_ids[2]);
}

const ::std::string&
Test::Interface2::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface2_ids[1];
}

const ::std::string&
Test::Interface2::ice_staticId()
{
    return __Test__Interface2_ids[1];
}

void
Test::Interface2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Interface2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Interface2::ice_staticId());
        return new ::Test::Interface2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Interface2_Ptr = new __F__Test__Interface2;

class __F__Test__Interface2__Init
{
public:

    __F__Test__Interface2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Interface2::ice_staticId(), __F__Test__Interface2_Ptr);
    }

    ~__F__Test__Interface2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Interface2::ice_staticId());
    }
};

const __F__Test__Interface2__Init __F__Test__Interface2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Interface2::ice_factory()
{
    return __F__Test__Interface2_Ptr;
}

void 
Test::__patch(Interface2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Interface3* p) { return p; }

namespace
{
const ::std::string __Test__Interface3_ids[3] =
{
    "::Ice::Object",
    "::Test::Interface1",
    "::Test::Interface3"
};

}

bool
Test::Interface3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface3_ids, __Test__Interface3_ids + 3, _s);
}

::std::vector< ::std::string>
Test::Interface3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface3_ids[0], &__Test__Interface3_ids[3]);
}

const ::std::string&
Test::Interface3::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface3_ids[2];
}

const ::std::string&
Test::Interface3::ice_staticId()
{
    return __Test__Interface3_ids[2];
}

void
Test::Interface3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(Interface3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Interface4* p) { return p; }

namespace
{
const ::std::string __Test__Interface4_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface4"
};

}

bool
Test::Interface4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface4_ids, __Test__Interface4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Interface4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface4_ids[0], &__Test__Interface4_ids[2]);
}

const ::std::string&
Test::Interface4::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface4_ids[1];
}

const ::std::string&
Test::Interface4::ice_staticId()
{
    return __Test__Interface4_ids[1];
}

::Ice::DispatchStatus
Test::Interface4::___opInterface4(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    opInterface4(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__Interface4_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opInterface4"
};

}

::Ice::DispatchStatus
Test::Interface4::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Interface4_all, __Test__Interface4_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Interface4_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___opInterface4(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Interface4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(Interface4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass1* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass1::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass1"
};

}

bool
Test::EmptyClass1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass1_ids, __Test__EmptyClass1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass1_ids[0], &__Test__EmptyClass1_ids[2]);
}

const ::std::string&
Test::EmptyClass1::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass1_ids[1];
}

const ::std::string&
Test::EmptyClass1::ice_staticId()
{
    return __Test__EmptyClass1_ids[1];
}

void
Test::EmptyClass1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__EmptyClass1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass1::ice_staticId());
        return new ::Test::EmptyClass1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass1_Ptr = new __F__Test__EmptyClass1;

class __F__Test__EmptyClass1__Init
{
public:

    __F__Test__EmptyClass1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass1::ice_staticId(), __F__Test__EmptyClass1_Ptr);
    }

    ~__F__Test__EmptyClass1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass1::ice_staticId());
    }
};

const __F__Test__EmptyClass1__Init __F__Test__EmptyClass1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass1::ice_factory()
{
    return __F__Test__EmptyClass1_Ptr;
}

void 
Test::__patch(EmptyClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass2* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass2::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass2"
};

}

bool
Test::EmptyClass2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass2_ids, __Test__EmptyClass2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass2_ids[0], &__Test__EmptyClass2_ids[2]);
}

const ::std::string&
Test::EmptyClass2::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass2_ids[1];
}

const ::std::string&
Test::EmptyClass2::ice_staticId()
{
    return __Test__EmptyClass2_ids[1];
}

void
Test::EmptyClass2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(d);
    __os->endWriteSlice();
}

void
Test::EmptyClass2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(d);
    __is->endReadSlice();
}

namespace
{

class __F__Test__EmptyClass2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass2::ice_staticId());
        return new ::Test::EmptyClass2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass2_Ptr = new __F__Test__EmptyClass2;

class __F__Test__EmptyClass2__Init
{
public:

    __F__Test__EmptyClass2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass2::ice_staticId(), __F__Test__EmptyClass2_Ptr);
    }

    ~__F__Test__EmptyClass2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass2::ice_staticId());
    }
};

const __F__Test__EmptyClass2__Init __F__Test__EmptyClass2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass2::ice_factory()
{
    return __F__Test__EmptyClass2_Ptr;
}

void 
Test::__patch(EmptyClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass3* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass3::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__EmptyClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass3"
};

}

bool
Test::EmptyClass3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass3_ids, __Test__EmptyClass3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass3_ids[0], &__Test__EmptyClass3_ids[2]);
}

const ::std::string&
Test::EmptyClass3::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass3_ids[1];
}

const ::std::string&
Test::EmptyClass3::ice_staticId()
{
    return __Test__EmptyClass3_ids[1];
}

::Ice::DispatchStatus
Test::EmptyClass3::___newOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    newOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__EmptyClass3_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newOp"
};

}

::Ice::DispatchStatus
Test::EmptyClass3::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__EmptyClass3_all, __Test__EmptyClass3_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__EmptyClass3_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___newOp(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::EmptyClass3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(EmptyClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass4* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass4::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass4_ids[3] =
{
    "::Ice::Object",
    "::Test::EmptyClass1",
    "::Test::EmptyClass4"
};

}

bool
Test::EmptyClass4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass4_ids, __Test__EmptyClass4_ids + 3, _s);
}

::std::vector< ::std::string>
Test::EmptyClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass4_ids[0], &__Test__EmptyClass4_ids[3]);
}

const ::std::string&
Test::EmptyClass4::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass4_ids[2];
}

const ::std::string&
Test::EmptyClass4::ice_staticId()
{
    return __Test__EmptyClass4_ids[2];
}

void
Test::EmptyClass4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::Test::EmptyClass1::__writeImpl(__os);
}

void
Test::EmptyClass4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Test::EmptyClass1::__readImpl(__is);
}

namespace
{

class __F__Test__EmptyClass4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass4::ice_staticId());
        return new ::Test::EmptyClass4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass4_Ptr = new __F__Test__EmptyClass4;

class __F__Test__EmptyClass4__Init
{
public:

    __F__Test__EmptyClass4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass4::ice_staticId(), __F__Test__EmptyClass4_Ptr);
    }

    ~__F__Test__EmptyClass4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass4::ice_staticId());
    }
};

const __F__Test__EmptyClass4__Init __F__Test__EmptyClass4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass4::ice_factory()
{
    return __F__Test__EmptyClass4_Ptr;
}

void 
Test::__patch(EmptyClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass5* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass5::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__EmptyClass5_ids[3] =
{
    "::Ice::Object",
    "::Test::EmptyClass5",
    "::Test::Interface1"
};

}

bool
Test::EmptyClass5::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass5_ids, __Test__EmptyClass5_ids + 3, _s);
}

::std::vector< ::std::string>
Test::EmptyClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass5_ids[0], &__Test__EmptyClass5_ids[3]);
}

const ::std::string&
Test::EmptyClass5::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass5_ids[1];
}

const ::std::string&
Test::EmptyClass5::ice_staticId()
{
    return __Test__EmptyClass5_ids[1];
}

void
Test::EmptyClass5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(EmptyClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass5::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass1* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass1::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass1"
};

}

bool
Test::SimpleClass1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass1_ids, __Test__SimpleClass1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass1_ids[0], &__Test__SimpleClass1_ids[2]);
}

const ::std::string&
Test::SimpleClass1::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass1_ids[1];
}

const ::std::string&
Test::SimpleClass1::ice_staticId()
{
    return __Test__SimpleClass1_ids[1];
}

void
Test::SimpleClass1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass1::ice_staticId());
        return new ::Test::SimpleClass1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass1_Ptr = new __F__Test__SimpleClass1;

class __F__Test__SimpleClass1__Init
{
public:

    __F__Test__SimpleClass1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass1::ice_staticId(), __F__Test__SimpleClass1_Ptr);
    }

    ~__F__Test__SimpleClass1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass1::ice_staticId());
    }
};

const __F__Test__SimpleClass1__Init __F__Test__SimpleClass1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass1::ice_factory()
{
    return __F__Test__SimpleClass1_Ptr;
}

void 
Test::__patch(SimpleClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass2* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__SimpleClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass2"
};

}

bool
Test::SimpleClass2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass2_ids, __Test__SimpleClass2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass2_ids[0], &__Test__SimpleClass2_ids[2]);
}

const ::std::string&
Test::SimpleClass2::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass2_ids[1];
}

const ::std::string&
Test::SimpleClass2::ice_staticId()
{
    return __Test__SimpleClass2_ids[1];
}

::Ice::DispatchStatus
Test::SimpleClass2::___newOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    newOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__SimpleClass2_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newOp"
};

}

::Ice::DispatchStatus
Test::SimpleClass2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__SimpleClass2_all, __Test__SimpleClass2_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__SimpleClass2_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___newOp(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::SimpleClass2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

void 
Test::__patch(SimpleClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass3* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass3::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass3(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass3"
};

}

bool
Test::SimpleClass3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass3_ids, __Test__SimpleClass3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass3_ids[0], &__Test__SimpleClass3_ids[2]);
}

const ::std::string&
Test::SimpleClass3::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass3_ids[1];
}

const ::std::string&
Test::SimpleClass3::ice_staticId()
{
    return __Test__SimpleClass3_ids[1];
}

void
Test::SimpleClass3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(g);
    __os->endWriteSlice();
}

void
Test::SimpleClass3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(g);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass3 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass3::ice_staticId());
        return new ::Test::SimpleClass3;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass3_Ptr = new __F__Test__SimpleClass3;

class __F__Test__SimpleClass3__Init
{
public:

    __F__Test__SimpleClass3__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass3::ice_staticId(), __F__Test__SimpleClass3_Ptr);
    }

    ~__F__Test__SimpleClass3__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass3::ice_staticId());
    }
};

const __F__Test__SimpleClass3__Init __F__Test__SimpleClass3__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass3::ice_factory()
{
    return __F__Test__SimpleClass3_Ptr;
}

void 
Test::__patch(SimpleClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass4* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass4::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass4_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass4"
};

}

bool
Test::SimpleClass4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass4_ids, __Test__SimpleClass4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass4_ids[0], &__Test__SimpleClass4_ids[2]);
}

const ::std::string&
Test::SimpleClass4::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass4_ids[1];
}

const ::std::string&
Test::SimpleClass4::ice_staticId()
{
    return __Test__SimpleClass4_ids[1];
}

void
Test::SimpleClass4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::SimpleClass4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass4::ice_staticId());
        return new ::Test::SimpleClass4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass4_Ptr = new __F__Test__SimpleClass4;

class __F__Test__SimpleClass4__Init
{
public:

    __F__Test__SimpleClass4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass4::ice_staticId(), __F__Test__SimpleClass4_Ptr);
    }

    ~__F__Test__SimpleClass4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass4::ice_staticId());
    }
};

const __F__Test__SimpleClass4__Init __F__Test__SimpleClass4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass4::ice_factory()
{
    return __F__Test__SimpleClass4_Ptr;
}

void 
Test::__patch(SimpleClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass5* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass5::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass5(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass5_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass5"
};

}

bool
Test::SimpleClass5::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass5_ids, __Test__SimpleClass5_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass5_ids[0], &__Test__SimpleClass5_ids[2]);
}

const ::std::string&
Test::SimpleClass5::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass5_ids[1];
}

const ::std::string&
Test::SimpleClass5::ice_staticId()
{
    return __Test__SimpleClass5_ids[1];
}

void
Test::SimpleClass5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->endWriteSlice();
}

void
Test::SimpleClass5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass5 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass5::ice_staticId());
        return new ::Test::SimpleClass5;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass5_Ptr = new __F__Test__SimpleClass5;

class __F__Test__SimpleClass5__Init
{
public:

    __F__Test__SimpleClass5__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass5::ice_staticId(), __F__Test__SimpleClass5_Ptr);
    }

    ~__F__Test__SimpleClass5__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass5::ice_staticId());
    }
};

const __F__Test__SimpleClass5__Init __F__Test__SimpleClass5__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass5::ice_factory()
{
    return __F__Test__SimpleClass5_Ptr;
}

void 
Test::__patch(SimpleClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass5::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass6* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass6::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass6(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass6_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass6"
};

}

bool
Test::SimpleClass6::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass6_ids, __Test__SimpleClass6_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass6_ids[0], &__Test__SimpleClass6_ids[2]);
}

const ::std::string&
Test::SimpleClass6::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass6_ids[1];
}

const ::std::string&
Test::SimpleClass6::ice_staticId()
{
    return __Test__SimpleClass6_ids[1];
}

void
Test::SimpleClass6::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(f);
    __os->write(str);
    __os->endWriteSlice();
}

void
Test::SimpleClass6::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(f);
    __is->read(str);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass6 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass6::ice_staticId());
        return new ::Test::SimpleClass6;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass6_Ptr = new __F__Test__SimpleClass6;

class __F__Test__SimpleClass6__Init
{
public:

    __F__Test__SimpleClass6__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass6::ice_staticId(), __F__Test__SimpleClass6_Ptr);
    }

    ~__F__Test__SimpleClass6__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass6::ice_staticId());
    }
};

const __F__Test__SimpleClass6__Init __F__Test__SimpleClass6__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass6::ice_factory()
{
    return __F__Test__SimpleClass6_Ptr;
}

void 
Test::__patch(SimpleClass6Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass6Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass6::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass7* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass7::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass7(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass7_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass7"
};

}

bool
Test::SimpleClass7::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass7_ids, __Test__SimpleClass7_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass7::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass7_ids[0], &__Test__SimpleClass7_ids[2]);
}

const ::std::string&
Test::SimpleClass7::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass7_ids[1];
}

const ::std::string&
Test::SimpleClass7::ice_staticId()
{
    return __Test__SimpleClass7_ids[1];
}

void
Test::SimpleClass7::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass7::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass7 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass7::ice_staticId());
        return new ::Test::SimpleClass7;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass7_Ptr = new __F__Test__SimpleClass7;

class __F__Test__SimpleClass7__Init
{
public:

    __F__Test__SimpleClass7__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass7::ice_staticId(), __F__Test__SimpleClass7_Ptr);
    }

    ~__F__Test__SimpleClass7__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass7::ice_staticId());
    }
};

const __F__Test__SimpleClass7__Init __F__Test__SimpleClass7__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass7::ice_factory()
{
    return __F__Test__SimpleClass7_Ptr;
}

void 
Test::__patch(SimpleClass7Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass7Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass7::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Exception6* p) { return p; }
::Ice::ObjectPtr
Test::Exception6::ice_clone() const
{
    ::Ice::Object* __p = new Exception6(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Exception6_ids[2] =
{
    "::Ice::Object",
    "::Test::Exception6"
};

}

bool
Test::Exception6::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Exception6_ids, __Test__Exception6_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Exception6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Exception6_ids[0], &__Test__Exception6_ids[2]);
}

const ::std::string&
Test::Exception6::ice_id(const ::Ice::Current&) const
{
    return __Test__Exception6_ids[1];
}

const ::std::string&
Test::Exception6::ice_staticId()
{
    return __Test__Exception6_ids[1];
}

void
Test::Exception6::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Exception6::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Exception6 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Exception6::ice_staticId());
        return new ::Test::Exception6;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Exception6_Ptr = new __F__Test__Exception6;

class __F__Test__Exception6__Init
{
public:

    __F__Test__Exception6__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Exception6::ice_staticId(), __F__Test__Exception6_Ptr);
    }

    ~__F__Test__Exception6__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Exception6::ice_staticId());
    }
};

const __F__Test__Exception6__Init __F__Test__Exception6__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Exception6::ice_factory()
{
    return __F__Test__Exception6_Ptr;
}

void 
Test::__patch(Exception6Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Exception6Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Exception6::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass1* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass1"
};

}

bool
Test::BaseClass1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass1_ids, __Test__BaseClass1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass1_ids[0], &__Test__BaseClass1_ids[2]);
}

const ::std::string&
Test::BaseClass1::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass1_ids[1];
}

const ::std::string&
Test::BaseClass1::ice_staticId()
{
    return __Test__BaseClass1_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass1::___baseOp1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp1(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass1::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass1_all[] =
{
    "baseOp1",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass1_all, __Test__BaseClass1_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass1_all)
    {
        case 0:
        {
            return ___baseOp1(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass2* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass2"
};

}

bool
Test::BaseClass2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass2_ids, __Test__BaseClass2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass2_ids[0], &__Test__BaseClass2_ids[2]);
}

const ::std::string&
Test::BaseClass2::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass2_ids[1];
}

const ::std::string&
Test::BaseClass2::ice_staticId()
{
    return __Test__BaseClass2_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass2::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int __ret = baseOp(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass2::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass2_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass2_all, __Test__BaseClass2_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass2_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass3* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass3::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass3"
};

}

bool
Test::BaseClass3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass3_ids, __Test__BaseClass3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass3_ids[0], &__Test__BaseClass3_ids[2]);
}

const ::std::string&
Test::BaseClass3::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass3_ids[1];
}

const ::std::string&
Test::BaseClass3::ice_staticId()
{
    return __Test__BaseClass3_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass3::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::ObjectPtr o;
    __is->read(o);
    __is->readPendingObjects();
    __inS.endReadParams();
    baseOp(o, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass3::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass3_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass3::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass3_all, __Test__BaseClass3_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass3_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass4* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass4::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass4_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass4"
};

}

bool
Test::BaseClass4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass4_ids, __Test__BaseClass4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass4_ids[0], &__Test__BaseClass4_ids[2]);
}

const ::std::string&
Test::BaseClass4::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass4_ids[1];
}

const ::std::string&
Test::BaseClass4::ice_staticId()
{
    return __Test__BaseClass4_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass4::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass4::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Test::Exception2& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass4_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass4::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass4_all, __Test__BaseClass4_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass4_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass5* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass5::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass5_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass5"
};

}

bool
Test::BaseClass5::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass5_ids, __Test__BaseClass5_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass5_ids[0], &__Test__BaseClass5_ids[2]);
}

const ::std::string&
Test::BaseClass5::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass5_ids[1];
}

const ::std::string&
Test::BaseClass5::ice_staticId()
{
    return __Test__BaseClass5_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass5::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass5::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    ::std::string s;
    __is->read(i);
    __is->read(s);
    __inS.endReadParams();
    try
    {
        baseOp2(i, s, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass5_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass5::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass5_all, __Test__BaseClass5_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass5_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass5::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass6* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass6::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass6_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass6"
};

}

bool
Test::BaseClass6::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass6_ids, __Test__BaseClass6_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass6_ids[0], &__Test__BaseClass6_ids[2]);
}

const ::std::string&
Test::BaseClass6::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass6_ids[1];
}

const ::std::string&
Test::BaseClass6::ice_staticId()
{
    return __Test__BaseClass6_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass6::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass6::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::std::string s;
    try
    {
        baseOp2(s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass6_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass6::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass6_all, __Test__BaseClass6_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass6_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass6::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass6::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass6Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass6Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass6::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass7* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass7::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass7_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass7"
};

}

bool
Test::BaseClass7::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass7_ids, __Test__BaseClass7_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass7::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass7_ids[0], &__Test__BaseClass7_ids[2]);
}

const ::std::string&
Test::BaseClass7::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass7_ids[1];
}

const ::std::string&
Test::BaseClass7::ice_staticId()
{
    return __Test__BaseClass7_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass7::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass7::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    baseOp2(i, s, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(s);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__BaseClass7_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass7::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass7_all, __Test__BaseClass7_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass7_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass7::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass7::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass7Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass7Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass7::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass8* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass8::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass8_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass8"
};

}

bool
Test::BaseClass8::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass8_ids, __Test__BaseClass8_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass8::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass8_ids[0], &__Test__BaseClass8_ids[2]);
}

const ::std::string&
Test::BaseClass8::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass8_ids[1];
}

const ::std::string&
Test::BaseClass8::ice_staticId()
{
    return __Test__BaseClass8_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass8::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass8_all[] =
{
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass8::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass8_all, __Test__BaseClass8_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass8_all)
    {
        case 0:
        {
            return ___baseOp2(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass8::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass8::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass8Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass8Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass8::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass9* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass9::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass9_ids[3] =
{
    "::Ice::Object",
    "::Test::BaseClass9",
    "::Test::EmptyClass1"
};

}

bool
Test::BaseClass9::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass9_ids, __Test__BaseClass9_ids + 3, _s);
}

::std::vector< ::std::string>
Test::BaseClass9::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass9_ids[0], &__Test__BaseClass9_ids[3]);
}

const ::std::string&
Test::BaseClass9::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass9_ids[1];
}

const ::std::string&
Test::BaseClass9::ice_staticId()
{
    return __Test__BaseClass9_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass9::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass9::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass9_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass9::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass9_all, __Test__BaseClass9_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass9_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass9::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::Test::EmptyClass1::__writeImpl(__os);
}

void
Test::BaseClass9::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Test::EmptyClass1::__readImpl(__is);
}

void 
Test::__patch(BaseClass9Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass9Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass9::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass10* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass10::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass10_ids[3] =
{
    "::Ice::Object",
    "::Test::BaseClass10",
    "::Test::Interface1"
};

}

bool
Test::BaseClass10::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass10_ids, __Test__BaseClass10_ids + 3, _s);
}

::std::vector< ::std::string>
Test::BaseClass10::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass10_ids[0], &__Test__BaseClass10_ids[3]);
}

const ::std::string&
Test::BaseClass10::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass10_ids[1];
}

const ::std::string&
Test::BaseClass10::ice_staticId()
{
    return __Test__BaseClass10_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass10::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass10::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass10_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass10::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass10_all, __Test__BaseClass10_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass10_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass10::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass10::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass10Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass10Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass10::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass11* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass11::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass11_ids[4] =
{
    "::Ice::Object",
    "::Test::BaseClass11",
    "::Test::EmptyClass1",
    "::Test::Interface1"
};

}

bool
Test::BaseClass11::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass11_ids, __Test__BaseClass11_ids + 4, _s);
}

::std::vector< ::std::string>
Test::BaseClass11::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass11_ids[0], &__Test__BaseClass11_ids[4]);
}

const ::std::string&
Test::BaseClass11::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass11_ids[1];
}

const ::std::string&
Test::BaseClass11::ice_staticId()
{
    return __Test__BaseClass11_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass11::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass11::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass11_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass11::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass11_all, __Test__BaseClass11_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass11_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass11::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::Test::EmptyClass1::__writeImpl(__os);
}

void
Test::BaseClass11::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Test::EmptyClass1::__readImpl(__is);
}

void 
Test::__patch(BaseClass11Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass11Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass11::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Compact1* p) { return p; }
::Ice::ObjectPtr
Test::Compact1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__Compact1_ids[2] =
{
    "::Ice::Object",
    "::Test::Compact1"
};

}

bool
Test::Compact1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Compact1_ids, __Test__Compact1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Compact1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Compact1_ids[0], &__Test__Compact1_ids[2]);
}

const ::std::string&
Test::Compact1::ice_id(const ::Ice::Current&) const
{
    return __Test__Compact1_ids[1];
}

const ::std::string&
Test::Compact1::ice_staticId()
{
    return __Test__Compact1_ids[1];
}

::Ice::DispatchStatus
Test::Compact1::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::Compact1::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__Compact1_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::Compact1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Compact1_all, __Test__Compact1_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Compact1_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Compact1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), 1, true);
    __os->endWriteSlice();
}

void
Test::Compact1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Compact1__Init
{
public:

    __F__Test__Compact1__Init()
    {
        ::IceInternal::factoryTable->addTypeId(1, ::Test::Compact1::ice_staticId());
    }

    ~__F__Test__Compact1__Init()
    {
        ::IceInternal::factoryTable->removeTypeId(1);
    }
};

const __F__Test__Compact1__Init __F__Test__Compact1__i;

}

void 
Test::__patch(Compact1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Compact1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Compact1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Derived1* p) { return p; }
::Ice::ObjectPtr
Test::Derived1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__Derived1_ids[3] =
{
    "::Ice::Object",
    "::Test::Compact1",
    "::Test::Derived1"
};

}

bool
Test::Derived1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Derived1_ids, __Test__Derived1_ids + 3, _s);
}

::std::vector< ::std::string>
Test::Derived1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Derived1_ids[0], &__Test__Derived1_ids[3]);
}

const ::std::string&
Test::Derived1::ice_id(const ::Ice::Current&) const
{
    return __Test__Derived1_ids[2];
}

const ::std::string&
Test::Derived1::ice_staticId()
{
    return __Test__Derived1_ids[2];
}

namespace
{
const ::std::string __Test__Derived1_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::Derived1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Derived1_all, __Test__Derived1_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Derived1_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Derived1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::Test::Compact1::__writeImpl(__os);
}

void
Test::Derived1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Test::Compact1::__readImpl(__is);
}

void 
Test::__patch(Derived1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Derived1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Derived1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Compact2* p) { return p; }
::Ice::ObjectPtr
Test::Compact2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__Compact2_ids[2] =
{
    "::Ice::Object",
    "::Test::Compact2"
};

}

bool
Test::Compact2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Compact2_ids, __Test__Compact2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Compact2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Compact2_ids[0], &__Test__Compact2_ids[2]);
}

const ::std::string&
Test::Compact2::ice_id(const ::Ice::Current&) const
{
    return __Test__Compact2_ids[1];
}

const ::std::string&
Test::Compact2::ice_staticId()
{
    return __Test__Compact2_ids[1];
}

::Ice::DispatchStatus
Test::Compact2::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::Compact2::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__Compact2_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::Compact2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Compact2_all, __Test__Compact2_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Compact2_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Compact2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), 3, true);
    __os->endWriteSlice();
}

void
Test::Compact2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Compact2__Init
{
public:

    __F__Test__Compact2__Init()
    {
        ::IceInternal::factoryTable->addTypeId(3, ::Test::Compact2::ice_staticId());
    }

    ~__F__Test__Compact2__Init()
    {
        ::IceInternal::factoryTable->removeTypeId(3);
    }
};

const __F__Test__Compact2__Init __F__Test__Compact2__i;

}

void 
Test::__patch(Compact2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Compact2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Compact2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional0* p) { return p; }
::Ice::ObjectPtr
Test::Optional0::ice_clone() const
{
    ::Ice::Object* __p = new Optional0(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional0_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional0"
};

}

bool
Test::Optional0::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional0_ids, __Test__Optional0_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional0_ids[0], &__Test__Optional0_ids[2]);
}

const ::std::string&
Test::Optional0::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional0_ids[1];
}

const ::std::string&
Test::Optional0::ice_staticId()
{
    return __Test__Optional0_ids[1];
}

void
Test::Optional0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::Optional0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional0 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional0::ice_staticId());
        return new ::Test::Optional0;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional0_Ptr = new __F__Test__Optional0;

class __F__Test__Optional0__Init
{
public:

    __F__Test__Optional0__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional0::ice_staticId(), __F__Test__Optional0_Ptr);
    }

    ~__F__Test__Optional0__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional0::ice_staticId());
    }
};

const __F__Test__Optional0__Init __F__Test__Optional0__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional0::ice_factory()
{
    return __F__Test__Optional0_Ptr;
}

void 
Test::__patch(Optional0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional0::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional1* p) { return p; }
::Ice::ObjectPtr
Test::Optional1::ice_clone() const
{
    ::Ice::Object* __p = new Optional1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional1_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional1"
};

}

bool
Test::Optional1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional1_ids, __Test__Optional1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional1_ids[0], &__Test__Optional1_ids[2]);
}

const ::std::string&
Test::Optional1::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional1_ids[1];
}

const ::std::string&
Test::Optional1::ice_staticId()
{
    return __Test__Optional1_ids[1];
}

void
Test::Optional1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::Optional1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional1::ice_staticId());
        return new ::Test::Optional1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional1_Ptr = new __F__Test__Optional1;

class __F__Test__Optional1__Init
{
public:

    __F__Test__Optional1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional1::ice_staticId(), __F__Test__Optional1_Ptr);
    }

    ~__F__Test__Optional1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional1::ice_staticId());
    }
};

const __F__Test__Optional1__Init __F__Test__Optional1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional1::ice_factory()
{
    return __F__Test__Optional1_Ptr;
}

void 
Test::__patch(Optional1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional2* p) { return p; }
::Ice::ObjectPtr
Test::Optional2::ice_clone() const
{
    ::Ice::Object* __p = new Optional2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional2_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional2"
};

}

bool
Test::Optional2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional2_ids, __Test__Optional2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional2_ids[0], &__Test__Optional2_ids[2]);
}

const ::std::string&
Test::Optional2::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional2_ids[1];
}

const ::std::string&
Test::Optional2::ice_staticId()
{
    return __Test__Optional2_ids[1];
}

void
Test::Optional2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(emailAddress);
    __os->write(1, secondName);
    __os->endWriteSlice();
}

void
Test::Optional2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(emailAddress);
    __is->read(1, secondName);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional2::ice_staticId());
        return new ::Test::Optional2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional2_Ptr = new __F__Test__Optional2;

class __F__Test__Optional2__Init
{
public:

    __F__Test__Optional2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional2::ice_staticId(), __F__Test__Optional2_Ptr);
    }

    ~__F__Test__Optional2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional2::ice_staticId());
    }
};

const __F__Test__Optional2__Init __F__Test__Optional2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional2::ice_factory()
{
    return __F__Test__Optional2_Ptr;
}

void 
Test::__patch(Optional2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional3* p) { return p; }
::Ice::ObjectPtr
Test::Optional3::ice_clone() const
{
    ::Ice::Object* __p = new Optional3(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional3_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional3"
};

}

bool
Test::Optional3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional3_ids, __Test__Optional3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional3_ids[0], &__Test__Optional3_ids[2]);
}

const ::std::string&
Test::Optional3::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional3_ids[1];
}

const ::std::string&
Test::Optional3::ice_staticId()
{
    return __Test__Optional3_ids[1];
}

void
Test::Optional3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->write(3, phoneNumber);
    __os->endWriteSlice();
}

void
Test::Optional3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->read(3, phoneNumber);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional3 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional3::ice_staticId());
        return new ::Test::Optional3;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional3_Ptr = new __F__Test__Optional3;

class __F__Test__Optional3__Init
{
public:

    __F__Test__Optional3__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional3::ice_staticId(), __F__Test__Optional3_Ptr);
    }

    ~__F__Test__Optional3__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional3::ice_staticId());
    }
};

const __F__Test__Optional3__Init __F__Test__Optional3__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional3::ice_factory()
{
    return __F__Test__Optional3_Ptr;
}

void 
Test::__patch(Optional3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional4* p) { return p; }
::Ice::ObjectPtr
Test::Optional4::ice_clone() const
{
    ::Ice::Object* __p = new Optional4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional4_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional4"
};

}

bool
Test::Optional4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional4_ids, __Test__Optional4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional4_ids[0], &__Test__Optional4_ids[2]);
}

const ::std::string&
Test::Optional4::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional4_ids[1];
}

const ::std::string&
Test::Optional4::ice_staticId()
{
    return __Test__Optional4_ids[1];
}

void
Test::Optional4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, emailAddress);
    __os->write(2, secondName);
    __os->endWriteSlice();
}

void
Test::Optional4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, emailAddress);
    __is->read(2, secondName);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional4::ice_staticId());
        return new ::Test::Optional4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional4_Ptr = new __F__Test__Optional4;

class __F__Test__Optional4__Init
{
public:

    __F__Test__Optional4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional4::ice_staticId(), __F__Test__Optional4_Ptr);
    }

    ~__F__Test__Optional4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional4::ice_staticId());
    }
};

const __F__Test__Optional4__Init __F__Test__Optional4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional4::ice_factory()
{
    return __F__Test__Optional4_Ptr;
}

void 
Test::__patch(Optional4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters0* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters0::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters0"
};

}

bool
Test::OptionalParameters0::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters0_ids, __Test__OptionalParameters0_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters0_ids[0], &__Test__OptionalParameters0_ids[2]);
}

const ::std::string&
Test::OptionalParameters0::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters0_ids[1];
}

const ::std::string&
Test::OptionalParameters0::ice_staticId()
{
    return __Test__OptionalParameters0_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters0::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __inS.endReadParams();
    op1(firstName, secondName, emailAddress, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters0_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters0::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters0_all, __Test__OptionalParameters0_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters0_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters0::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters1* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters1_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters1"
};

}

bool
Test::OptionalParameters1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters1_ids, __Test__OptionalParameters1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters1_ids[0], &__Test__OptionalParameters1_ids[2]);
}

const ::std::string&
Test::OptionalParameters1::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters1_ids[1];
}

const ::std::string&
Test::OptionalParameters1::ice_staticId()
{
    return __Test__OptionalParameters1_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters1::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    IceUtil::Optional< ::std::string> emailAddress;
    IceUtil::Optional< ::std::string> secondName;
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __inS.endReadParams();
    op1(firstName, emailAddress, secondName, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters1_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters1_all, __Test__OptionalParameters1_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters1_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters2* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters2"
};

}

bool
Test::OptionalParameters2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters2_ids, __Test__OptionalParameters2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters2_ids[0], &__Test__OptionalParameters2_ids[2]);
}

const ::std::string&
Test::OptionalParameters2::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters2_ids[1];
}

const ::std::string&
Test::OptionalParameters2::ice_staticId()
{
    return __Test__OptionalParameters2_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters2::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    IceUtil::Optional< ::std::string> emailAddress;
    IceUtil::Optional< ::std::string> secondName;
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __inS.endReadParams();
    op1(firstName, emailAddress, secondName, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters2_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters2_all, __Test__OptionalParameters2_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters2_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters3* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters3::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters3_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters3"
};

}

bool
Test::OptionalParameters3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters3_ids, __Test__OptionalParameters3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters3_ids[0], &__Test__OptionalParameters3_ids[2]);
}

const ::std::string&
Test::OptionalParameters3::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters3_ids[1];
}

const ::std::string&
Test::OptionalParameters3::ice_staticId()
{
    return __Test__OptionalParameters3_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters3::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    ::std::string emailAddress;
    IceUtil::Optional< ::std::string> secondName;
    __is->read(firstName);
    __is->read(emailAddress);
    __is->read(1, secondName);
    __inS.endReadParams();
    op1(firstName, emailAddress, secondName, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters3_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters3::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters3_all, __Test__OptionalParameters3_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters3_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalReturn0* p) { return p; }
::Ice::ObjectPtr
Test::OptionalReturn0::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalReturn0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn0"
};

}

bool
Test::OptionalReturn0::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalReturn0_ids, __Test__OptionalReturn0_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalReturn0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalReturn0_ids[0], &__Test__OptionalReturn0_ids[2]);
}

const ::std::string&
Test::OptionalReturn0::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalReturn0_ids[1];
}

const ::std::string&
Test::OptionalReturn0::ice_staticId()
{
    return __Test__OptionalReturn0_ids[1];
}

::Ice::DispatchStatus
Test::OptionalReturn0::___op(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    IceUtil::Optional< ::Ice::Int> __ret = op(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(1, __ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalReturn0_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

::Ice::DispatchStatus
Test::OptionalReturn0::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalReturn0_all, __Test__OptionalReturn0_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalReturn0_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalReturn0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalReturn0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalReturn0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalReturn0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalReturn0::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalReturn2* p) { return p; }
::Ice::ObjectPtr
Test::OptionalReturn2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalReturn2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn2"
};

}

bool
Test::OptionalReturn2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalReturn2_ids, __Test__OptionalReturn2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalReturn2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalReturn2_ids[0], &__Test__OptionalReturn2_ids[2]);
}

const ::std::string&
Test::OptionalReturn2::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalReturn2_ids[1];
}

const ::std::string&
Test::OptionalReturn2::ice_staticId()
{
    return __Test__OptionalReturn2_ids[1];
}

::Ice::DispatchStatus
Test::OptionalReturn2::___op(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int __ret = op(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalReturn2_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

::Ice::DispatchStatus
Test::OptionalReturn2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalReturn2_all, __Test__OptionalReturn2_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalReturn2_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalReturn2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalReturn2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalReturn2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalReturn2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalReturn2::ice_staticId(), v);
    }
}

::Ice::LocalObject* Test::upCast(::Test::LocalClass* p) { return p; }

namespace
{

const char* __sliceChecksums[] =
{
    "::Test::BaseClass1", "549369ef4c2bd57ce3288dca332f5",
    "::Test::BaseClass10", "74961d462a46ede3195a02b5cbee93",
    "::Test::BaseClass11", "2d4f4683ceeb4320b412e6acdd18674",
    "::Test::BaseClass2", "71f30b9d27c8d3140f5ba567f82893",
    "::Test::BaseClass3", "19ffcdd2959ebfdbd99ad5d522139952",
    "::Test::BaseClass4", "47994447746d23e060385e0d0ae81e2",
    "::Test::BaseClass5", "555f677eb164989b3b4e605fda78a894",
    "::Test::BaseClass6", "a89a7d72ee6281342423e33127c84e",
    "::Test::BaseClass7", "35ea575fcba51a888686e32f28bee5a2",
    "::Test::BaseClass8", "dbd05e95f0dfb8b2604c4edcf9fe4c9",
    "::Test::BaseClass9", "efb294dff41a33bd6d23e9d22135ef",
    "::Test::Compact1", "53de5d6481876a2abc230cdaea2638b",
    "::Test::Compact2", "98b2d7e977cee59e41292b4dc6adf6e",
    "::Test::Derived1", "70eb1c3578f9db4f8e3f2c663272eed4",
    "::Test::Dictionary1", "25699466bad619a2f36d47ebead5138b",
    "::Test::Dictionary2", "793142495b3c671912c443dddfa163ad",
    "::Test::Dictionary3", "b930f3c9fedd82bb732a3bb54a470eb",
    "::Test::Dictionary4", "74991ade8e14e96f12951a2089c2123",
    "::Test::EmptyClass1", "8b172e6bd6a916d80f922742ddb91",
    "::Test::EmptyClass2", "946c69568625cbcdf7123d52bb07e98",
    "::Test::EmptyClass3", "9964c1a7ff26770beded39ff7259ee9",
    "::Test::EmptyClass4", "1cd504a457f11eac2285fb202abc8",
    "::Test::EmptyClass5", "d1bad93e37f99bd1387908286dfb181",
    "::Test::Enum1", "6c81f7cbcd6b1917e5908e95de31f624",
    "::Test::Enum2", "89fdd217de2596f4e399bae5f59104f",
    "::Test::Enum3", "c83cdceb7d476354c13d4ffc15379e54",
    "::Test::Enum4", "f71c2ad766bb2b75726d9aae3ee263c6",
    "::Test::EnumExplicit0", "3039549e3f1bd57f231277862c132af",
    "::Test::EnumExplicit1", "d2497a988932ca3252cdd87147807e",
    "::Test::EnumExplicit2", "3c95ae26358bf5ca73d2c739b1919f52",
    "::Test::EnumExplicit3", "21d0be38e97c3bf5a71a18d7f7c45",
    "::Test::Exception1", "9d9d6d47575447abd7488352c9728",
    "::Test::Exception2", "46a016f04778f80dad11c5adb42e9d",
    "::Test::Exception3", "662abe6f551f1fe382275b72443892",
    "::Test::Exception4", "6a9e86ce109d751d3b1954533d64aead",
    "::Test::Exception5", "72bac49785d36ed4c375fae76eccef",
    "::Test::Exception6", "b49a7d447d9a8fd5570193e8a44626",
    "::Test::IntConst1", "e67ad7c7baa8817a81f1ac6e8049f926",
    "::Test::IntConst2", "7283154c44d71ab5e21c3535a132110",
    "::Test::IntConst3", "84586e6771612745e2c181151bfe735",
    "::Test::Interface1", "f3d458f98f8f3c9099202927c3647f",
    "::Test::Interface2", "2ce2631fa5ebc013fb7d35b6da50a3",
    "::Test::Interface3", "abfcb6419adb836b955d84330f4cce0",
    "::Test::Interface4", "12f45d108a247609884983e9deccc",
    "::Test::Optional0", "4c424a20ee68c3cb2c183d0fe4b8496",
    "::Test::Optional1", "e44c9ae7f89c6872701fe83a5dfd77",
    "::Test::Optional2", "d3ffa273e28e22aea17166fbe6b3ddf",
    "::Test::Optional3", "2fa3b6d86120c2c913ddad198be604c",
    "::Test::Optional4", "8df4325c92e03f5058744315f0bbd044",
    "::Test::OptionalEx0", "7cce6eadb31650882cd186a8aab38841",
    "::Test::OptionalEx1", "e6b928366b46ac34cfac9bfb597aeb6",
    "::Test::OptionalEx2", "4c704524f7af467d121ad7fc30c291c0",
    "::Test::OptionalEx3", "1cd99e4ddf5285e53bbbb07f56354cfe",
    "::Test::OptionalEx4", "2fcfdaa57f48b1d553db9eadfc23e98",
    "::Test::OptionalParameters0", "50218eebd7ae752b15f342bc2a7acd5d",
    "::Test::OptionalParameters1", "3cfa6491e6e6c26a981bb718bc9e8732",
    "::Test::OptionalParameters2", "e98da8bf188508e968910e59e9c8057",
    "::Test::OptionalParameters3", "e7ec653a4fd428c44365539748f11d48",
    "::Test::OptionalReturn0", "ec318426ba8b88b35d6a667fdce3192",
    "::Test::OptionalReturn2", "1916dd243330fecf09c9cb1a49f8c55",
    "::Test::Sequence1", "945d43f4c73c2782de20223294c8e1",
    "::Test::Sequence2", "2cc04a7cbb7bd6ec87a1a5fe318a7d18",
    "::Test::Sequence3", "81f5744a219b9820853f5b3e28966ab6",
    "::Test::SimpleClass1", "24c5fbaecf6c6261b139141bf2c3812d",
    "::Test::SimpleClass2", "21ee7ea9a765b3a222185bc7ceab672",
    "::Test::SimpleClass3", "2bad135b9d11556ce1f6e2e7c5241393",
    "::Test::SimpleClass4", "7969d76bf97b90b652eb678372f55781",
    "::Test::SimpleClass5", "837d74e6cb5ee32b47994b6817aaaa1c",
    "::Test::SimpleClass6", "9ca6366edbd948c9ed21fb6d6a2bc58",
    "::Test::SimpleClass7", "5fce34426d394dbd36e9d854dacb6ae",
    "::Test::Struct1", "5b51361b27dbc3830afcfda19b8b2e8",
    "::Test::Struct2", "2c381df387126ce416c2c14ba48785f",
    "::Test::Struct3", "faece7ab41b6ba6f1dcde85f588eedf",
    "::Test::Struct4", "eb5ca3c41f48c71ed3f2dc43b9b5010",
    "::Test::Struct5", "b139718b8da232bbbff6e5795e2d9",
    0
};
const IceInternal::SliceChecksumInit __sliceChecksumInit(__sliceChecksums);

}
