// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Types.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Types.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SliceChecksums.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Test__BaseClass1__baseOp1_name = "baseOp1";

const ::std::string __Test__BaseClass1__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass2__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass2__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass3__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass3__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass4__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass4__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass5__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass5__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass6__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass6__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass7__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass7__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass8__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass8__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass9__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass9__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass10__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass10__baseOp2_name = "baseOp2";

const ::std::string __Test__BaseClass11__baseOp_name = "baseOp";

const ::std::string __Test__BaseClass11__baseOp2_name = "baseOp2";

const ::std::string __Test__Compact1__baseOp_name = "baseOp";

const ::std::string __Test__Compact1__baseOp2_name = "baseOp2";

const ::std::string __Test__Compact2__baseOp_name = "baseOp";

const ::std::string __Test__Compact2__baseOp2_name = "baseOp2";

const ::std::string __Test__OptionalParameters0__op1_name = "op1";

const ::std::string __Test__OptionalParameters1__op1_name = "op1";

const ::std::string __Test__OptionalParameters2__op1_name = "op1";

const ::std::string __Test__OptionalParameters3__op1_name = "op1";

const ::std::string __Test__OptionalReturn0__op_name = "op";

const ::std::string __Test__OptionalReturn2__op_name = "op";

}

namespace
{

const char* __Test__Exception1_name = "Test::Exception1";

struct __F__Test__Exception1 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception1();
    }
};

class __F__Test__Exception1__Init
{
public:

    __F__Test__Exception1__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception1", new __F__Test__Exception1);
    }

    ~__F__Test__Exception1__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception1");
    }
};

const __F__Test__Exception1__Init __F__Test__Exception1__i;

}

Test::Exception1::Exception1(const ::std::string& __ice_str, bool __ice_b) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b)
{
}

Test::Exception1::~Exception1() throw()
{
}

::std::string
Test::Exception1::ice_name() const
{
    return __Test__Exception1_name;
}

Test::Exception1*
Test::Exception1::ice_clone() const
{
    return new Exception1(*this);
}

void
Test::Exception1::ice_throw() const
{
    throw *this;
}

void
Test::Exception1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception1", -1, true);
    __os->write(str);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception2_name = "Test::Exception2";

struct __F__Test__Exception2 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception2();
    }
};

class __F__Test__Exception2__Init
{
public:

    __F__Test__Exception2__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception2", new __F__Test__Exception2);
    }

    ~__F__Test__Exception2__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception2");
    }
};

const __F__Test__Exception2__Init __F__Test__Exception2__i;

}

Test::Exception2::Exception2(const ::std::string& __ice_str, bool __ice_b) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b)
{
}

Test::Exception2::~Exception2() throw()
{
}

::std::string
Test::Exception2::ice_name() const
{
    return __Test__Exception2_name;
}

Test::Exception2*
Test::Exception2::ice_clone() const
{
    return new Exception2(*this);
}

void
Test::Exception2::ice_throw() const
{
    throw *this;
}

void
Test::Exception2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception2", -1, true);
    __os->write(str);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception3_name = "Test::Exception3";

struct __F__Test__Exception3 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception3();
    }
};

class __F__Test__Exception3__Init
{
public:

    __F__Test__Exception3__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception3", new __F__Test__Exception3);
    }

    ~__F__Test__Exception3__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception3");
    }
};

const __F__Test__Exception3__Init __F__Test__Exception3__i;

}

Test::Exception3::Exception3(const ::std::string& __ice_str, bool __ice_b) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b)
{
}

Test::Exception3::~Exception3() throw()
{
}

::std::string
Test::Exception3::ice_name() const
{
    return __Test__Exception3_name;
}

Test::Exception3*
Test::Exception3::ice_clone() const
{
    return new Exception3(*this);
}

void
Test::Exception3::ice_throw() const
{
    throw *this;
}

void
Test::Exception3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception3", -1, true);
    __os->write(str);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception4_name = "Test::Exception4";

struct __F__Test__Exception4 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception4();
    }
};

class __F__Test__Exception4__Init
{
public:

    __F__Test__Exception4__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception4", new __F__Test__Exception4);
    }

    ~__F__Test__Exception4__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception4");
    }
};

const __F__Test__Exception4__Init __F__Test__Exception4__i;

}

Test::Exception4::Exception4(const ::std::string& __ice_str, bool __ice_b) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b)
{
}

Test::Exception4::~Exception4() throw()
{
}

::std::string
Test::Exception4::ice_name() const
{
    return __Test__Exception4_name;
}

Test::Exception4*
Test::Exception4::ice_clone() const
{
    return new Exception4(*this);
}

void
Test::Exception4::ice_throw() const
{
    throw *this;
}

void
Test::Exception4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception4", -1, true);
    __os->write(str);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception5_name = "Test::Exception5";

struct __F__Test__Exception5 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception5();
    }
};

class __F__Test__Exception5__Init
{
public:

    __F__Test__Exception5__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception5", new __F__Test__Exception5);
    }

    ~__F__Test__Exception5__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception5");
    }
};

const __F__Test__Exception5__Init __F__Test__Exception5__i;

}

Test::Exception5::~Exception5() throw()
{
}

::std::string
Test::Exception5::ice_name() const
{
    return __Test__Exception5_name;
}

Test::Exception5*
Test::Exception5::ice_clone() const
{
    return new Exception5(*this);
}

void
Test::Exception5::ice_throw() const
{
    throw *this;
}

void
Test::Exception5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception5", -1, true);
    __os->endWriteSlice();
}

void
Test::Exception5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __Test__Exception6_name = "Test::Exception6";

struct __F__Test__Exception6 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Exception6();
    }
};

class __F__Test__Exception6__Init
{
public:

    __F__Test__Exception6__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Exception6", new __F__Test__Exception6);
    }

    ~__F__Test__Exception6__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Exception6");
    }
};

const __F__Test__Exception6__Init __F__Test__Exception6__i;

}

Test::Exception6::Exception6(const ::std::string& __ice_str, bool __ice_b) :
    ::Ice::UserException(),
    str(__ice_str),
    b(__ice_b)
{
}

Test::Exception6::~Exception6() throw()
{
}

::std::string
Test::Exception6::ice_name() const
{
    return __Test__Exception6_name;
}

Test::Exception6*
Test::Exception6::ice_clone() const
{
    return new Exception6(*this);
}

void
Test::Exception6::ice_throw() const
{
    throw *this;
}

void
Test::Exception6::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Exception6", -1, true);
    __os->write(str);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Exception6::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx0_name = "Test::OptionalEx0";

struct __F__Test__OptionalEx0 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx0();
    }
};

class __F__Test__OptionalEx0__Init
{
public:

    __F__Test__OptionalEx0__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx0", new __F__Test__OptionalEx0);
    }

    ~__F__Test__OptionalEx0__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx0");
    }
};

const __F__Test__OptionalEx0__Init __F__Test__OptionalEx0__i;

}

Test::OptionalEx0::OptionalEx0(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx0::~OptionalEx0() throw()
{
}

::std::string
Test::OptionalEx0::ice_name() const
{
    return __Test__OptionalEx0_name;
}

Test::OptionalEx0*
Test::OptionalEx0::ice_clone() const
{
    return new OptionalEx0(*this);
}

void
Test::OptionalEx0::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx0", -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::OptionalEx0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx1_name = "Test::OptionalEx1";

struct __F__Test__OptionalEx1 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx1();
    }
};

class __F__Test__OptionalEx1__Init
{
public:

    __F__Test__OptionalEx1__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx1", new __F__Test__OptionalEx1);
    }

    ~__F__Test__OptionalEx1__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx1");
    }
};

const __F__Test__OptionalEx1__Init __F__Test__OptionalEx1__i;

}

Test::OptionalEx1::OptionalEx1(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx1::~OptionalEx1() throw()
{
}

::std::string
Test::OptionalEx1::ice_name() const
{
    return __Test__OptionalEx1_name;
}

Test::OptionalEx1*
Test::OptionalEx1::ice_clone() const
{
    return new OptionalEx1(*this);
}

void
Test::OptionalEx1::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx1", -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::OptionalEx1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx2_name = "Test::OptionalEx2";

struct __F__Test__OptionalEx2 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx2();
    }
};

class __F__Test__OptionalEx2__Init
{
public:

    __F__Test__OptionalEx2__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx2", new __F__Test__OptionalEx2);
    }

    ~__F__Test__OptionalEx2__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx2");
    }
};

const __F__Test__OptionalEx2__Init __F__Test__OptionalEx2__i;

}

Test::OptionalEx2::OptionalEx2(const ::std::string& __ice_firstName, const ::std::string& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx2::~OptionalEx2() throw()
{
}

::std::string
Test::OptionalEx2::ice_name() const
{
    return __Test__OptionalEx2_name;
}

Test::OptionalEx2*
Test::OptionalEx2::ice_clone() const
{
    return new OptionalEx2(*this);
}

void
Test::OptionalEx2::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx2", -1, true);
    __os->write(firstName);
    __os->write(secondName);
    __os->write(1, emailAddress);
    __os->endWriteSlice();
}

void
Test::OptionalEx2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(secondName);
    __is->read(1, emailAddress);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx3_name = "Test::OptionalEx3";

struct __F__Test__OptionalEx3 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx3();
    }
};

class __F__Test__OptionalEx3__Init
{
public:

    __F__Test__OptionalEx3__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx3", new __F__Test__OptionalEx3);
    }

    ~__F__Test__OptionalEx3__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx3");
    }
};

const __F__Test__OptionalEx3__Init __F__Test__OptionalEx3__i;

}

Test::OptionalEx3::OptionalEx3(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx3::~OptionalEx3() throw()
{
}

::std::string
Test::OptionalEx3::ice_name() const
{
    return __Test__OptionalEx3_name;
}

Test::OptionalEx3*
Test::OptionalEx3::ice_clone() const
{
    return new OptionalEx3(*this);
}

void
Test::OptionalEx3::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx3", -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::OptionalEx3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

const char* __Test__OptionalEx4_name = "Test::OptionalEx4";

struct __F__Test__OptionalEx4 : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::OptionalEx4();
    }
};

class __F__Test__OptionalEx4__Init
{
public:

    __F__Test__OptionalEx4__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::OptionalEx4", new __F__Test__OptionalEx4);
    }

    ~__F__Test__OptionalEx4__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::OptionalEx4");
    }
};

const __F__Test__OptionalEx4__Init __F__Test__OptionalEx4__i;

}

Test::OptionalEx4::OptionalEx4(const ::std::string& __ice_firstName, const IceUtil::Optional< ::std::string>& __ice_secondName, const IceUtil::Optional< ::std::string>& __ice_emailAddress) :
    ::Ice::UserException(),
    firstName(__ice_firstName),
    secondName(__ice_secondName),
    emailAddress(__ice_emailAddress)
{
}

Test::OptionalEx4::~OptionalEx4() throw()
{
}

::std::string
Test::OptionalEx4::ice_name() const
{
    return __Test__OptionalEx4_name;
}

Test::OptionalEx4*
Test::OptionalEx4::ice_clone() const
{
    return new OptionalEx4(*this);
}

void
Test::OptionalEx4::ice_throw() const
{
    throw *this;
}

void
Test::OptionalEx4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::OptionalEx4", -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::OptionalEx4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Interface1::ice_staticId()
{
    return ::Test::Interface1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface1::__newInstance() const
{
    return new Interface1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Interface2::ice_staticId()
{
    return ::Test::Interface2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface2);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface2::__newInstance() const
{
    return new Interface2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Interface3::ice_staticId()
{
    return ::Test::Interface3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface3);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface3::__newInstance() const
{
    return new Interface3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Interface4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Interface4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Interface4::ice_staticId()
{
    return ::Test::Interface4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Interface4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Interface4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Interface4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Interface4);
}

::IceProxy::Ice::Object*
IceProxy::Test::Interface4::__newInstance() const
{
    return new Interface4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass1::ice_staticId()
{
    return ::Test::EmptyClass1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass1);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass1::__newInstance() const
{
    return new EmptyClass1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass2::ice_staticId()
{
    return ::Test::EmptyClass2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass2);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass2::__newInstance() const
{
    return new EmptyClass2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass3::ice_staticId()
{
    return ::Test::EmptyClass3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass3);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass3::__newInstance() const
{
    return new EmptyClass3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass4::ice_staticId()
{
    return ::Test::EmptyClass4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass4);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass4::__newInstance() const
{
    return new EmptyClass4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::EmptyClass5* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::EmptyClass5;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::EmptyClass5::ice_staticId()
{
    return ::Test::EmptyClass5::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::EmptyClass5::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::EmptyClass5);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::EmptyClass5::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::EmptyClass5);
}

::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass5::__newInstance() const
{
    return new EmptyClass5;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass1::ice_staticId()
{
    return ::Test::SimpleClass1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass1);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass1::__newInstance() const
{
    return new SimpleClass1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass2::ice_staticId()
{
    return ::Test::SimpleClass2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass2);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass2::__newInstance() const
{
    return new SimpleClass2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass3::ice_staticId()
{
    return ::Test::SimpleClass3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass3);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass3::__newInstance() const
{
    return new SimpleClass3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass4::ice_staticId()
{
    return ::Test::SimpleClass4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass4);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass4::__newInstance() const
{
    return new SimpleClass4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass5* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass5;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass5::ice_staticId()
{
    return ::Test::SimpleClass5::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass5::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass5);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass5::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass5);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass5::__newInstance() const
{
    return new SimpleClass5;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass6* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass6>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass6;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass6::ice_staticId()
{
    return ::Test::SimpleClass6::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass6::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass6);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass6::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass6);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass6::__newInstance() const
{
    return new SimpleClass6;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SimpleClass7* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass7>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SimpleClass7;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SimpleClass7::ice_staticId()
{
    return ::Test::SimpleClass7::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SimpleClass7::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SimpleClass7);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SimpleClass7::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SimpleClass7);
}

::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass7::__newInstance() const
{
    return new SimpleClass7;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass1;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass1::baseOp1(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass1__baseOp1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass1* __del = dynamic_cast< ::IceDelegate::Test::BaseClass1*>(__delBase.get());
            __del->baseOp1(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass1::begin_baseOp1(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass1__baseOp1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass1__baseOp1_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass1::end_baseOp1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass1__baseOp1_name);
}

void
IceProxy::Test::BaseClass1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass1__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass1__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass1* __del = dynamic_cast< ::IceDelegate::Test::BaseClass1*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass1::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass1__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass1__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass1__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass1::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass1__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass1::ice_staticId()
{
    return ::Test::BaseClass1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass1);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass1::__newInstance() const
{
    return new BaseClass1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass2;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass2::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass2__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass2* __del = dynamic_cast< ::IceDelegate::Test::BaseClass2*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass2::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass2__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass2__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass2::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass2__baseOp_name);
}

void
IceProxy::Test::BaseClass2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass2__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass2__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass2* __del = dynamic_cast< ::IceDelegate::Test::BaseClass2*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass2::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass2__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass2__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass2__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass2::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass2__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass2::ice_staticId()
{
    return ::Test::BaseClass2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass2);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass2::__newInstance() const
{
    return new BaseClass2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass3;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass3::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass3__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass3* __del = dynamic_cast< ::IceDelegate::Test::BaseClass3*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass3::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass3__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass3__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass3::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass3__baseOp_name);
}

void
IceProxy::Test::BaseClass3::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass3__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass3__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass3* __del = dynamic_cast< ::IceDelegate::Test::BaseClass3*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass3::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass3__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass3__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass3__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass3::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass3__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass3::ice_staticId()
{
    return ::Test::BaseClass3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass3);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass3::__newInstance() const
{
    return new BaseClass3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass4;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass4::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass4__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass4* __del = dynamic_cast< ::IceDelegate::Test::BaseClass4*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass4::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass4__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass4__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass4::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass4__baseOp_name);
}

void
IceProxy::Test::BaseClass4::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass4__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass4__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass4* __del = dynamic_cast< ::IceDelegate::Test::BaseClass4*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass4::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass4__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass4__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass4__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass4::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass4__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass4::ice_staticId()
{
    return ::Test::BaseClass4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass4);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass4::__newInstance() const
{
    return new BaseClass4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass5* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass5;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass5::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass5__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass5* __del = dynamic_cast< ::IceDelegate::Test::BaseClass5*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass5::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass5__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass5__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass5::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass5__baseOp_name);
}

void
IceProxy::Test::BaseClass5::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass5__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass5__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass5* __del = dynamic_cast< ::IceDelegate::Test::BaseClass5*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass5::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass5__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass5__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass5__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass5::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass5__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass5::ice_staticId()
{
    return ::Test::BaseClass5::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass5::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass5);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass5::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass5);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass5::__newInstance() const
{
    return new BaseClass5;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass6* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass6>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass6;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass6::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass6__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass6* __del = dynamic_cast< ::IceDelegate::Test::BaseClass6*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass6::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass6__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass6__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass6::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass6__baseOp_name);
}

void
IceProxy::Test::BaseClass6::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass6__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass6__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass6* __del = dynamic_cast< ::IceDelegate::Test::BaseClass6*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass6::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass6__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass6__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass6__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass6::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass6__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass6::ice_staticId()
{
    return ::Test::BaseClass6::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass6::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass6);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass6::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass6);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass6::__newInstance() const
{
    return new BaseClass6;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass7* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass7>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass7;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass7::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass7__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass7* __del = dynamic_cast< ::IceDelegate::Test::BaseClass7*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass7::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass7__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass7__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass7::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass7__baseOp_name);
}

void
IceProxy::Test::BaseClass7::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass7__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass7__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass7* __del = dynamic_cast< ::IceDelegate::Test::BaseClass7*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass7::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass7__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass7__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass7__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass7::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass7__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass7::ice_staticId()
{
    return ::Test::BaseClass7::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass7::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass7);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass7::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass7);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass7::__newInstance() const
{
    return new BaseClass7;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass8* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass8>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass8;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass8::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass8__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass8* __del = dynamic_cast< ::IceDelegate::Test::BaseClass8*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass8::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass8__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass8__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass8::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass8__baseOp_name);
}

void
IceProxy::Test::BaseClass8::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass8__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass8__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass8* __del = dynamic_cast< ::IceDelegate::Test::BaseClass8*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass8::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass8__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass8__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass8__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass8::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass8__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass8::ice_staticId()
{
    return ::Test::BaseClass8::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass8::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass8);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass8::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass8);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass8::__newInstance() const
{
    return new BaseClass8;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass9* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass9>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass9;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass9::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass9__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass9* __del = dynamic_cast< ::IceDelegate::Test::BaseClass9*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass9::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass9__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass9__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass9::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass9__baseOp_name);
}

void
IceProxy::Test::BaseClass9::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass9__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass9__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass9* __del = dynamic_cast< ::IceDelegate::Test::BaseClass9*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass9::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass9__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass9__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass9__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass9::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass9__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass9::ice_staticId()
{
    return ::Test::BaseClass9::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass9::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass9);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass9::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass9);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass9::__newInstance() const
{
    return new BaseClass9;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass10* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass10>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass10;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass10::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass10__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass10* __del = dynamic_cast< ::IceDelegate::Test::BaseClass10*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass10::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass10__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass10__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass10::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass10__baseOp_name);
}

void
IceProxy::Test::BaseClass10::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass10__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass10__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass10* __del = dynamic_cast< ::IceDelegate::Test::BaseClass10*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass10::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass10__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass10__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass10__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass10::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass10__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass10::ice_staticId()
{
    return ::Test::BaseClass10::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass10::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass10);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass10::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass10);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass10::__newInstance() const
{
    return new BaseClass10;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass11* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass11>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass11;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::BaseClass11::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass11__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass11* __del = dynamic_cast< ::IceDelegate::Test::BaseClass11*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass11::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass11__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass11__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass11::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__BaseClass11__baseOp_name);
}

void
IceProxy::Test::BaseClass11::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__BaseClass11__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__BaseClass11__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::BaseClass11* __del = dynamic_cast< ::IceDelegate::Test::BaseClass11*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseClass11::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__BaseClass11__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__BaseClass11__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__BaseClass11__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::BaseClass11::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__BaseClass11__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::BaseClass11::ice_staticId()
{
    return ::Test::BaseClass11::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass11::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass11);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass11::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass11);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass11::__newInstance() const
{
    return new BaseClass11;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Compact1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Compact1;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::Compact1::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact1__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact1* __del = dynamic_cast< ::IceDelegate::Test::Compact1*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact1::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact1__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact1__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact1::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Compact1__baseOp_name);
}

void
IceProxy::Test::Compact1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact1__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Compact1__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact1* __del = dynamic_cast< ::IceDelegate::Test::Compact1*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact1::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Compact1__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact1__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact1__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact1::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Compact1__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::Compact1::ice_staticId()
{
    return ::Test::Compact1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Compact1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Compact1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Compact1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Compact1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Compact1::__newInstance() const
{
    return new Compact1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Derived1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Derived1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Derived1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Derived1::ice_staticId()
{
    return ::Test::Derived1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Derived1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Derived1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Derived1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Derived1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Derived1::__newInstance() const
{
    return new Derived1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Compact2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Compact2;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::Compact2::baseOp(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact2__baseOp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact2* __del = dynamic_cast< ::IceDelegate::Test::Compact2*>(__delBase.get());
            __del->baseOp(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact2::begin_baseOp(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact2__baseOp_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact2__baseOp_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact2::end_baseOp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__Compact2__baseOp_name);
}

void
IceProxy::Test::Compact2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Compact2__baseOp2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Compact2__baseOp2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Compact2* __del = dynamic_cast< ::IceDelegate::Test::Compact2*>(__delBase.get());
            __del->baseOp2(i, s, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Compact2::begin_baseOp2(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Compact2__baseOp2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Compact2__baseOp2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Compact2__baseOp2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Compact2::end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Compact2__baseOp2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(s);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::Compact2::ice_staticId()
{
    return ::Test::Compact2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Compact2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Compact2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Compact2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Compact2);
}

::IceProxy::Ice::Object*
IceProxy::Test::Compact2::__newInstance() const
{
    return new Compact2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional0* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional0>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional0;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional0::ice_staticId()
{
    return ::Test::Optional0::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional0::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional0);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional0::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional0);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional0::__newInstance() const
{
    return new Optional0;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional1::ice_staticId()
{
    return ::Test::Optional1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional1);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional1::__newInstance() const
{
    return new Optional1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional2::ice_staticId()
{
    return ::Test::Optional2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional2);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional2::__newInstance() const
{
    return new Optional2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional3;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional3::ice_staticId()
{
    return ::Test::Optional3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional3);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional3::__newInstance() const
{
    return new Optional3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Optional4* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional4>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Optional4;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Optional4::ice_staticId()
{
    return ::Test::Optional4::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Optional4::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Optional4);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Optional4::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Optional4);
}

::IceProxy::Ice::Object*
IceProxy::Test::Optional4::__newInstance() const
{
    return new Optional4;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters0* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters0>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters0;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters0::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters0__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters0* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters0*>(__delBase.get());
            __del->op1(firstName, secondName, emailAddress, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters0::begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters0__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters0__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters0::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters0__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters0::ice_staticId()
{
    return ::Test::OptionalParameters0::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters0::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters0);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters0::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters0);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters0::__newInstance() const
{
    return new OptionalParameters0;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters1;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters1::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters1__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters1* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters1*>(__delBase.get());
            __del->op1(firstName, secondName, emailAddress, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters1::begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters1__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters1__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters1::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters1__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters1::ice_staticId()
{
    return ::Test::OptionalParameters1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters1);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters1::__newInstance() const
{
    return new OptionalParameters1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters2;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters2::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters2__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters2* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters2*>(__delBase.get());
            __del->op1(firstName, emailAddress, secondName, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters2::begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters2__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters2__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, emailAddress);
        __os->write(2, secondName);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters2::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters2__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters2::ice_staticId()
{
    return ::Test::OptionalParameters2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters2);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters2::__newInstance() const
{
    return new OptionalParameters2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalParameters3* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters3>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalParameters3;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::OptionalParameters3::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalParameters3__op1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalParameters3* __del = dynamic_cast< ::IceDelegate::Test::OptionalParameters3*>(__delBase.get());
            __del->op1(firstName, emailAddress, secondName, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters3::begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalParameters3__op1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalParameters3__op1_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(secondName);
        __os->write(1, emailAddress);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::OptionalParameters3::end_op1(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__OptionalParameters3__op1_name);
}

const ::std::string&
IceProxy::Test::OptionalParameters3::ice_staticId()
{
    return ::Test::OptionalParameters3::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalParameters3::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalParameters3);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalParameters3::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalParameters3);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters3::__newInstance() const
{
    return new OptionalParameters3;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalReturn0* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn0>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalReturn0;
        v->__copyFrom(proxy);
    }
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn0::op(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalReturn0__op_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__OptionalReturn0__op_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalReturn0* __del = dynamic_cast< ::IceDelegate::Test::OptionalReturn0*>(__delBase.get());
            return __del->op(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalReturn0::begin_op(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__OptionalReturn0__op_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalReturn0__op_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalReturn0__op_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn0::end_op(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__OptionalReturn0__op_name);
    IceUtil::Optional< ::Ice::Int> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(1, __ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::OptionalReturn0::ice_staticId()
{
    return ::Test::OptionalReturn0::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalReturn0::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalReturn0);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalReturn0::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalReturn0);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalReturn0::__newInstance() const
{
    return new OptionalReturn0;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::OptionalReturn2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::OptionalReturn2;
        v->__copyFrom(proxy);
    }
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn2::op(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__OptionalReturn2__op_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__OptionalReturn2__op_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::OptionalReturn2* __del = dynamic_cast< ::IceDelegate::Test::OptionalReturn2*>(__delBase.get());
            return __del->op(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::OptionalReturn2::begin_op(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__OptionalReturn2__op_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__OptionalReturn2__op_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__OptionalReturn2__op_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn2::end_op(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__OptionalReturn2__op_name);
    IceUtil::Optional< ::Ice::Int> __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(1, __ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::OptionalReturn2::ice_staticId()
{
    return ::Test::OptionalReturn2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::OptionalReturn2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::OptionalReturn2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::OptionalReturn2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::OptionalReturn2);
}

::IceProxy::Ice::Object*
IceProxy::Test::OptionalReturn2::__newInstance() const
{
    return new OptionalReturn2;
}

void
IceDelegateM::Test::BaseClass1::baseOp1(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass1__baseOp1_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass1__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass2__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass2__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass3::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass3__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass3::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass3__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass4::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass4__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass4::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass4__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass5::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass5__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass5::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass5__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass6::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass6__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass6::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass6__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass7::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass7__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass7::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass7__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass8::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass8__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass8::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass8__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass9::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass9__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass9::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass9__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass10::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass10__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass10::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass10__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::BaseClass11::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass11__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::BaseClass11::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__BaseClass11__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Compact1::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact1__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Compact1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact1__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Compact2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact2__baseOp_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::Compact2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Compact2__baseOp2_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(i);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(s);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::OptionalParameters0::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters0__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::OptionalParameters1::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters1__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, secondName);
        __os->write(2, emailAddress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::OptionalParameters2::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters2__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(1, emailAddress);
        __os->write(2, secondName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Test::OptionalParameters3::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalParameters3__op1_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(firstName);
        __os->write(secondName);
        __os->write(1, emailAddress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

IceUtil::Optional< ::Ice::Int>
IceDelegateM::Test::OptionalReturn0::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalReturn0__op_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    IceUtil::Optional< ::Ice::Int> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(1, __ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

IceUtil::Optional< ::Ice::Int>
IceDelegateM::Test::OptionalReturn2::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__OptionalReturn2__op_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    IceUtil::Optional< ::Ice::Int> __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(1, __ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::Test::BaseClass1::baseOp1(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass1* servant = dynamic_cast< ::Test::BaseClass1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp1(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass1__baseOp1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass1* servant = dynamic_cast< ::Test::BaseClass1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass1__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass2* servant = dynamic_cast< ::Test::BaseClass2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass2__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass2* servant = dynamic_cast< ::Test::BaseClass2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass2__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass3::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass3* servant = dynamic_cast< ::Test::BaseClass3*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass3__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass3::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass3* servant = dynamic_cast< ::Test::BaseClass3*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass3__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass4::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass4* servant = dynamic_cast< ::Test::BaseClass4*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass4__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass4::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass4* servant = dynamic_cast< ::Test::BaseClass4*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass4__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass5::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass5* servant = dynamic_cast< ::Test::BaseClass5*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass5__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass5::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass5* servant = dynamic_cast< ::Test::BaseClass5*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass5__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass6::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass6* servant = dynamic_cast< ::Test::BaseClass6*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass6__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass6::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass6* servant = dynamic_cast< ::Test::BaseClass6*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass6__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass7::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass7* servant = dynamic_cast< ::Test::BaseClass7*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass7__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass7::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass7* servant = dynamic_cast< ::Test::BaseClass7*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass7__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass8::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass8* servant = dynamic_cast< ::Test::BaseClass8*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass8__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass8::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass8* servant = dynamic_cast< ::Test::BaseClass8*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass8__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass9::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass9* servant = dynamic_cast< ::Test::BaseClass9*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass9__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass9::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass9* servant = dynamic_cast< ::Test::BaseClass9*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass9__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass10::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass10* servant = dynamic_cast< ::Test::BaseClass10*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass10__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass10::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass10* servant = dynamic_cast< ::Test::BaseClass10*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass10__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass11::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass11* servant = dynamic_cast< ::Test::BaseClass11*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass11__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::BaseClass11::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::BaseClass11* servant = dynamic_cast< ::Test::BaseClass11*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__BaseClass11__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact1::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact1* servant = dynamic_cast< ::Test::Compact1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact1__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact1::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact1* servant = dynamic_cast< ::Test::Compact1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact1__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact2::baseOp(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact2* servant = dynamic_cast< ::Test::Compact2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->baseOp(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact2__baseOp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Compact2::baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_i, ::std::string& __p_s, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_i(__p_i),
            _m_s(__p_s)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Compact2* servant = dynamic_cast< ::Test::Compact2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->baseOp2(_m_i, _m_s, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int _m_i;
        ::std::string& _m_s;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Compact2__baseOp2_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(i, s, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Exception1&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters0::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const IceUtil::Optional< ::std::string>& __p_secondName, const IceUtil::Optional< ::std::string>& __p_emailAddress, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_secondName(__p_secondName),
            _m_emailAddress(__p_emailAddress)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters0* servant = dynamic_cast< ::Test::OptionalParameters0*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_secondName, _m_emailAddress, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const IceUtil::Optional< ::std::string>& _m_secondName;
        const IceUtil::Optional< ::std::string>& _m_emailAddress;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters0__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, secondName, emailAddress, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters1::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const IceUtil::Optional< ::std::string>& __p_secondName, const IceUtil::Optional< ::std::string>& __p_emailAddress, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_secondName(__p_secondName),
            _m_emailAddress(__p_emailAddress)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters1* servant = dynamic_cast< ::Test::OptionalParameters1*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_secondName, _m_emailAddress, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const IceUtil::Optional< ::std::string>& _m_secondName;
        const IceUtil::Optional< ::std::string>& _m_emailAddress;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters1__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, secondName, emailAddress, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters2::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const IceUtil::Optional< ::std::string>& __p_emailAddress, const IceUtil::Optional< ::std::string>& __p_secondName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_emailAddress(__p_emailAddress),
            _m_secondName(__p_secondName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters2* servant = dynamic_cast< ::Test::OptionalParameters2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_emailAddress, _m_secondName, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const IceUtil::Optional< ::std::string>& _m_emailAddress;
        const IceUtil::Optional< ::std::string>& _m_secondName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters2__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, emailAddress, secondName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::OptionalParameters3::op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_firstName, const IceUtil::Optional< ::std::string>& __p_emailAddress, const ::std::string& __p_secondName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_firstName(__p_firstName),
            _m_emailAddress(__p_emailAddress),
            _m_secondName(__p_secondName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalParameters3* servant = dynamic_cast< ::Test::OptionalParameters3*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->op1(_m_firstName, _m_emailAddress, _m_secondName, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_firstName;
        const IceUtil::Optional< ::std::string>& _m_emailAddress;
        const ::std::string& _m_secondName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalParameters3__op1_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(firstName, emailAddress, secondName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

IceUtil::Optional< ::Ice::Int>
IceDelegateD::Test::OptionalReturn0::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(IceUtil::Optional< ::Ice::Int>& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalReturn0* servant = dynamic_cast< ::Test::OptionalReturn0*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->op(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        IceUtil::Optional< ::Ice::Int>& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalReturn0__op_name, ::Ice::Normal, __context);
    IceUtil::Optional< ::Ice::Int> __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

IceUtil::Optional< ::Ice::Int>
IceDelegateD::Test::OptionalReturn2::op(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(IceUtil::Optional< ::Ice::Int>& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::OptionalReturn2* servant = dynamic_cast< ::Test::OptionalReturn2*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->op(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        IceUtil::Optional< ::Ice::Int>& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__OptionalReturn2__op_name, ::Ice::Normal, __context);
    IceUtil::Optional< ::Ice::Int> __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Object* Test::upCast(::Test::Interface1* p) { return p; }

namespace
{
const ::std::string __Test__Interface1_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface1"
};

}

bool
Test::Interface1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface1_ids, __Test__Interface1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Interface1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface1_ids[0], &__Test__Interface1_ids[2]);
}

const ::std::string&
Test::Interface1::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface1_ids[1];
}

const ::std::string&
Test::Interface1::ice_staticId()
{
    return __Test__Interface1_ids[1];
}

void
Test::Interface1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(Interface1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Interface2* p) { return p; }

namespace
{
const ::std::string __Test__Interface2_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface2"
};

}

bool
Test::Interface2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface2_ids, __Test__Interface2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Interface2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface2_ids[0], &__Test__Interface2_ids[2]);
}

const ::std::string&
Test::Interface2::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface2_ids[1];
}

const ::std::string&
Test::Interface2::ice_staticId()
{
    return __Test__Interface2_ids[1];
}

void
Test::Interface2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(Interface2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Interface3* p) { return p; }

namespace
{
const ::std::string __Test__Interface3_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface3"
};

}

bool
Test::Interface3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface3_ids, __Test__Interface3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Interface3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface3_ids[0], &__Test__Interface3_ids[2]);
}

const ::std::string&
Test::Interface3::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface3_ids[1];
}

const ::std::string&
Test::Interface3::ice_staticId()
{
    return __Test__Interface3_ids[1];
}

void
Test::Interface3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(Interface3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Interface4* p) { return p; }

namespace
{
const ::std::string __Test__Interface4_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface4"
};

}

bool
Test::Interface4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Interface4_ids, __Test__Interface4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Interface4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Interface4_ids[0], &__Test__Interface4_ids[2]);
}

const ::std::string&
Test::Interface4::ice_id(const ::Ice::Current&) const
{
    return __Test__Interface4_ids[1];
}

const ::std::string&
Test::Interface4::ice_staticId()
{
    return __Test__Interface4_ids[1];
}

void
Test::Interface4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Interface4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(Interface4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Interface4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Interface4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass1* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass1::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass1"
};

}

bool
Test::EmptyClass1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass1_ids, __Test__EmptyClass1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass1_ids[0], &__Test__EmptyClass1_ids[2]);
}

const ::std::string&
Test::EmptyClass1::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass1_ids[1];
}

const ::std::string&
Test::EmptyClass1::ice_staticId()
{
    return __Test__EmptyClass1_ids[1];
}

void
Test::EmptyClass1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__EmptyClass1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass1::ice_staticId());
        return new ::Test::EmptyClass1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass1_Ptr = new __F__Test__EmptyClass1;

class __F__Test__EmptyClass1__Init
{
public:

    __F__Test__EmptyClass1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass1::ice_staticId(), __F__Test__EmptyClass1_Ptr);
    }

    ~__F__Test__EmptyClass1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass1::ice_staticId());
    }
};

const __F__Test__EmptyClass1__Init __F__Test__EmptyClass1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass1::ice_factory()
{
    return __F__Test__EmptyClass1_Ptr;
}

void 
Test::__patch(EmptyClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass2* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass2::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass2"
};

}

bool
Test::EmptyClass2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass2_ids, __Test__EmptyClass2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass2_ids[0], &__Test__EmptyClass2_ids[2]);
}

const ::std::string&
Test::EmptyClass2::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass2_ids[1];
}

const ::std::string&
Test::EmptyClass2::ice_staticId()
{
    return __Test__EmptyClass2_ids[1];
}

void
Test::EmptyClass2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__EmptyClass2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass2::ice_staticId());
        return new ::Test::EmptyClass2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass2_Ptr = new __F__Test__EmptyClass2;

class __F__Test__EmptyClass2__Init
{
public:

    __F__Test__EmptyClass2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass2::ice_staticId(), __F__Test__EmptyClass2_Ptr);
    }

    ~__F__Test__EmptyClass2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass2::ice_staticId());
    }
};

const __F__Test__EmptyClass2__Init __F__Test__EmptyClass2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass2::ice_factory()
{
    return __F__Test__EmptyClass2_Ptr;
}

void 
Test::__patch(EmptyClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass3* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass3::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass3(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass3"
};

}

bool
Test::EmptyClass3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass3_ids, __Test__EmptyClass3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass3_ids[0], &__Test__EmptyClass3_ids[2]);
}

const ::std::string&
Test::EmptyClass3::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass3_ids[1];
}

const ::std::string&
Test::EmptyClass3::ice_staticId()
{
    return __Test__EmptyClass3_ids[1];
}

void
Test::EmptyClass3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__EmptyClass3 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass3::ice_staticId());
        return new ::Test::EmptyClass3;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass3_Ptr = new __F__Test__EmptyClass3;

class __F__Test__EmptyClass3__Init
{
public:

    __F__Test__EmptyClass3__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass3::ice_staticId(), __F__Test__EmptyClass3_Ptr);
    }

    ~__F__Test__EmptyClass3__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass3::ice_staticId());
    }
};

const __F__Test__EmptyClass3__Init __F__Test__EmptyClass3__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass3::ice_factory()
{
    return __F__Test__EmptyClass3_Ptr;
}

void 
Test::__patch(EmptyClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass4* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass4::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass4_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass4"
};

}

bool
Test::EmptyClass4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass4_ids, __Test__EmptyClass4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass4_ids[0], &__Test__EmptyClass4_ids[2]);
}

const ::std::string&
Test::EmptyClass4::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass4_ids[1];
}

const ::std::string&
Test::EmptyClass4::ice_staticId()
{
    return __Test__EmptyClass4_ids[1];
}

void
Test::EmptyClass4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__EmptyClass4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass4::ice_staticId());
        return new ::Test::EmptyClass4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass4_Ptr = new __F__Test__EmptyClass4;

class __F__Test__EmptyClass4__Init
{
public:

    __F__Test__EmptyClass4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass4::ice_staticId(), __F__Test__EmptyClass4_Ptr);
    }

    ~__F__Test__EmptyClass4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass4::ice_staticId());
    }
};

const __F__Test__EmptyClass4__Init __F__Test__EmptyClass4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass4::ice_factory()
{
    return __F__Test__EmptyClass4_Ptr;
}

void 
Test::__patch(EmptyClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::EmptyClass5* p) { return p; }
::Ice::ObjectPtr
Test::EmptyClass5::ice_clone() const
{
    ::Ice::Object* __p = new EmptyClass5(*this);
    return __p;
}

namespace
{
const ::std::string __Test__EmptyClass5_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass5"
};

}

bool
Test::EmptyClass5::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__EmptyClass5_ids, __Test__EmptyClass5_ids + 2, _s);
}

::std::vector< ::std::string>
Test::EmptyClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__EmptyClass5_ids[0], &__Test__EmptyClass5_ids[2]);
}

const ::std::string&
Test::EmptyClass5::ice_id(const ::Ice::Current&) const
{
    return __Test__EmptyClass5_ids[1];
}

const ::std::string&
Test::EmptyClass5::ice_staticId()
{
    return __Test__EmptyClass5_ids[1];
}

void
Test::EmptyClass5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::EmptyClass5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__EmptyClass5 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::EmptyClass5::ice_staticId());
        return new ::Test::EmptyClass5;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__EmptyClass5_Ptr = new __F__Test__EmptyClass5;

class __F__Test__EmptyClass5__Init
{
public:

    __F__Test__EmptyClass5__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::EmptyClass5::ice_staticId(), __F__Test__EmptyClass5_Ptr);
    }

    ~__F__Test__EmptyClass5__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::EmptyClass5::ice_staticId());
    }
};

const __F__Test__EmptyClass5__Init __F__Test__EmptyClass5__i;

}

const ::Ice::ObjectFactoryPtr&
Test::EmptyClass5::ice_factory()
{
    return __F__Test__EmptyClass5_Ptr;
}

void 
Test::__patch(EmptyClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::EmptyClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::EmptyClass5::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass1* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass1::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass1"
};

}

bool
Test::SimpleClass1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass1_ids, __Test__SimpleClass1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass1_ids[0], &__Test__SimpleClass1_ids[2]);
}

const ::std::string&
Test::SimpleClass1::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass1_ids[1];
}

const ::std::string&
Test::SimpleClass1::ice_staticId()
{
    return __Test__SimpleClass1_ids[1];
}

void
Test::SimpleClass1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass1::ice_staticId());
        return new ::Test::SimpleClass1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass1_Ptr = new __F__Test__SimpleClass1;

class __F__Test__SimpleClass1__Init
{
public:

    __F__Test__SimpleClass1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass1::ice_staticId(), __F__Test__SimpleClass1_Ptr);
    }

    ~__F__Test__SimpleClass1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass1::ice_staticId());
    }
};

const __F__Test__SimpleClass1__Init __F__Test__SimpleClass1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass1::ice_factory()
{
    return __F__Test__SimpleClass1_Ptr;
}

void 
Test::__patch(SimpleClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass2* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass2::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass2"
};

}

bool
Test::SimpleClass2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass2_ids, __Test__SimpleClass2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass2_ids[0], &__Test__SimpleClass2_ids[2]);
}

const ::std::string&
Test::SimpleClass2::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass2_ids[1];
}

const ::std::string&
Test::SimpleClass2::ice_staticId()
{
    return __Test__SimpleClass2_ids[1];
}

void
Test::SimpleClass2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass2::ice_staticId());
        return new ::Test::SimpleClass2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass2_Ptr = new __F__Test__SimpleClass2;

class __F__Test__SimpleClass2__Init
{
public:

    __F__Test__SimpleClass2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass2::ice_staticId(), __F__Test__SimpleClass2_Ptr);
    }

    ~__F__Test__SimpleClass2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass2::ice_staticId());
    }
};

const __F__Test__SimpleClass2__Init __F__Test__SimpleClass2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass2::ice_factory()
{
    return __F__Test__SimpleClass2_Ptr;
}

void 
Test::__patch(SimpleClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass3* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass3::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass3(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass3"
};

}

bool
Test::SimpleClass3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass3_ids, __Test__SimpleClass3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass3_ids[0], &__Test__SimpleClass3_ids[2]);
}

const ::std::string&
Test::SimpleClass3::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass3_ids[1];
}

const ::std::string&
Test::SimpleClass3::ice_staticId()
{
    return __Test__SimpleClass3_ids[1];
}

void
Test::SimpleClass3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass3 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass3::ice_staticId());
        return new ::Test::SimpleClass3;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass3_Ptr = new __F__Test__SimpleClass3;

class __F__Test__SimpleClass3__Init
{
public:

    __F__Test__SimpleClass3__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass3::ice_staticId(), __F__Test__SimpleClass3_Ptr);
    }

    ~__F__Test__SimpleClass3__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass3::ice_staticId());
    }
};

const __F__Test__SimpleClass3__Init __F__Test__SimpleClass3__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass3::ice_factory()
{
    return __F__Test__SimpleClass3_Ptr;
}

void 
Test::__patch(SimpleClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass4* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass4::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass4_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass4"
};

}

bool
Test::SimpleClass4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass4_ids, __Test__SimpleClass4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass4_ids[0], &__Test__SimpleClass4_ids[2]);
}

const ::std::string&
Test::SimpleClass4::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass4_ids[1];
}

const ::std::string&
Test::SimpleClass4::ice_staticId()
{
    return __Test__SimpleClass4_ids[1];
}

void
Test::SimpleClass4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass4::ice_staticId());
        return new ::Test::SimpleClass4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass4_Ptr = new __F__Test__SimpleClass4;

class __F__Test__SimpleClass4__Init
{
public:

    __F__Test__SimpleClass4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass4::ice_staticId(), __F__Test__SimpleClass4_Ptr);
    }

    ~__F__Test__SimpleClass4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass4::ice_staticId());
    }
};

const __F__Test__SimpleClass4__Init __F__Test__SimpleClass4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass4::ice_factory()
{
    return __F__Test__SimpleClass4_Ptr;
}

void 
Test::__patch(SimpleClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass5* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass5::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass5(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass5_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass5"
};

}

bool
Test::SimpleClass5::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass5_ids, __Test__SimpleClass5_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass5_ids[0], &__Test__SimpleClass5_ids[2]);
}

const ::std::string&
Test::SimpleClass5::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass5_ids[1];
}

const ::std::string&
Test::SimpleClass5::ice_staticId()
{
    return __Test__SimpleClass5_ids[1];
}

void
Test::SimpleClass5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass5 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass5::ice_staticId());
        return new ::Test::SimpleClass5;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass5_Ptr = new __F__Test__SimpleClass5;

class __F__Test__SimpleClass5__Init
{
public:

    __F__Test__SimpleClass5__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass5::ice_staticId(), __F__Test__SimpleClass5_Ptr);
    }

    ~__F__Test__SimpleClass5__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass5::ice_staticId());
    }
};

const __F__Test__SimpleClass5__Init __F__Test__SimpleClass5__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass5::ice_factory()
{
    return __F__Test__SimpleClass5_Ptr;
}

void 
Test::__patch(SimpleClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass5::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass6* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass6::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass6(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass6_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass6"
};

}

bool
Test::SimpleClass6::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass6_ids, __Test__SimpleClass6_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass6_ids[0], &__Test__SimpleClass6_ids[2]);
}

const ::std::string&
Test::SimpleClass6::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass6_ids[1];
}

const ::std::string&
Test::SimpleClass6::ice_staticId()
{
    return __Test__SimpleClass6_ids[1];
}

void
Test::SimpleClass6::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass6::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass6 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass6::ice_staticId());
        return new ::Test::SimpleClass6;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass6_Ptr = new __F__Test__SimpleClass6;

class __F__Test__SimpleClass6__Init
{
public:

    __F__Test__SimpleClass6__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass6::ice_staticId(), __F__Test__SimpleClass6_Ptr);
    }

    ~__F__Test__SimpleClass6__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass6::ice_staticId());
    }
};

const __F__Test__SimpleClass6__Init __F__Test__SimpleClass6__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass6::ice_factory()
{
    return __F__Test__SimpleClass6_Ptr;
}

void 
Test::__patch(SimpleClass6Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass6Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass6::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SimpleClass7* p) { return p; }
::Ice::ObjectPtr
Test::SimpleClass7::ice_clone() const
{
    ::Ice::Object* __p = new SimpleClass7(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SimpleClass7_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass7"
};

}

bool
Test::SimpleClass7::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SimpleClass7_ids, __Test__SimpleClass7_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SimpleClass7::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SimpleClass7_ids[0], &__Test__SimpleClass7_ids[2]);
}

const ::std::string&
Test::SimpleClass7::ice_id(const ::Ice::Current&) const
{
    return __Test__SimpleClass7_ids[1];
}

const ::std::string&
Test::SimpleClass7::ice_staticId()
{
    return __Test__SimpleClass7_ids[1];
}

void
Test::SimpleClass7::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(str);
    __os->write(f);
    __os->endWriteSlice();
}

void
Test::SimpleClass7::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(str);
    __is->read(f);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SimpleClass7 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SimpleClass7::ice_staticId());
        return new ::Test::SimpleClass7;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SimpleClass7_Ptr = new __F__Test__SimpleClass7;

class __F__Test__SimpleClass7__Init
{
public:

    __F__Test__SimpleClass7__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SimpleClass7::ice_staticId(), __F__Test__SimpleClass7_Ptr);
    }

    ~__F__Test__SimpleClass7__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SimpleClass7::ice_staticId());
    }
};

const __F__Test__SimpleClass7__Init __F__Test__SimpleClass7__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SimpleClass7::ice_factory()
{
    return __F__Test__SimpleClass7_Ptr;
}

void 
Test::__patch(SimpleClass7Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SimpleClass7Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SimpleClass7::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass1* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass1"
};

}

bool
Test::BaseClass1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass1_ids, __Test__BaseClass1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass1_ids[0], &__Test__BaseClass1_ids[2]);
}

const ::std::string&
Test::BaseClass1::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass1_ids[1];
}

const ::std::string&
Test::BaseClass1::ice_staticId()
{
    return __Test__BaseClass1_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass1::___baseOp1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp1(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass1::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass1_all[] =
{
    "baseOp1",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass1_all, __Test__BaseClass1_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass1_all)
    {
        case 0:
        {
            return ___baseOp1(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass2* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass2"
};

}

bool
Test::BaseClass2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass2_ids, __Test__BaseClass2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass2_ids[0], &__Test__BaseClass2_ids[2]);
}

const ::std::string&
Test::BaseClass2::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass2_ids[1];
}

const ::std::string&
Test::BaseClass2::ice_staticId()
{
    return __Test__BaseClass2_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass2::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass2::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass2_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass2_all, __Test__BaseClass2_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass2_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass3* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass3::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass3"
};

}

bool
Test::BaseClass3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass3_ids, __Test__BaseClass3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass3_ids[0], &__Test__BaseClass3_ids[2]);
}

const ::std::string&
Test::BaseClass3::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass3_ids[1];
}

const ::std::string&
Test::BaseClass3::ice_staticId()
{
    return __Test__BaseClass3_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass3::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass3::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass3_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass3::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass3_all, __Test__BaseClass3_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass3_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass4* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass4::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass4_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass4"
};

}

bool
Test::BaseClass4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass4_ids, __Test__BaseClass4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass4_ids[0], &__Test__BaseClass4_ids[2]);
}

const ::std::string&
Test::BaseClass4::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass4_ids[1];
}

const ::std::string&
Test::BaseClass4::ice_staticId()
{
    return __Test__BaseClass4_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass4::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass4::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass4_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass4::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass4_all, __Test__BaseClass4_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass4_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass5* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass5::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass5_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass5"
};

}

bool
Test::BaseClass5::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass5_ids, __Test__BaseClass5_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass5_ids[0], &__Test__BaseClass5_ids[2]);
}

const ::std::string&
Test::BaseClass5::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass5_ids[1];
}

const ::std::string&
Test::BaseClass5::ice_staticId()
{
    return __Test__BaseClass5_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass5::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass5::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass5_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass5::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass5_all, __Test__BaseClass5_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass5_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass5::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass5::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass5::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass6* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass6::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass6_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass6"
};

}

bool
Test::BaseClass6::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass6_ids, __Test__BaseClass6_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass6_ids[0], &__Test__BaseClass6_ids[2]);
}

const ::std::string&
Test::BaseClass6::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass6_ids[1];
}

const ::std::string&
Test::BaseClass6::ice_staticId()
{
    return __Test__BaseClass6_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass6::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass6::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass6_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass6::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass6_all, __Test__BaseClass6_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass6_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass6::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass6::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass6Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass6Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass6::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass7* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass7::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass7_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass7"
};

}

bool
Test::BaseClass7::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass7_ids, __Test__BaseClass7_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass7::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass7_ids[0], &__Test__BaseClass7_ids[2]);
}

const ::std::string&
Test::BaseClass7::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass7_ids[1];
}

const ::std::string&
Test::BaseClass7::ice_staticId()
{
    return __Test__BaseClass7_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass7::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass7::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass7_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass7::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass7_all, __Test__BaseClass7_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass7_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass7::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass7::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass7Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass7Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass7::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass8* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass8::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass8_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass8"
};

}

bool
Test::BaseClass8::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass8_ids, __Test__BaseClass8_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass8::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass8_ids[0], &__Test__BaseClass8_ids[2]);
}

const ::std::string&
Test::BaseClass8::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass8_ids[1];
}

const ::std::string&
Test::BaseClass8::ice_staticId()
{
    return __Test__BaseClass8_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass8::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass8::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass8_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass8::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass8_all, __Test__BaseClass8_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass8_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass8::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass8::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass8Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass8Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass8::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass9* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass9::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass9_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass9"
};

}

bool
Test::BaseClass9::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass9_ids, __Test__BaseClass9_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass9::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass9_ids[0], &__Test__BaseClass9_ids[2]);
}

const ::std::string&
Test::BaseClass9::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass9_ids[1];
}

const ::std::string&
Test::BaseClass9::ice_staticId()
{
    return __Test__BaseClass9_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass9::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass9::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass9_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass9::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass9_all, __Test__BaseClass9_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass9_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass9::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass9::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass9Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass9Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass9::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass10* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass10::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass10_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass10"
};

}

bool
Test::BaseClass10::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass10_ids, __Test__BaseClass10_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass10::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass10_ids[0], &__Test__BaseClass10_ids[2]);
}

const ::std::string&
Test::BaseClass10::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass10_ids[1];
}

const ::std::string&
Test::BaseClass10::ice_staticId()
{
    return __Test__BaseClass10_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass10::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass10::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass10_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass10::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass10_all, __Test__BaseClass10_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass10_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass10::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass10::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass10Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass10Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass10::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::BaseClass11* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass11::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__BaseClass11_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass11"
};

}

bool
Test::BaseClass11::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass11_ids, __Test__BaseClass11_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass11::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass11_ids[0], &__Test__BaseClass11_ids[2]);
}

const ::std::string&
Test::BaseClass11::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass11_ids[1];
}

const ::std::string&
Test::BaseClass11::ice_staticId()
{
    return __Test__BaseClass11_ids[1];
}

::Ice::DispatchStatus
Test::BaseClass11::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::BaseClass11::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__BaseClass11_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::BaseClass11::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__BaseClass11_all, __Test__BaseClass11_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__BaseClass11_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::BaseClass11::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::BaseClass11::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(BaseClass11Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClass11Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass11::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Compact1* p) { return p; }
::Ice::ObjectPtr
Test::Compact1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__Compact1_ids[2] =
{
    "::Ice::Object",
    "::Test::Compact1"
};

}

bool
Test::Compact1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Compact1_ids, __Test__Compact1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Compact1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Compact1_ids[0], &__Test__Compact1_ids[2]);
}

const ::std::string&
Test::Compact1::ice_id(const ::Ice::Current&) const
{
    return __Test__Compact1_ids[1];
}

const ::std::string&
Test::Compact1::ice_staticId()
{
    return __Test__Compact1_ids[1];
}

::Ice::DispatchStatus
Test::Compact1::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::Compact1::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__Compact1_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::Compact1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Compact1_all, __Test__Compact1_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Compact1_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Compact1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), 1, true);
    __os->endWriteSlice();
}

void
Test::Compact1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Compact1__Init
{
public:

    __F__Test__Compact1__Init()
    {
        ::IceInternal::factoryTable->addTypeId(1, ::Test::Compact1::ice_staticId());
    }

    ~__F__Test__Compact1__Init()
    {
        ::IceInternal::factoryTable->removeTypeId(1);
    }
};

const __F__Test__Compact1__Init __F__Test__Compact1__i;

}

void 
Test::__patch(Compact1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Compact1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Compact1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Derived1* p) { return p; }
::Ice::ObjectPtr
Test::Derived1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__Derived1_ids[3] =
{
    "::Ice::Object",
    "::Test::Compact1",
    "::Test::Derived1"
};

}

bool
Test::Derived1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Derived1_ids, __Test__Derived1_ids + 3, _s);
}

::std::vector< ::std::string>
Test::Derived1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Derived1_ids[0], &__Test__Derived1_ids[3]);
}

const ::std::string&
Test::Derived1::ice_id(const ::Ice::Current&) const
{
    return __Test__Derived1_ids[2];
}

const ::std::string&
Test::Derived1::ice_staticId()
{
    return __Test__Derived1_ids[2];
}

namespace
{
const ::std::string __Test__Derived1_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::Derived1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Derived1_all, __Test__Derived1_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Derived1_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Derived1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::Test::Compact1::__writeImpl(__os);
}

void
Test::Derived1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Test::Compact1::__readImpl(__is);
}

void 
Test::__patch(Derived1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Derived1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Derived1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Compact2* p) { return p; }
::Ice::ObjectPtr
Test::Compact2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__Compact2_ids[2] =
{
    "::Ice::Object",
    "::Test::Compact2"
};

}

bool
Test::Compact2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Compact2_ids, __Test__Compact2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Compact2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Compact2_ids[0], &__Test__Compact2_ids[2]);
}

const ::std::string&
Test::Compact2::ice_id(const ::Ice::Current&) const
{
    return __Test__Compact2_ids[1];
}

const ::std::string&
Test::Compact2::ice_staticId()
{
    return __Test__Compact2_ids[1];
}

::Ice::DispatchStatus
Test::Compact2::___baseOp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    baseOp(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Test::Compact2::___baseOp2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int i;
    __is->read(i);
    __inS.endReadParams();
    ::std::string s;
    try
    {
        baseOp2(i, s, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(s);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Exception1& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__Compact2_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Test::Compact2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Compact2_all, __Test__Compact2_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Compact2_all)
    {
        case 0:
        {
            return ___baseOp(in, current);
        }
        case 1:
        {
            return ___baseOp2(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Compact2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), 2, true);
    __os->endWriteSlice();
}

void
Test::Compact2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

class __F__Test__Compact2__Init
{
public:

    __F__Test__Compact2__Init()
    {
        ::IceInternal::factoryTable->addTypeId(2, ::Test::Compact2::ice_staticId());
    }

    ~__F__Test__Compact2__Init()
    {
        ::IceInternal::factoryTable->removeTypeId(2);
    }
};

const __F__Test__Compact2__Init __F__Test__Compact2__i;

}

void 
Test::__patch(Compact2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Compact2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Compact2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional0* p) { return p; }
::Ice::ObjectPtr
Test::Optional0::ice_clone() const
{
    ::Ice::Object* __p = new Optional0(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional0_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional0"
};

}

bool
Test::Optional0::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional0_ids, __Test__Optional0_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional0_ids[0], &__Test__Optional0_ids[2]);
}

const ::std::string&
Test::Optional0::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional0_ids[1];
}

const ::std::string&
Test::Optional0::ice_staticId()
{
    return __Test__Optional0_ids[1];
}

void
Test::Optional0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::Optional0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional0 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional0::ice_staticId());
        return new ::Test::Optional0;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional0_Ptr = new __F__Test__Optional0;

class __F__Test__Optional0__Init
{
public:

    __F__Test__Optional0__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional0::ice_staticId(), __F__Test__Optional0_Ptr);
    }

    ~__F__Test__Optional0__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional0::ice_staticId());
    }
};

const __F__Test__Optional0__Init __F__Test__Optional0__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional0::ice_factory()
{
    return __F__Test__Optional0_Ptr;
}

void 
Test::__patch(Optional0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional0::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional1* p) { return p; }
::Ice::ObjectPtr
Test::Optional1::ice_clone() const
{
    ::Ice::Object* __p = new Optional1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional1_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional1"
};

}

bool
Test::Optional1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional1_ids, __Test__Optional1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional1_ids[0], &__Test__Optional1_ids[2]);
}

const ::std::string&
Test::Optional1::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional1_ids[1];
}

const ::std::string&
Test::Optional1::ice_staticId()
{
    return __Test__Optional1_ids[1];
}

void
Test::Optional1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::Optional1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional1::ice_staticId());
        return new ::Test::Optional1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional1_Ptr = new __F__Test__Optional1;

class __F__Test__Optional1__Init
{
public:

    __F__Test__Optional1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional1::ice_staticId(), __F__Test__Optional1_Ptr);
    }

    ~__F__Test__Optional1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional1::ice_staticId());
    }
};

const __F__Test__Optional1__Init __F__Test__Optional1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional1::ice_factory()
{
    return __F__Test__Optional1_Ptr;
}

void 
Test::__patch(Optional1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional2* p) { return p; }
::Ice::ObjectPtr
Test::Optional2::ice_clone() const
{
    ::Ice::Object* __p = new Optional2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional2_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional2"
};

}

bool
Test::Optional2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional2_ids, __Test__Optional2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional2_ids[0], &__Test__Optional2_ids[2]);
}

const ::std::string&
Test::Optional2::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional2_ids[1];
}

const ::std::string&
Test::Optional2::ice_staticId()
{
    return __Test__Optional2_ids[1];
}

void
Test::Optional2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(secondName);
    __os->write(1, emailAddress);
    __os->endWriteSlice();
}

void
Test::Optional2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(secondName);
    __is->read(1, emailAddress);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional2::ice_staticId());
        return new ::Test::Optional2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional2_Ptr = new __F__Test__Optional2;

class __F__Test__Optional2__Init
{
public:

    __F__Test__Optional2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional2::ice_staticId(), __F__Test__Optional2_Ptr);
    }

    ~__F__Test__Optional2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional2::ice_staticId());
    }
};

const __F__Test__Optional2__Init __F__Test__Optional2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional2::ice_factory()
{
    return __F__Test__Optional2_Ptr;
}

void 
Test::__patch(Optional2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional3* p) { return p; }
::Ice::ObjectPtr
Test::Optional3::ice_clone() const
{
    ::Ice::Object* __p = new Optional3(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional3_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional3"
};

}

bool
Test::Optional3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional3_ids, __Test__Optional3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional3_ids[0], &__Test__Optional3_ids[2]);
}

const ::std::string&
Test::Optional3::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional3_ids[1];
}

const ::std::string&
Test::Optional3::ice_staticId()
{
    return __Test__Optional3_ids[1];
}

void
Test::Optional3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::Optional3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional3 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional3::ice_staticId());
        return new ::Test::Optional3;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional3_Ptr = new __F__Test__Optional3;

class __F__Test__Optional3__Init
{
public:

    __F__Test__Optional3__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional3::ice_staticId(), __F__Test__Optional3_Ptr);
    }

    ~__F__Test__Optional3__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional3::ice_staticId());
    }
};

const __F__Test__Optional3__Init __F__Test__Optional3__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional3::ice_factory()
{
    return __F__Test__Optional3_Ptr;
}

void 
Test::__patch(Optional3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Optional4* p) { return p; }
::Ice::ObjectPtr
Test::Optional4::ice_clone() const
{
    ::Ice::Object* __p = new Optional4(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Optional4_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional4"
};

}

bool
Test::Optional4::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Optional4_ids, __Test__Optional4_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Optional4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Optional4_ids[0], &__Test__Optional4_ids[2]);
}

const ::std::string&
Test::Optional4::ice_id(const ::Ice::Current&) const
{
    return __Test__Optional4_ids[1];
}

const ::std::string&
Test::Optional4::ice_staticId()
{
    return __Test__Optional4_ids[1];
}

void
Test::Optional4::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(firstName);
    __os->write(1, secondName);
    __os->write(2, emailAddress);
    __os->endWriteSlice();
}

void
Test::Optional4::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __is->endReadSlice();
}

namespace
{

class __F__Test__Optional4 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Optional4::ice_staticId());
        return new ::Test::Optional4;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Optional4_Ptr = new __F__Test__Optional4;

class __F__Test__Optional4__Init
{
public:

    __F__Test__Optional4__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Optional4::ice_staticId(), __F__Test__Optional4_Ptr);
    }

    ~__F__Test__Optional4__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Optional4::ice_staticId());
    }
};

const __F__Test__Optional4__Init __F__Test__Optional4__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Optional4::ice_factory()
{
    return __F__Test__Optional4_Ptr;
}

void 
Test::__patch(Optional4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::Optional4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Optional4::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters0* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters0::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters0"
};

}

bool
Test::OptionalParameters0::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters0_ids, __Test__OptionalParameters0_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters0_ids[0], &__Test__OptionalParameters0_ids[2]);
}

const ::std::string&
Test::OptionalParameters0::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters0_ids[1];
}

const ::std::string&
Test::OptionalParameters0::ice_staticId()
{
    return __Test__OptionalParameters0_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters0::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __inS.endReadParams();
    op1(firstName, secondName, emailAddress, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters0_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters0::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters0_all, __Test__OptionalParameters0_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters0_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters0::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters1* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters1::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters1_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters1"
};

}

bool
Test::OptionalParameters1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters1_ids, __Test__OptionalParameters1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters1_ids[0], &__Test__OptionalParameters1_ids[2]);
}

const ::std::string&
Test::OptionalParameters1::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters1_ids[1];
}

const ::std::string&
Test::OptionalParameters1::ice_staticId()
{
    return __Test__OptionalParameters1_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters1::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;
    __is->read(firstName);
    __is->read(1, secondName);
    __is->read(2, emailAddress);
    __inS.endReadParams();
    op1(firstName, secondName, emailAddress, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters1_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters1::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters1_all, __Test__OptionalParameters1_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters1_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters2* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters2"
};

}

bool
Test::OptionalParameters2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters2_ids, __Test__OptionalParameters2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters2_ids[0], &__Test__OptionalParameters2_ids[2]);
}

const ::std::string&
Test::OptionalParameters2::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters2_ids[1];
}

const ::std::string&
Test::OptionalParameters2::ice_staticId()
{
    return __Test__OptionalParameters2_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters2::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    IceUtil::Optional< ::std::string> emailAddress;
    IceUtil::Optional< ::std::string> secondName;
    __is->read(firstName);
    __is->read(1, emailAddress);
    __is->read(2, secondName);
    __inS.endReadParams();
    op1(firstName, emailAddress, secondName, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters2_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters2_all, __Test__OptionalParameters2_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters2_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalParameters3* p) { return p; }
::Ice::ObjectPtr
Test::OptionalParameters3::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalParameters3_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters3"
};

}

bool
Test::OptionalParameters3::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalParameters3_ids, __Test__OptionalParameters3_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalParameters3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalParameters3_ids[0], &__Test__OptionalParameters3_ids[2]);
}

const ::std::string&
Test::OptionalParameters3::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalParameters3_ids[1];
}

const ::std::string&
Test::OptionalParameters3::ice_staticId()
{
    return __Test__OptionalParameters3_ids[1];
}

::Ice::DispatchStatus
Test::OptionalParameters3::___op1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string firstName;
    IceUtil::Optional< ::std::string> emailAddress;
    ::std::string secondName;
    __is->read(firstName);
    __is->read(secondName);
    __is->read(1, emailAddress);
    __inS.endReadParams();
    op1(firstName, emailAddress, secondName, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalParameters3_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

::Ice::DispatchStatus
Test::OptionalParameters3::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalParameters3_all, __Test__OptionalParameters3_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalParameters3_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op1(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalParameters3::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalParameters3::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalParameters3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalParameters3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalParameters3::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalReturn0* p) { return p; }
::Ice::ObjectPtr
Test::OptionalReturn0::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalReturn0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn0"
};

}

bool
Test::OptionalReturn0::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalReturn0_ids, __Test__OptionalReturn0_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalReturn0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalReturn0_ids[0], &__Test__OptionalReturn0_ids[2]);
}

const ::std::string&
Test::OptionalReturn0::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalReturn0_ids[1];
}

const ::std::string&
Test::OptionalReturn0::ice_staticId()
{
    return __Test__OptionalReturn0_ids[1];
}

::Ice::DispatchStatus
Test::OptionalReturn0::___op(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    IceUtil::Optional< ::Ice::Int> __ret = op(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(1, __ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalReturn0_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

::Ice::DispatchStatus
Test::OptionalReturn0::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalReturn0_all, __Test__OptionalReturn0_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalReturn0_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalReturn0::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalReturn0::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalReturn0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalReturn0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalReturn0::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::OptionalReturn2* p) { return p; }
::Ice::ObjectPtr
Test::OptionalReturn2::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

namespace
{
const ::std::string __Test__OptionalReturn2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn2"
};

}

bool
Test::OptionalReturn2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__OptionalReturn2_ids, __Test__OptionalReturn2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::OptionalReturn2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__OptionalReturn2_ids[0], &__Test__OptionalReturn2_ids[2]);
}

const ::std::string&
Test::OptionalReturn2::ice_id(const ::Ice::Current&) const
{
    return __Test__OptionalReturn2_ids[1];
}

const ::std::string&
Test::OptionalReturn2::ice_staticId()
{
    return __Test__OptionalReturn2_ids[1];
}

::Ice::DispatchStatus
Test::OptionalReturn2::___op(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    IceUtil::Optional< ::Ice::Int> __ret = op(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(1, __ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Test__OptionalReturn2_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

::Ice::DispatchStatus
Test::OptionalReturn2::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__OptionalReturn2_all, __Test__OptionalReturn2_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__OptionalReturn2_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___op(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::OptionalReturn2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::OptionalReturn2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(OptionalReturn2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::OptionalReturn2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::OptionalReturn2::ice_staticId(), v);
    }
}

::Ice::LocalObject* Test::upCast(::Test::LocalClass* p) { return p; }

namespace
{

const char* __sliceChecksums[] =
{
    "::Test::BaseClass1", "549369ef4c2bd57ce3288dca332f5",
    "::Test::BaseClass10", "09f46f8e8a894eef7b8d13dbc33559",
    "::Test::BaseClass11", "5044fd3afead4c3cb76494a89b14cd2",
    "::Test::BaseClass2", "9a2293639293e761c562bc94fbd12d3",
    "::Test::BaseClass3", "fe76102e274d32be3f9e861ed629fb4",
    "::Test::BaseClass4", "d635cff4795dd7f11fef8b42a889379d",
    "::Test::BaseClass5", "9a505744157f19afde1612dffe4e",
    "::Test::BaseClass6", "49cf89d9724171ba86e64bae309112",
    "::Test::BaseClass7", "ffd373e6ad79a2d3d247c2b94f316e1",
    "::Test::BaseClass8", "9f6e158cc99523956b777ce1b844222",
    "::Test::BaseClass9", "fb1ab274d74b33fcff7ac097863819",
    "::Test::Compact1", "53de5d6481876a2abc230cdaea2638b",
    "::Test::Compact2", "696e329581c3d3b21de44f641acecae",
    "::Test::Derived1", "70eb1c3578f9db4f8e3f2c663272eed4",
    "::Test::Dictionary1", "25699466bad619a2f36d47ebead5138b",
    "::Test::Dictionary2", "64b906033d7ca4dbd387d0c07e3e9b",
    "::Test::Dictionary3", "3e902c12e4e939341fe8a64e38318b2",
    "::Test::Dictionary4", "dc6e59f29abc431dd10de76727f89df",
    "::Test::EmptyClass1", "8b172e6bd6a916d80f922742ddb91",
    "::Test::EmptyClass2", "a6ef2a535f1c38a13196b94d59f17a9",
    "::Test::EmptyClass3", "81782b17e75755c94597618f35798c",
    "::Test::EmptyClass4", "34f47b795bed740249a91e3ff94a46e",
    "::Test::EmptyClass5", "b2e0dfb612c6282cb3433f1e5645be6",
    "::Test::Enum1", "6c81f7cbcd6b1917e5908e95de31f624",
    "::Test::Enum2", "30c421397a5b77107bbc63d8fbc93e",
    "::Test::Enum3", "7c44cf6b73b1227b9a7a8065cfc5e13b",
    "::Test::Enum4", "4d7e5b9643547b8f14aebd358bd7617",
    "::Test::EnumExplicit0", "3039549e3f1bd57f231277862c132af",
    "::Test::EnumExplicit1", "d2497a988932ca3252cdd87147807e",
    "::Test::EnumExplicit2", "74bef1d79dfda354517b3edb31b984",
    "::Test::EnumExplicit3", "e42a331ae4e71116c487e611a2faf747",
    "::Test::Exception1", "9d9d6d47575447abd7488352c9728",
    "::Test::Exception2", "6f50687469c9effafc1f8eeeff07983",
    "::Test::Exception3", "3f101b81b79b24d23927f3c40661c27",
    "::Test::Exception4", "878e40dcb4b583f7d74c843186f2c913",
    "::Test::Exception5", "1efde34768d88e2afcfa6392bb4caddc",
    "::Test::Exception6", "dfe05f784f23539daad5d7ab541e61",
    "::Test::IntConst1", "e67ad7c7baa8817a81f1ac6e8049f926",
    "::Test::IntConst2", "8e05717de5d9352b1b061b931a37a3a",
    "::Test::IntConst3", "1eac2f1f899d38ad18c7682831603872",
    "::Test::Interface1", "f3d458f98f8f3c9099202927c3647f",
    "::Test::Interface2", "93e96fe8a94d6126ef2d6b71afaa5678",
    "::Test::Interface3", "3a5f6dad7928ae4bd6a83188a846b7ef",
    "::Test::Interface4", "b1b6bf864f19ad39a3c7afd76a318",
    "::Test::Optional0", "4c424a20ee68c3cb2c183d0fe4b8496",
    "::Test::Optional1", "e44c9ae7f89c6872701fe83a5dfd77",
    "::Test::Optional2", "d4b3f1156aa023e5663f54764b70c544",
    "::Test::Optional3", "c6669908b1e3b9269af7da27ae8e8d7",
    "::Test::Optional4", "30c535f71f22a6227fa810919d80c7af",
    "::Test::OptionalEx0", "7cce6eadb31650882cd186a8aab38841",
    "::Test::OptionalEx1", "e6b928366b46ac34cfac9bfb597aeb6",
    "::Test::OptionalEx2", "b8767729edb4ce3cfca3ccd9dba6adc",
    "::Test::OptionalEx3", "d4e81cd32d68d03ed688f4438dd33cde",
    "::Test::OptionalEx4", "c647668a84a1fd26716d1a8ae3d57",
    "::Test::OptionalParameters0", "50218eebd7ae752b15f342bc2a7acd5d",
    "::Test::OptionalParameters1", "3cfa6491e6e6c26a981bb718bc9e8732",
    "::Test::OptionalParameters2", "beb314ed2d8ed28fd75ebde4511b70a4",
    "::Test::OptionalParameters3", "38ab11c8f8a9c9713c08d7bcc358ba",
    "::Test::OptionalReturn0", "ec318426ba8b88b35d6a667fdce3192",
    "::Test::OptionalReturn2", "f0871f5e54d441244e17afc1657da",
    "::Test::Sequence1", "945d43f4c73c2782de20223294c8e1",
    "::Test::Sequence2", "656baa26de92dd21eb9aa3e5ed277ff0",
    "::Test::Sequence3", "b3a15aecfbf756d93ae367a7f667fb",
    "::Test::SimpleClass1", "24c5fbaecf6c6261b139141bf2c3812d",
    "::Test::SimpleClass2", "5d43d8a01d64ee528446b3f4fa6bb4e",
    "::Test::SimpleClass3", "4043d34a805426eb5efebdec485bbf",
    "::Test::SimpleClass4", "901ebe68bb1cddb5ddf27db2b8e18c79",
    "::Test::SimpleClass5", "c1a2df6af3431222b77bbf5c196f",
    "::Test::SimpleClass6", "499768efb129c5c7beb4d649672b9d3",
    "::Test::SimpleClass7", "108bda784075ab447aa7b66aaaa349",
    "::Test::Struct1", "5b51361b27dbc3830afcfda19b8b2e8",
    "::Test::Struct2", "baa2cbf8c89a0a83782bb2a698b4660",
    "::Test::Struct3", "33c16c07a1214dfb9c7cbbea3673a2",
    "::Test::Struct4", "abc321876299dada7f34cfcffad33a",
    "::Test::Struct5", "6f795e75712aee13c6506f388cd76733",
    0
};
const IceInternal::SliceChecksumInit __sliceChecksumInit(__sliceChecksums);

}
