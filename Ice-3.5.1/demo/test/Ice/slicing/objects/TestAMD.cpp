// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <TestAMD.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SlicedData.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Test__TestIntf__SBaseAsObject_name = "SBaseAsObject";

const ::std::string __Test__TestIntf__SBaseAsSBase_name = "SBaseAsSBase";

const ::std::string __Test__TestIntf__SBSKnownDerivedAsSBase_name = "SBSKnownDerivedAsSBase";

const ::std::string __Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name = "SBSKnownDerivedAsSBSKnownDerived";

const ::std::string __Test__TestIntf__SBSUnknownDerivedAsSBase_name = "SBSUnknownDerivedAsSBase";

const ::std::string __Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name = "SBSUnknownDerivedAsSBaseCompact";

const ::std::string __Test__TestIntf__SUnknownAsObject_name = "SUnknownAsObject";

const ::std::string __Test__TestIntf__checkSUnknown_name = "checkSUnknown";

const ::std::string __Test__TestIntf__oneElementCycle_name = "oneElementCycle";

const ::std::string __Test__TestIntf__twoElementCycle_name = "twoElementCycle";

const ::std::string __Test__TestIntf__D1AsB_name = "D1AsB";

const ::std::string __Test__TestIntf__D1AsD1_name = "D1AsD1";

const ::std::string __Test__TestIntf__D2AsB_name = "D2AsB";

const ::std::string __Test__TestIntf__paramTest1_name = "paramTest1";

const ::std::string __Test__TestIntf__paramTest2_name = "paramTest2";

const ::std::string __Test__TestIntf__paramTest3_name = "paramTest3";

const ::std::string __Test__TestIntf__paramTest4_name = "paramTest4";

const ::std::string __Test__TestIntf__returnTest1_name = "returnTest1";

const ::std::string __Test__TestIntf__returnTest2_name = "returnTest2";

const ::std::string __Test__TestIntf__returnTest3_name = "returnTest3";

const ::std::string __Test__TestIntf__sequenceTest_name = "sequenceTest";

const ::std::string __Test__TestIntf__dictionaryTest_name = "dictionaryTest";

const ::std::string __Test__TestIntf__exchangePBase_name = "exchangePBase";

const ::std::string __Test__TestIntf__PBSUnknownAsPreserved_name = "PBSUnknownAsPreserved";

const ::std::string __Test__TestIntf__checkPBSUnknown_name = "checkPBSUnknown";

const ::std::string __Test__TestIntf__PBSUnknownAsPreservedWithGraph_name = "PBSUnknownAsPreservedWithGraph";

const ::std::string __Test__TestIntf__checkPBSUnknownWithGraph_name = "checkPBSUnknownWithGraph";

const ::std::string __Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name = "PBSUnknown2AsPreservedWithGraph";

const ::std::string __Test__TestIntf__checkPBSUnknown2WithGraph_name = "checkPBSUnknown2WithGraph";

const ::std::string __Test__TestIntf__exchangePNode_name = "exchangePNode";

const ::std::string __Test__TestIntf__throwBaseAsBase_name = "throwBaseAsBase";

const ::std::string __Test__TestIntf__throwDerivedAsBase_name = "throwDerivedAsBase";

const ::std::string __Test__TestIntf__throwDerivedAsDerived_name = "throwDerivedAsDerived";

const ::std::string __Test__TestIntf__throwUnknownDerivedAsBase_name = "throwUnknownDerivedAsBase";

const ::std::string __Test__TestIntf__throwPreservedException_name = "throwPreservedException";

const ::std::string __Test__TestIntf__useForward_name = "useForward";

const ::std::string __Test__TestIntf__shutdown_name = "shutdown";

}

namespace
{

const char* __Test__BaseException_name = "Test::BaseException";

struct __F__Test__BaseException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::BaseException();
    }
};

class __F__Test__BaseException__Init
{
public:

    __F__Test__BaseException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::BaseException", new __F__Test__BaseException);
    }

    ~__F__Test__BaseException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::BaseException");
    }
};

const __F__Test__BaseException__Init __F__Test__BaseException__i;

}

Test::BaseException::BaseException(const ::std::string& __ice_sbe, const ::Test::BPtr& __ice_pb) :
    ::Ice::UserException(),
    sbe(__ice_sbe),
    pb(__ice_pb)
{
}

Test::BaseException::~BaseException() throw()
{
}

::std::string
Test::BaseException::ice_name() const
{
    return __Test__BaseException_name;
}

Test::BaseException*
Test::BaseException::ice_clone() const
{
    return new BaseException(*this);
}

void
Test::BaseException::ice_throw() const
{
    throw *this;
}

bool
Test::BaseException::__usesClasses() const
{
    return true;
}

void
Test::BaseException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::BaseException", -1, true);
    __os->write(sbe);
    __os->write(pb);
    __os->endWriteSlice();
}

void
Test::BaseException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(sbe);
    __is->read(pb);
    __is->endReadSlice();
}

namespace
{

const char* __Test__DerivedException_name = "Test::DerivedException";

struct __F__Test__DerivedException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::DerivedException();
    }
};

class __F__Test__DerivedException__Init
{
public:

    __F__Test__DerivedException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::DerivedException", new __F__Test__DerivedException);
    }

    ~__F__Test__DerivedException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::DerivedException");
    }
};

const __F__Test__DerivedException__Init __F__Test__DerivedException__i;

}

Test::DerivedException::DerivedException(const ::std::string& __ice_sbe, const ::Test::BPtr& __ice_pb, const ::std::string& __ice_sde, const ::Test::D1Ptr& __ice_pd1) :
    ::Test::BaseException(__ice_sbe, __ice_pb),
    sde(__ice_sde),
    pd1(__ice_pd1)
{
}

Test::DerivedException::~DerivedException() throw()
{
}

::std::string
Test::DerivedException::ice_name() const
{
    return __Test__DerivedException_name;
}

Test::DerivedException*
Test::DerivedException::ice_clone() const
{
    return new DerivedException(*this);
}

void
Test::DerivedException::ice_throw() const
{
    throw *this;
}

void
Test::DerivedException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::DerivedException", -1, false);
    __os->write(sde);
    __os->write(pd1);
    __os->endWriteSlice();
    ::Test::BaseException::__writeImpl(__os);
}

void
Test::DerivedException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(sde);
    __is->read(pd1);
    __is->endReadSlice();
    ::Test::BaseException::__readImpl(__is);
}

namespace
{

const char* __Test__PreservedException_name = "Test::PreservedException";

struct __F__Test__PreservedException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::PreservedException();
    }
};

class __F__Test__PreservedException__Init
{
public:

    __F__Test__PreservedException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::PreservedException", new __F__Test__PreservedException);
    }

    ~__F__Test__PreservedException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::PreservedException");
    }
};

const __F__Test__PreservedException__Init __F__Test__PreservedException__i;

}

Test::PreservedException::~PreservedException() throw()
{
}

::std::string
Test::PreservedException::ice_name() const
{
    return __Test__PreservedException_name;
}

Test::PreservedException*
Test::PreservedException::ice_clone() const
{
    return new PreservedException(*this);
}

void
Test::PreservedException::ice_throw() const
{
    throw *this;
}

void
Test::PreservedException::__write(::IceInternal::BasicStream* __os) const
{
    __os->startWriteException(__slicedData);
    __writeImpl(__os);
    __os->endWriteException();
}

void
Test::PreservedException::__read(::IceInternal::BasicStream* __is)
{
    __is->startReadException();
    __readImpl(__is);
    __slicedData = __is->endReadException(true);
}

void
Test::PreservedException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::PreservedException", -1, true);
    __os->endWriteSlice();
}

void
Test::PreservedException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace Ice
{
}

IceAsync::Test::AMD_TestIntf_SBaseAsObject::AMD_TestIntf_SBaseAsObject(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBaseAsObject::ice_response(const ::Ice::ObjectPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_SBaseAsSBase::AMD_TestIntf_SBaseAsSBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBaseAsSBase::ice_response(const ::Test::SBasePtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBase::AMD_TestIntf_SBSKnownDerivedAsSBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBase::ice_response(const ::Test::SBasePtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived::ice_response(const ::Test::SBSKnownDerivedPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase::AMD_TestIntf_SBSUnknownDerivedAsSBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase::ice_response(const ::Test::SBasePtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact::ice_response(const ::Test::SBasePtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::CompactFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_SUnknownAsObject::AMD_TestIntf_SUnknownAsObject(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SUnknownAsObject::ice_response(const ::Ice::ObjectPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_checkSUnknown::AMD_TestIntf_checkSUnknown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkSUnknown::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_oneElementCycle::AMD_TestIntf_oneElementCycle(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_oneElementCycle::ice_response(const ::Test::BPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_twoElementCycle::AMD_TestIntf_twoElementCycle(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_twoElementCycle::ice_response(const ::Test::BPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_D1AsB::AMD_TestIntf_D1AsB(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_D1AsB::ice_response(const ::Test::BPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_D1AsD1::AMD_TestIntf_D1AsD1(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_D1AsD1::ice_response(const ::Test::D1Ptr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_D2AsB::AMD_TestIntf_D2AsB(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_D2AsB::ice_response(const ::Test::BPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_paramTest1::AMD_TestIntf_paramTest1(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest1::ice_response(const ::Test::BPtr& p1, const ::Test::BPtr& p2)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(p1);
            __os->write(p2);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_paramTest2::AMD_TestIntf_paramTest2(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest2::ice_response(const ::Test::BPtr& p2, const ::Test::BPtr& p1)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(p2);
            __os->write(p1);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_paramTest3::AMD_TestIntf_paramTest3(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest3::ice_response(const ::Test::BPtr& __ret, const ::Test::BPtr& p1, const ::Test::BPtr& p2)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(p1);
            __os->write(p2);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_paramTest4::AMD_TestIntf_paramTest4(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest4::ice_response(const ::Test::BPtr& __ret, const ::Test::BPtr& p)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(p);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_returnTest1::AMD_TestIntf_returnTest1(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_returnTest1::ice_response(const ::Test::BPtr& __ret, const ::Test::BPtr& p1, const ::Test::BPtr& p2)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(p1);
            __os->write(p2);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_returnTest2::AMD_TestIntf_returnTest2(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_returnTest2::ice_response(const ::Test::BPtr& __ret, const ::Test::BPtr& p2, const ::Test::BPtr& p1)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(p2);
            __os->write(p1);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_returnTest3::AMD_TestIntf_returnTest3(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_returnTest3::ice_response(const ::Test::BPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_sequenceTest::AMD_TestIntf_sequenceTest(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_sequenceTest::ice_response(const ::Test::SS3& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_dictionaryTest::AMD_TestIntf_dictionaryTest(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_dictionaryTest::ice_response(const ::Test::BDict& __ret, const ::Test::BDict& bout)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(bout);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_exchangePBase::AMD_TestIntf_exchangePBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_exchangePBase::ice_response(const ::Test::PBasePtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreserved::AMD_TestIntf_PBSUnknownAsPreserved(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreserved::ice_response(const ::Test::PreservedPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_checkPBSUnknown::AMD_TestIntf_checkPBSUnknown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkPBSUnknown::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph::AMD_TestIntf_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph::ice_response(const ::Test::PreservedPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_checkPBSUnknownWithGraph::AMD_TestIntf_checkPBSUnknownWithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkPBSUnknownWithGraph::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph::ice_response(const ::Test::PreservedPtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_checkPBSUnknown2WithGraph::AMD_TestIntf_checkPBSUnknown2WithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkPBSUnknown2WithGraph::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_exchangePNode::AMD_TestIntf_exchangePNode(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_exchangePNode::ice_response(const ::Test::PNodePtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_throwBaseAsBase::AMD_TestIntf_throwBaseAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwBaseAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_throwBaseAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::BaseException* __ex = dynamic_cast<const ::Test::BaseException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_throwDerivedAsBase::AMD_TestIntf_throwDerivedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwDerivedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_throwDerivedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::BaseException* __ex = dynamic_cast<const ::Test::BaseException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_throwDerivedAsDerived::AMD_TestIntf_throwDerivedAsDerived(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwDerivedAsDerived::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_throwDerivedAsDerived::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::DerivedException* __ex = dynamic_cast<const ::Test::DerivedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_throwUnknownDerivedAsBase::AMD_TestIntf_throwUnknownDerivedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwUnknownDerivedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_throwUnknownDerivedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::BaseException* __ex = dynamic_cast<const ::Test::BaseException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_throwPreservedException::AMD_TestIntf_throwPreservedException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwPreservedException::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_throwPreservedException::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::PreservedException* __ex = dynamic_cast<const ::Test::PreservedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_useForward::AMD_TestIntf_useForward(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_useForward::ice_response(const ::Test::ForwardPtr& f)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::SlicedFormat);
            __os->write(f);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Test::AMD_TestIntf_shutdown::AMD_TestIntf_shutdown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_shutdown::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SBase* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SBase>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SBase;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SBase::ice_staticId()
{
    return ::Test::SBase::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SBase::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SBase);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SBase::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SBase);
}

::IceProxy::Ice::Object*
IceProxy::Test::SBase::__newInstance() const
{
    return new SBase;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SBSKnownDerived* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SBSKnownDerived>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SBSKnownDerived;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SBSKnownDerived::ice_staticId()
{
    return ::Test::SBSKnownDerived::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SBSKnownDerived::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SBSKnownDerived);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SBSKnownDerived::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SBSKnownDerived);
}

::IceProxy::Ice::Object*
IceProxy::Test::SBSKnownDerived::__newInstance() const
{
    return new SBSKnownDerived;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::B* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::B>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::B;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::B::ice_staticId()
{
    return ::Test::B::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::B::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::B);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::B::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::B);
}

::IceProxy::Ice::Object*
IceProxy::Test::B::__newInstance() const
{
    return new B;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::D1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::D1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::D1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::D1::ice_staticId()
{
    return ::Test::D1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::D1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::D1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::D1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::D1);
}

::IceProxy::Ice::Object*
IceProxy::Test::D1::__newInstance() const
{
    return new D1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SS1* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SS1>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SS1;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SS1::ice_staticId()
{
    return ::Test::SS1::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SS1::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SS1);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SS1::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SS1);
}

::IceProxy::Ice::Object*
IceProxy::Test::SS1::__newInstance() const
{
    return new SS1;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::SS2* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::SS2>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::SS2;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::SS2::ice_staticId()
{
    return ::Test::SS2::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::SS2::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::SS2);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::SS2::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::SS2);
}

::IceProxy::Ice::Object*
IceProxy::Test::SS2::__newInstance() const
{
    return new SS2;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::PBase* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::PBase>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::PBase;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::PBase::ice_staticId()
{
    return ::Test::PBase::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::PBase::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::PBase);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::PBase::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::PBase);
}

::IceProxy::Ice::Object*
IceProxy::Test::PBase::__newInstance() const
{
    return new PBase;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Preserved* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Preserved>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Preserved;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::Preserved::ice_staticId()
{
    return ::Test::Preserved::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Preserved::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Preserved);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Preserved::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Preserved);
}

::IceProxy::Ice::Object*
IceProxy::Test::Preserved::__newInstance() const
{
    return new Preserved;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::PDerived* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::PDerived>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::PDerived;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::PDerived::ice_staticId()
{
    return ::Test::PDerived::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::PDerived::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::PDerived);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::PDerived::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::PDerived);
}

::IceProxy::Ice::Object*
IceProxy::Test::PDerived::__newInstance() const
{
    return new PDerived;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::PNode* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::PNode>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::PNode;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::PNode::ice_staticId()
{
    return ::Test::PNode::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::PNode::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::PNode);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::PNode::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::PNode);
}

::IceProxy::Ice::Object*
IceProxy::Test::PNode::__newInstance() const
{
    return new PNode;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::TestIntf* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::TestIntf;
        v->__copyFrom(proxy);
    }
}

::Ice::ObjectPtr
IceProxy::Test::TestIntf::SBaseAsObject(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__SBaseAsObject_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__SBaseAsObject_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->SBaseAsObject(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_SBaseAsObject(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__SBaseAsObject_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__SBaseAsObject_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__SBaseAsObject_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::ObjectPtr
IceProxy::Test::TestIntf::end_SBaseAsObject(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__SBaseAsObject_name);
    ::Ice::ObjectPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::SBasePtr
IceProxy::Test::TestIntf::SBaseAsSBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__SBaseAsSBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__SBaseAsSBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->SBaseAsSBase(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_SBaseAsSBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__SBaseAsSBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__SBaseAsSBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__SBaseAsSBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBaseAsSBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__SBaseAsSBase_name);
    ::Test::SBasePtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::SBasePtr
IceProxy::Test::TestIntf::SBSKnownDerivedAsSBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__SBSKnownDerivedAsSBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__SBSKnownDerivedAsSBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->SBSKnownDerivedAsSBase(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__SBSKnownDerivedAsSBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__SBSKnownDerivedAsSBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__SBSKnownDerivedAsSBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSKnownDerivedAsSBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__SBSKnownDerivedAsSBase_name);
    ::Test::SBasePtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::SBSKnownDerivedPtr
IceProxy::Test::TestIntf::SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->SBSKnownDerivedAsSBSKnownDerived(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::SBSKnownDerivedPtr
IceProxy::Test::TestIntf::end_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name);
    ::Test::SBSKnownDerivedPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::SBasePtr
IceProxy::Test::TestIntf::SBSUnknownDerivedAsSBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__SBSUnknownDerivedAsSBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__SBSUnknownDerivedAsSBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->SBSUnknownDerivedAsSBase(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__SBSUnknownDerivedAsSBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__SBSUnknownDerivedAsSBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__SBSUnknownDerivedAsSBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSUnknownDerivedAsSBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__SBSUnknownDerivedAsSBase_name);
    ::Test::SBasePtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::SBasePtr
IceProxy::Test::TestIntf::SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->SBSUnknownDerivedAsSBaseCompact(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSUnknownDerivedAsSBaseCompact(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name);
    ::Test::SBasePtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::ObjectPtr
IceProxy::Test::TestIntf::SUnknownAsObject(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__SUnknownAsObject_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__SUnknownAsObject_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->SUnknownAsObject(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_SUnknownAsObject(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__SUnknownAsObject_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__SUnknownAsObject_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__SUnknownAsObject_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::ObjectPtr
IceProxy::Test::TestIntf::end_SUnknownAsObject(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__SUnknownAsObject_name);
    ::Ice::ObjectPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__checkSUnknown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->checkSUnknown(o, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__checkSUnknown_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__checkSUnknown_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(o);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_checkSUnknown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__checkSUnknown_name);
}

::Test::BPtr
IceProxy::Test::TestIntf::oneElementCycle(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__oneElementCycle_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__oneElementCycle_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->oneElementCycle(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_oneElementCycle(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__oneElementCycle_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__oneElementCycle_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__oneElementCycle_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_oneElementCycle(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__oneElementCycle_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::twoElementCycle(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__twoElementCycle_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__twoElementCycle_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->twoElementCycle(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_twoElementCycle(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__twoElementCycle_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__twoElementCycle_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__twoElementCycle_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_twoElementCycle(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__twoElementCycle_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::D1AsB(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__D1AsB_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__D1AsB_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->D1AsB(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_D1AsB(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__D1AsB_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__D1AsB_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__D1AsB_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_D1AsB(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__D1AsB_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::D1Ptr
IceProxy::Test::TestIntf::D1AsD1(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__D1AsD1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__D1AsD1_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->D1AsD1(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_D1AsD1(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__D1AsD1_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__D1AsD1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__D1AsD1_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::D1Ptr
IceProxy::Test::TestIntf::end_D1AsD1(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__D1AsD1_name);
    ::Test::D1Ptr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::D2AsB(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__D2AsB_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__D2AsB_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->D2AsB(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_D2AsB(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__D2AsB_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__D2AsB_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__D2AsB_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_D2AsB(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__D2AsB_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__paramTest1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__paramTest1_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->paramTest1(p1, p2, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_paramTest1(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__paramTest1_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__paramTest1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__paramTest1_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__paramTest1_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(p1);
        __is->read(p2);
        __is->readPendingObjects();
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__paramTest2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__paramTest2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->paramTest2(p2, p1, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_paramTest2(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__paramTest2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__paramTest2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__paramTest2_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__paramTest2_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(p2);
        __is->read(p1);
        __is->readPendingObjects();
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__paramTest3_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__paramTest3_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->paramTest3(p1, p2, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_paramTest3(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__paramTest3_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__paramTest3_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__paramTest3_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__paramTest3_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(p1);
        __is->read(p2);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::paramTest4(::Test::BPtr& p, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__paramTest4_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__paramTest4_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->paramTest4(p, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_paramTest4(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__paramTest4_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__paramTest4_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__paramTest4_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_paramTest4(::Test::BPtr& p, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__paramTest4_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(p);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__returnTest1_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__returnTest1_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->returnTest1(p1, p2, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_returnTest1(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__returnTest1_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__returnTest1_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__returnTest1_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__returnTest1_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(p1);
        __is->read(p2);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__returnTest2_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__returnTest2_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->returnTest2(p2, p1, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_returnTest2(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__returnTest2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__returnTest2_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__returnTest2_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__returnTest2_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(p2);
        __is->read(p1);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BPtr
IceProxy::Test::TestIntf::returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__returnTest3_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__returnTest3_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->returnTest3(p1, p2, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__returnTest3_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__returnTest3_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__returnTest3_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(p1);
        __os->write(p2);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest3(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__returnTest3_name);
    ::Test::BPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::SS3
IceProxy::Test::TestIntf::sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__sequenceTest_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__sequenceTest_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->sequenceTest(p1, p2, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__sequenceTest_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__sequenceTest_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__sequenceTest_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(p1);
        __os->write(p2);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::SS3
IceProxy::Test::TestIntf::end_sequenceTest(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__sequenceTest_name);
    ::Test::SS3 __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::BDict
IceProxy::Test::TestIntf::dictionaryTest(const ::Test::BDict& bin, ::Test::BDict& bout, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__dictionaryTest_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__dictionaryTest_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->dictionaryTest(bin, bout, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__dictionaryTest_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__dictionaryTest_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__dictionaryTest_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(bin);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::BDict
IceProxy::Test::TestIntf::end_dictionaryTest(::Test::BDict& bout, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__dictionaryTest_name);
    ::Test::BDict __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(bout);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::PBasePtr
IceProxy::Test::TestIntf::exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__exchangePBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__exchangePBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->exchangePBase(pb, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__exchangePBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__exchangePBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__exchangePBase_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(pb);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::PBasePtr
IceProxy::Test::TestIntf::end_exchangePBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__exchangePBase_name);
    ::Test::PBasePtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::PBSUnknownAsPreserved(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__PBSUnknownAsPreserved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__PBSUnknownAsPreserved_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->PBSUnknownAsPreserved(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__PBSUnknownAsPreserved_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__PBSUnknownAsPreserved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__PBSUnknownAsPreserved_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknownAsPreserved(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__PBSUnknownAsPreserved_name);
    ::Test::PreservedPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__checkPBSUnknown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->checkPBSUnknown(p, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__checkPBSUnknown_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__checkPBSUnknown_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(p);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__checkPBSUnknown_name);
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::PBSUnknownAsPreservedWithGraph(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__PBSUnknownAsPreservedWithGraph_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__PBSUnknownAsPreservedWithGraph_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->PBSUnknownAsPreservedWithGraph(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__PBSUnknownAsPreservedWithGraph_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__PBSUnknownAsPreservedWithGraph_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__PBSUnknownAsPreservedWithGraph_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknownAsPreservedWithGraph(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__PBSUnknownAsPreservedWithGraph_name);
    ::Test::PreservedPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__checkPBSUnknownWithGraph_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->checkPBSUnknownWithGraph(p, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__checkPBSUnknownWithGraph_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__checkPBSUnknownWithGraph_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(p);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknownWithGraph(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__checkPBSUnknownWithGraph_name);
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::PBSUnknown2AsPreservedWithGraph(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->PBSUnknown2AsPreservedWithGraph(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknown2AsPreservedWithGraph(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name);
    ::Test::PreservedPtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__checkPBSUnknown2WithGraph_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->checkPBSUnknown2WithGraph(p, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__checkPBSUnknown2WithGraph_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__checkPBSUnknown2WithGraph_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(p);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknown2WithGraph(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__checkPBSUnknown2WithGraph_name);
}

::Test::PNodePtr
IceProxy::Test::TestIntf::exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__exchangePNode_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__exchangePNode_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            return __del->exchangePNode(pn, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__exchangePNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__exchangePNode_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__exchangePNode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(pn);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Test::PNodePtr
IceProxy::Test::TestIntf::end_exchangePNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__exchangePNode_name);
    ::Test::PNodePtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::throwBaseAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__throwBaseAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__throwBaseAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->throwBaseAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_throwBaseAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__throwBaseAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__throwBaseAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__throwBaseAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_throwBaseAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__throwBaseAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::throwDerivedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__throwDerivedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__throwDerivedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->throwDerivedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_throwDerivedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__throwDerivedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__throwDerivedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__throwDerivedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_throwDerivedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__throwDerivedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::throwDerivedAsDerived(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__throwDerivedAsDerived_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__throwDerivedAsDerived_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->throwDerivedAsDerived(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_throwDerivedAsDerived(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__throwDerivedAsDerived_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__throwDerivedAsDerived_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__throwDerivedAsDerived_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_throwDerivedAsDerived(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__throwDerivedAsDerived_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::DerivedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::throwUnknownDerivedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__throwUnknownDerivedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__throwUnknownDerivedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->throwUnknownDerivedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__throwUnknownDerivedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__throwUnknownDerivedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__throwUnknownDerivedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_throwUnknownDerivedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__throwUnknownDerivedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::throwPreservedException(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__throwPreservedException_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__throwPreservedException_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->throwPreservedException(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_throwPreservedException(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__throwPreservedException_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__throwPreservedException_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__throwPreservedException_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_throwPreservedException(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__throwPreservedException_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::PreservedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::useForward(::Test::ForwardPtr& f, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__useForward_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__useForward_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->useForward(f, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_useForward(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__useForward_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__useForward_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__useForward_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_useForward(::Test::ForwardPtr& f, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__useForward_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(f);
        __is->readPendingObjects();
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__shutdown_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__shutdown_name);
}

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::TestIntf);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::TestIntf);
}

::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::__newInstance() const
{
    return new TestIntf;
}

::Ice::ObjectPtr
IceDelegateM::Test::TestIntf::SBaseAsObject(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__SBaseAsObject_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::ObjectPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::SBasePtr
IceDelegateM::Test::TestIntf::SBaseAsSBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__SBaseAsSBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::SBasePtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::SBasePtr
IceDelegateM::Test::TestIntf::SBSKnownDerivedAsSBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__SBSKnownDerivedAsSBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::SBasePtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::SBSKnownDerivedPtr
IceDelegateM::Test::TestIntf::SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__SBSKnownDerivedAsSBSKnownDerived_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::SBSKnownDerivedPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::SBasePtr
IceDelegateM::Test::TestIntf::SBSUnknownDerivedAsSBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__SBSUnknownDerivedAsSBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::SBasePtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::SBasePtr
IceDelegateM::Test::TestIntf::SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__SBSUnknownDerivedAsSBaseCompact_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::SBasePtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::ObjectPtr
IceDelegateM::Test::TestIntf::SUnknownAsObject(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__SUnknownAsObject_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::ObjectPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__checkSUnknown_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(o);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::oneElementCycle(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__oneElementCycle_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::twoElementCycle(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__twoElementCycle_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::D1AsB(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__D1AsB_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::D1Ptr
IceDelegateM::Test::TestIntf::D1AsD1(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__D1AsD1_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::D1Ptr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::D2AsB(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__D2AsB_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__paramTest1_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(p1);
        __is->read(p2);
        __is->readPendingObjects();
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__paramTest2_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(p2);
        __is->read(p1);
        __is->readPendingObjects();
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__paramTest3_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(p1);
        __is->read(p2);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::paramTest4(::Test::BPtr& p, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__paramTest4_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(p);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__returnTest1_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(p1);
        __is->read(p2);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__returnTest2_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(p2);
        __is->read(p1);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BPtr
IceDelegateM::Test::TestIntf::returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__returnTest3_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(p1);
        __os->write(p2);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::SS3
IceDelegateM::Test::TestIntf::sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__sequenceTest_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(p1);
        __os->write(p2);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::SS3 __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::BDict
IceDelegateM::Test::TestIntf::dictionaryTest(const ::Test::BDict& bin, ::Test::BDict& bout, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__dictionaryTest_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(bin);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::BDict __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(bout);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::PBasePtr
IceDelegateM::Test::TestIntf::exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__exchangePBase_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(pb);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::PBasePtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Test::PreservedPtr
IceDelegateM::Test::TestIntf::PBSUnknownAsPreserved(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__PBSUnknownAsPreserved_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::PreservedPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__checkPBSUnknown_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(p);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Test::PreservedPtr
IceDelegateM::Test::TestIntf::PBSUnknownAsPreservedWithGraph(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__PBSUnknownAsPreservedWithGraph_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::PreservedPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__checkPBSUnknownWithGraph_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(p);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Test::PreservedPtr
IceDelegateM::Test::TestIntf::PBSUnknown2AsPreservedWithGraph(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__PBSUnknown2AsPreservedWithGraph_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Test::PreservedPtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__checkPBSUnknown2WithGraph_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(p);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Test::PNodePtr
IceDelegateM::Test::TestIntf::exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__exchangePNode_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(pn);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Test::PNodePtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::throwBaseAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__throwBaseAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::throwDerivedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__throwDerivedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::throwDerivedAsDerived(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__throwDerivedAsDerived_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::DerivedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::throwUnknownDerivedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__throwUnknownDerivedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::throwPreservedException(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__throwPreservedException_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::PreservedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::useForward(::Test::ForwardPtr& f, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__useForward_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(f);
        __is->readPendingObjects();
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__shutdown_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::ObjectPtr
IceDelegateD::Test::TestIntf::SBaseAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::ObjectPtr(); // to avoid a warning with some compilers;
}

::Test::SBasePtr
IceDelegateD::Test::TestIntf::SBaseAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::SBasePtr(); // to avoid a warning with some compilers;
}

::Test::SBasePtr
IceDelegateD::Test::TestIntf::SBSKnownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::SBasePtr(); // to avoid a warning with some compilers;
}

::Test::SBSKnownDerivedPtr
IceDelegateD::Test::TestIntf::SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::SBSKnownDerivedPtr(); // to avoid a warning with some compilers;
}

::Test::SBasePtr
IceDelegateD::Test::TestIntf::SBSUnknownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::SBasePtr(); // to avoid a warning with some compilers;
}

::Test::SBasePtr
IceDelegateD::Test::TestIntf::SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::SBasePtr(); // to avoid a warning with some compilers;
}

::Ice::ObjectPtr
IceDelegateD::Test::TestIntf::SUnknownAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::ObjectPtr(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::checkSUnknown(const ::Ice::ObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Test::BPtr
IceDelegateD::Test::TestIntf::oneElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::BPtr
IceDelegateD::Test::TestIntf::twoElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::BPtr
IceDelegateD::Test::TestIntf::D1AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::D1Ptr
IceDelegateD::Test::TestIntf::D1AsD1(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::D1Ptr(); // to avoid a warning with some compilers;
}

::Test::BPtr
IceDelegateD::Test::TestIntf::D2AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::paramTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::paramTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Test::BPtr
IceDelegateD::Test::TestIntf::paramTest3(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::BPtr
IceDelegateD::Test::TestIntf::paramTest4(::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::BPtr
IceDelegateD::Test::TestIntf::returnTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::BPtr
IceDelegateD::Test::TestIntf::returnTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::BPtr
IceDelegateD::Test::TestIntf::returnTest3(const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BPtr(); // to avoid a warning with some compilers;
}

::Test::SS3
IceDelegateD::Test::TestIntf::sequenceTest(const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::SS3(); // to avoid a warning with some compilers;
}

::Test::BDict
IceDelegateD::Test::TestIntf::dictionaryTest(const ::Test::BDict&, ::Test::BDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::BDict(); // to avoid a warning with some compilers;
}

::Test::PBasePtr
IceDelegateD::Test::TestIntf::exchangePBase(const ::Test::PBasePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::PBasePtr(); // to avoid a warning with some compilers;
}

::Test::PreservedPtr
IceDelegateD::Test::TestIntf::PBSUnknownAsPreserved(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::PreservedPtr(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::checkPBSUnknown(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Test::PreservedPtr
IceDelegateD::Test::TestIntf::PBSUnknownAsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::PreservedPtr(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::checkPBSUnknownWithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Test::PreservedPtr
IceDelegateD::Test::TestIntf::PBSUnknown2AsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::PreservedPtr(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::checkPBSUnknown2WithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Test::PNodePtr
IceDelegateD::Test::TestIntf::exchangePNode(const ::Test::PNodePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Test::PNodePtr(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Test::TestIntf::throwBaseAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::throwDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::throwDerivedAsDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::throwUnknownDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::throwPreservedException(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::useForward(::Test::ForwardPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Object* Test::upCast(::Test::SBase* p) { return p; }
::Ice::ObjectPtr
Test::SBase::ice_clone() const
{
    ::Ice::Object* __p = new SBase(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SBase_ids[2] =
{
    "::Ice::Object",
    "::Test::SBase"
};

}

bool
Test::SBase::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SBase_ids, __Test__SBase_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SBase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SBase_ids[0], &__Test__SBase_ids[2]);
}

const ::std::string&
Test::SBase::ice_id(const ::Ice::Current&) const
{
    return __Test__SBase_ids[1];
}

const ::std::string&
Test::SBase::ice_staticId()
{
    return __Test__SBase_ids[1];
}

void
Test::SBase::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(sb);
    __os->endWriteSlice();
}

void
Test::SBase::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(sb);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SBase : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SBase::ice_staticId());
        return new ::Test::SBase;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SBase_Ptr = new __F__Test__SBase;

class __F__Test__SBase__Init
{
public:

    __F__Test__SBase__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SBase::ice_staticId(), __F__Test__SBase_Ptr);
    }

    ~__F__Test__SBase__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SBase::ice_staticId());
    }
};

const __F__Test__SBase__Init __F__Test__SBase__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SBase::ice_factory()
{
    return __F__Test__SBase_Ptr;
}

void 
Test::__patch(SBasePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SBasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SBase::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SBSKnownDerived* p) { return p; }
::Ice::ObjectPtr
Test::SBSKnownDerived::ice_clone() const
{
    ::Ice::Object* __p = new SBSKnownDerived(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SBSKnownDerived_ids[3] =
{
    "::Ice::Object",
    "::Test::SBSKnownDerived",
    "::Test::SBase"
};

}

bool
Test::SBSKnownDerived::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SBSKnownDerived_ids, __Test__SBSKnownDerived_ids + 3, _s);
}

::std::vector< ::std::string>
Test::SBSKnownDerived::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SBSKnownDerived_ids[0], &__Test__SBSKnownDerived_ids[3]);
}

const ::std::string&
Test::SBSKnownDerived::ice_id(const ::Ice::Current&) const
{
    return __Test__SBSKnownDerived_ids[1];
}

const ::std::string&
Test::SBSKnownDerived::ice_staticId()
{
    return __Test__SBSKnownDerived_ids[1];
}

void
Test::SBSKnownDerived::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(sbskd);
    __os->endWriteSlice();
    ::Test::SBase::__writeImpl(__os);
}

void
Test::SBSKnownDerived::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(sbskd);
    __is->endReadSlice();
    ::Test::SBase::__readImpl(__is);
}

namespace
{

class __F__Test__SBSKnownDerived : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SBSKnownDerived::ice_staticId());
        return new ::Test::SBSKnownDerived;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SBSKnownDerived_Ptr = new __F__Test__SBSKnownDerived;

class __F__Test__SBSKnownDerived__Init
{
public:

    __F__Test__SBSKnownDerived__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SBSKnownDerived::ice_staticId(), __F__Test__SBSKnownDerived_Ptr);
    }

    ~__F__Test__SBSKnownDerived__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SBSKnownDerived::ice_staticId());
    }
};

const __F__Test__SBSKnownDerived__Init __F__Test__SBSKnownDerived__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SBSKnownDerived::ice_factory()
{
    return __F__Test__SBSKnownDerived_Ptr;
}

void 
Test::__patch(SBSKnownDerivedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SBSKnownDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SBSKnownDerived::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::B* p) { return p; }
::Ice::ObjectPtr
Test::B::ice_clone() const
{
    ::Ice::Object* __p = new B(*this);
    return __p;
}

namespace
{
const ::std::string __Test__B_ids[2] =
{
    "::Ice::Object",
    "::Test::B"
};

}

bool
Test::B::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__B_ids, __Test__B_ids + 2, _s);
}

::std::vector< ::std::string>
Test::B::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__B_ids[0], &__Test__B_ids[2]);
}

const ::std::string&
Test::B::ice_id(const ::Ice::Current&) const
{
    return __Test__B_ids[1];
}

const ::std::string&
Test::B::ice_staticId()
{
    return __Test__B_ids[1];
}

void
Test::B::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::B::__usesGC()
{
    return true;
}

void
Test::B::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(pb)
    {
        ::Test::upCast(pb.get())->__addObject(_c);
    }
}

void
Test::B::__gcClear()
{
    if(pb)
    {
        if(::Test::upCast(pb.get())->__usesGC())
        {
            ::Test::upCast(pb.get())->__decRefUnsafe();
            pb.__clearHandleUnsafe();
        }
        else
        {
            pb = 0;
        }
    }
}

void
Test::B::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(sb);
    __os->write(pb);
    __os->endWriteSlice();
}

void
Test::B::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(sb);
    __is->read(pb);
    __is->endReadSlice();
}

namespace
{

class __F__Test__B : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::B::ice_staticId());
        return new ::Test::B;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__B_Ptr = new __F__Test__B;

class __F__Test__B__Init
{
public:

    __F__Test__B__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::B::ice_staticId(), __F__Test__B_Ptr);
    }

    ~__F__Test__B__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::B::ice_staticId());
    }
};

const __F__Test__B__Init __F__Test__B__i;

}

const ::Ice::ObjectFactoryPtr&
Test::B::ice_factory()
{
    return __F__Test__B_Ptr;
}

void 
Test::__patch(BPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::B::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::D1* p) { return p; }
::Ice::ObjectPtr
Test::D1::ice_clone() const
{
    ::Ice::Object* __p = new D1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__D1_ids[3] =
{
    "::Ice::Object",
    "::Test::B",
    "::Test::D1"
};

}

bool
Test::D1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__D1_ids, __Test__D1_ids + 3, _s);
}

::std::vector< ::std::string>
Test::D1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__D1_ids[0], &__Test__D1_ids[3]);
}

const ::std::string&
Test::D1::ice_id(const ::Ice::Current&) const
{
    return __Test__D1_ids[2];
}

const ::std::string&
Test::D1::ice_staticId()
{
    return __Test__D1_ids[2];
}

void
Test::D1::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    ::Test::B::__gcReachable(_c);
    if(pd1)
    {
        ::Test::upCast(pd1.get())->__addObject(_c);
    }
}

void
Test::D1::__gcClear()
{
    ::Test::B::__gcClear();
    if(pd1)
    {
        if(::Test::upCast(pd1.get())->__usesGC())
        {
            ::Test::upCast(pd1.get())->__decRefUnsafe();
            pd1.__clearHandleUnsafe();
        }
        else
        {
            pd1 = 0;
        }
    }
}

void
Test::D1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(sd1);
    __os->write(pd1);
    __os->endWriteSlice();
    ::Test::B::__writeImpl(__os);
}

void
Test::D1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(sd1);
    __is->read(pd1);
    __is->endReadSlice();
    ::Test::B::__readImpl(__is);
}

namespace
{

class __F__Test__D1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::D1::ice_staticId());
        return new ::Test::D1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__D1_Ptr = new __F__Test__D1;

class __F__Test__D1__Init
{
public:

    __F__Test__D1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::D1::ice_staticId(), __F__Test__D1_Ptr);
    }

    ~__F__Test__D1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::D1::ice_staticId());
    }
};

const __F__Test__D1__Init __F__Test__D1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::D1::ice_factory()
{
    return __F__Test__D1_Ptr;
}

void 
Test::__patch(D1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::D1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::D1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SS1* p) { return p; }
::Ice::ObjectPtr
Test::SS1::ice_clone() const
{
    ::Ice::Object* __p = new SS1(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SS1_ids[2] =
{
    "::Ice::Object",
    "::Test::SS1"
};

}

bool
Test::SS1::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SS1_ids, __Test__SS1_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SS1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SS1_ids[0], &__Test__SS1_ids[2]);
}

const ::std::string&
Test::SS1::ice_id(const ::Ice::Current&) const
{
    return __Test__SS1_ids[1];
}

const ::std::string&
Test::SS1::ice_staticId()
{
    return __Test__SS1_ids[1];
}

void
Test::SS1::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::SS1::__usesGC()
{
    return true;
}

void
Test::SS1::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::Test::BSeq::const_iterator _i0 = s.begin(); _i0 != s.end(); ++_i0)
        {
            if((*_i0))
            {
                ::Test::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
}

void
Test::SS1::__gcClear()
{
    {
        for(::Test::BSeq::iterator _i0 = s.begin(); _i0 != s.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::Test::upCast((*_i0).get())->__usesGC())
                {
                    ::Test::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
Test::SS1::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(s);
    __os->endWriteSlice();
}

void
Test::SS1::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(s);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SS1 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SS1::ice_staticId());
        return new ::Test::SS1;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SS1_Ptr = new __F__Test__SS1;

class __F__Test__SS1__Init
{
public:

    __F__Test__SS1__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SS1::ice_staticId(), __F__Test__SS1_Ptr);
    }

    ~__F__Test__SS1__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SS1::ice_staticId());
    }
};

const __F__Test__SS1__Init __F__Test__SS1__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SS1::ice_factory()
{
    return __F__Test__SS1_Ptr;
}

void 
Test::__patch(SS1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SS1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SS1::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::SS2* p) { return p; }
::Ice::ObjectPtr
Test::SS2::ice_clone() const
{
    ::Ice::Object* __p = new SS2(*this);
    return __p;
}

namespace
{
const ::std::string __Test__SS2_ids[2] =
{
    "::Ice::Object",
    "::Test::SS2"
};

}

bool
Test::SS2::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__SS2_ids, __Test__SS2_ids + 2, _s);
}

::std::vector< ::std::string>
Test::SS2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__SS2_ids[0], &__Test__SS2_ids[2]);
}

const ::std::string&
Test::SS2::ice_id(const ::Ice::Current&) const
{
    return __Test__SS2_ids[1];
}

const ::std::string&
Test::SS2::ice_staticId()
{
    return __Test__SS2_ids[1];
}

void
Test::SS2::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::SS2::__usesGC()
{
    return true;
}

void
Test::SS2::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::Test::BSeq::const_iterator _i0 = s.begin(); _i0 != s.end(); ++_i0)
        {
            if((*_i0))
            {
                ::Test::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
}

void
Test::SS2::__gcClear()
{
    {
        for(::Test::BSeq::iterator _i0 = s.begin(); _i0 != s.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::Test::upCast((*_i0).get())->__usesGC())
                {
                    ::Test::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
Test::SS2::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(s);
    __os->endWriteSlice();
}

void
Test::SS2::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(s);
    __is->endReadSlice();
}

namespace
{

class __F__Test__SS2 : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::SS2::ice_staticId());
        return new ::Test::SS2;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__SS2_Ptr = new __F__Test__SS2;

class __F__Test__SS2__Init
{
public:

    __F__Test__SS2__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::SS2::ice_staticId(), __F__Test__SS2_Ptr);
    }

    ~__F__Test__SS2__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::SS2::ice_staticId());
    }
};

const __F__Test__SS2__Init __F__Test__SS2__i;

}

const ::Ice::ObjectFactoryPtr&
Test::SS2::ice_factory()
{
    return __F__Test__SS2_Ptr;
}

void 
Test::__patch(SS2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::SS2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::SS2::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::PBase* p) { return p; }
::Ice::ObjectPtr
Test::PBase::ice_clone() const
{
    ::Ice::Object* __p = new PBase(*this);
    return __p;
}

namespace
{
const ::std::string __Test__PBase_ids[2] =
{
    "::Ice::Object",
    "::Test::PBase"
};

}

bool
Test::PBase::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__PBase_ids, __Test__PBase_ids + 2, _s);
}

::std::vector< ::std::string>
Test::PBase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__PBase_ids[0], &__Test__PBase_ids[2]);
}

const ::std::string&
Test::PBase::ice_id(const ::Ice::Current&) const
{
    return __Test__PBase_ids[1];
}

const ::std::string&
Test::PBase::ice_staticId()
{
    return __Test__PBase_ids[1];
}

void
Test::PBase::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(pi);
    __os->endWriteSlice();
}

void
Test::PBase::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(pi);
    __is->endReadSlice();
}

namespace
{

class __F__Test__PBase : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::PBase::ice_staticId());
        return new ::Test::PBase;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__PBase_Ptr = new __F__Test__PBase;

class __F__Test__PBase__Init
{
public:

    __F__Test__PBase__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::PBase::ice_staticId(), __F__Test__PBase_Ptr);
    }

    ~__F__Test__PBase__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::PBase::ice_staticId());
    }
};

const __F__Test__PBase__Init __F__Test__PBase__i;

}

const ::Ice::ObjectFactoryPtr&
Test::PBase::ice_factory()
{
    return __F__Test__PBase_Ptr;
}

void 
Test::__patch(PBasePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::PBasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::PBase::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Preserved* p) { return p; }
::Ice::ObjectPtr
Test::Preserved::ice_clone() const
{
    ::Ice::Object* __p = new Preserved(*this);
    return __p;
}

namespace
{
const ::std::string __Test__Preserved_ids[3] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::Preserved"
};

}

bool
Test::Preserved::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Preserved_ids, __Test__Preserved_ids + 3, _s);
}

::std::vector< ::std::string>
Test::Preserved::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Preserved_ids[0], &__Test__Preserved_ids[3]);
}

const ::std::string&
Test::Preserved::ice_id(const ::Ice::Current&) const
{
    return __Test__Preserved_ids[2];
}

const ::std::string&
Test::Preserved::ice_staticId()
{
    return __Test__Preserved_ids[2];
}

void
Test::Preserved::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::Preserved::__usesGC()
{
    return true;
}

void
Test::Preserved::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(__slicedData)
    {
        __slicedData->__addObject(_c);
    }
}

void
Test::Preserved::__gcClear()
{
    if(__slicedData)
    {
        __slicedData->__decRefUnsafe();
        __slicedData.__clearHandleUnsafe();
    }
}

void
Test::Preserved::__write(::IceInternal::BasicStream* __os) const
{
    __os->startWriteObject(__slicedData);
    __writeImpl(__os);
    __os->endWriteObject();
}

void
Test::Preserved::__read(::IceInternal::BasicStream* __is)
{
    __is->startReadObject();
    __readImpl(__is);
    __slicedData = __is->endReadObject(true);
}

void
Test::Preserved::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(ps);
    __os->endWriteSlice();
    ::Test::PBase::__writeImpl(__os);
}

void
Test::Preserved::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(ps);
    __is->endReadSlice();
    ::Test::PBase::__readImpl(__is);
}

namespace
{

class __F__Test__Preserved : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::Preserved::ice_staticId());
        return new ::Test::Preserved;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__Preserved_Ptr = new __F__Test__Preserved;

class __F__Test__Preserved__Init
{
public:

    __F__Test__Preserved__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::Preserved::ice_staticId(), __F__Test__Preserved_Ptr);
    }

    ~__F__Test__Preserved__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::Preserved::ice_staticId());
    }
};

const __F__Test__Preserved__Init __F__Test__Preserved__i;

}

const ::Ice::ObjectFactoryPtr&
Test::Preserved::ice_factory()
{
    return __F__Test__Preserved_Ptr;
}

void 
Test::__patch(PreservedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::PreservedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Preserved::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::PDerived* p) { return p; }
::Ice::ObjectPtr
Test::PDerived::ice_clone() const
{
    ::Ice::Object* __p = new PDerived(*this);
    return __p;
}

namespace
{
const ::std::string __Test__PDerived_ids[4] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::PDerived",
    "::Test::Preserved"
};

}

bool
Test::PDerived::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__PDerived_ids, __Test__PDerived_ids + 4, _s);
}

::std::vector< ::std::string>
Test::PDerived::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__PDerived_ids[0], &__Test__PDerived_ids[4]);
}

const ::std::string&
Test::PDerived::ice_id(const ::Ice::Current&) const
{
    return __Test__PDerived_ids[2];
}

const ::std::string&
Test::PDerived::ice_staticId()
{
    return __Test__PDerived_ids[2];
}

void
Test::PDerived::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    ::Test::Preserved::__gcReachable(_c);
    if(pb)
    {
        ::Test::upCast(pb.get())->__addObject(_c);
    }
}

void
Test::PDerived::__gcClear()
{
    ::Test::Preserved::__gcClear();
    if(pb)
    {
        if(::Test::upCast(pb.get())->__usesGC())
        {
            ::Test::upCast(pb.get())->__decRefUnsafe();
            pb.__clearHandleUnsafe();
        }
        else
        {
            pb = 0;
        }
    }
}

void
Test::PDerived::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(pb);
    __os->endWriteSlice();
    ::Test::Preserved::__writeImpl(__os);
}

void
Test::PDerived::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(pb);
    __is->endReadSlice();
    ::Test::Preserved::__readImpl(__is);
}

namespace
{

class __F__Test__PDerived : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::PDerived::ice_staticId());
        return new ::Test::PDerived;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__PDerived_Ptr = new __F__Test__PDerived;

class __F__Test__PDerived__Init
{
public:

    __F__Test__PDerived__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::PDerived::ice_staticId(), __F__Test__PDerived_Ptr);
    }

    ~__F__Test__PDerived__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::PDerived::ice_staticId());
    }
};

const __F__Test__PDerived__Init __F__Test__PDerived__i;

}

const ::Ice::ObjectFactoryPtr&
Test::PDerived::ice_factory()
{
    return __F__Test__PDerived_Ptr;
}

void 
Test::__patch(PDerivedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::PDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::PDerived::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::PNode* p) { return p; }
::Ice::ObjectPtr
Test::PNode::ice_clone() const
{
    ::Ice::Object* __p = new PNode(*this);
    return __p;
}

namespace
{
const ::std::string __Test__PNode_ids[2] =
{
    "::Ice::Object",
    "::Test::PNode"
};

}

bool
Test::PNode::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__PNode_ids, __Test__PNode_ids + 2, _s);
}

::std::vector< ::std::string>
Test::PNode::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__PNode_ids[0], &__Test__PNode_ids[2]);
}

const ::std::string&
Test::PNode::ice_id(const ::Ice::Current&) const
{
    return __Test__PNode_ids[1];
}

const ::std::string&
Test::PNode::ice_staticId()
{
    return __Test__PNode_ids[1];
}

void
Test::PNode::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::PNode::__usesGC()
{
    return true;
}

void
Test::PNode::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(__slicedData)
    {
        __slicedData->__addObject(_c);
    }
    if(next)
    {
        ::Test::upCast(next.get())->__addObject(_c);
    }
}

void
Test::PNode::__gcClear()
{
    if(__slicedData)
    {
        __slicedData->__decRefUnsafe();
        __slicedData.__clearHandleUnsafe();
    }
    if(next)
    {
        if(::Test::upCast(next.get())->__usesGC())
        {
            ::Test::upCast(next.get())->__decRefUnsafe();
            next.__clearHandleUnsafe();
        }
        else
        {
            next = 0;
        }
    }
}

void
Test::PNode::__write(::IceInternal::BasicStream* __os) const
{
    __os->startWriteObject(__slicedData);
    __writeImpl(__os);
    __os->endWriteObject();
}

void
Test::PNode::__read(::IceInternal::BasicStream* __is)
{
    __is->startReadObject();
    __readImpl(__is);
    __slicedData = __is->endReadObject(true);
}

void
Test::PNode::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(next);
    __os->endWriteSlice();
}

void
Test::PNode::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(next);
    __is->endReadSlice();
}

namespace
{

class __F__Test__PNode : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::PNode::ice_staticId());
        return new ::Test::PNode;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__PNode_Ptr = new __F__Test__PNode;

class __F__Test__PNode__Init
{
public:

    __F__Test__PNode__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::PNode::ice_staticId(), __F__Test__PNode_Ptr);
    }

    ~__F__Test__PNode__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::PNode::ice_staticId());
    }
};

const __F__Test__PNode__Init __F__Test__PNode__i;

}

const ::Ice::ObjectFactoryPtr&
Test::PNode::ice_factory()
{
    return __F__Test__PNode_Ptr;
}

void 
Test::__patch(PNodePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::PNodePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::PNode::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::TestIntf* p) { return p; }

namespace
{
const ::std::string __Test__TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__TestIntf_ids, __Test__TestIntf_ids + 2, _s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__TestIntf_ids[0], &__Test__TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return __Test__TestIntf_ids[1];
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    return __Test__TestIntf_ids[1];
}

::Ice::DispatchStatus
Test::TestIntf::___SBaseAsObject(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_SBaseAsObjectPtr __cb = new IceAsync::Test::AMD_TestIntf_SBaseAsObject(__inS);
    try
    {
        SBaseAsObject_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___SBaseAsSBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_SBaseAsSBasePtr __cb = new IceAsync::Test::AMD_TestIntf_SBaseAsSBase(__inS);
    try
    {
        SBaseAsSBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___SBSKnownDerivedAsSBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_SBSKnownDerivedAsSBasePtr __cb = new IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBase(__inS);
    try
    {
        SBSKnownDerivedAsSBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr __cb = new IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived(__inS);
    try
    {
        SBSKnownDerivedAsSBSKnownDerived_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___SBSUnknownDerivedAsSBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBasePtr __cb = new IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase(__inS);
    try
    {
        SBSUnknownDerivedAsSBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr __cb = new IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact(__inS);
    try
    {
        SBSUnknownDerivedAsSBaseCompact_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___SUnknownAsObject(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_SUnknownAsObjectPtr __cb = new IceAsync::Test::AMD_TestIntf_SUnknownAsObject(__inS);
    try
    {
        SUnknownAsObject_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___checkSUnknown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::ObjectPtr o;
    __is->read(o);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_checkSUnknownPtr __cb = new IceAsync::Test::AMD_TestIntf_checkSUnknown(__inS);
    try
    {
        checkSUnknown_async(__cb, o, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___oneElementCycle(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_oneElementCyclePtr __cb = new IceAsync::Test::AMD_TestIntf_oneElementCycle(__inS);
    try
    {
        oneElementCycle_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___twoElementCycle(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_twoElementCyclePtr __cb = new IceAsync::Test::AMD_TestIntf_twoElementCycle(__inS);
    try
    {
        twoElementCycle_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___D1AsB(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_D1AsBPtr __cb = new IceAsync::Test::AMD_TestIntf_D1AsB(__inS);
    try
    {
        D1AsB_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___D1AsD1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_D1AsD1Ptr __cb = new IceAsync::Test::AMD_TestIntf_D1AsD1(__inS);
    try
    {
        D1AsD1_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___D2AsB(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_D2AsBPtr __cb = new IceAsync::Test::AMD_TestIntf_D2AsB(__inS);
    try
    {
        D2AsB_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___paramTest1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_paramTest1Ptr __cb = new IceAsync::Test::AMD_TestIntf_paramTest1(__inS);
    try
    {
        paramTest1_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___paramTest2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_paramTest2Ptr __cb = new IceAsync::Test::AMD_TestIntf_paramTest2(__inS);
    try
    {
        paramTest2_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___paramTest3(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_paramTest3Ptr __cb = new IceAsync::Test::AMD_TestIntf_paramTest3(__inS);
    try
    {
        paramTest3_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___paramTest4(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_paramTest4Ptr __cb = new IceAsync::Test::AMD_TestIntf_paramTest4(__inS);
    try
    {
        paramTest4_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___returnTest1(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_returnTest1Ptr __cb = new IceAsync::Test::AMD_TestIntf_returnTest1(__inS);
    try
    {
        returnTest1_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___returnTest2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_returnTest2Ptr __cb = new IceAsync::Test::AMD_TestIntf_returnTest2(__inS);
    try
    {
        returnTest2_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___returnTest3(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::BPtr p1;
    ::Test::BPtr p2;
    __is->read(p1);
    __is->read(p2);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_returnTest3Ptr __cb = new IceAsync::Test::AMD_TestIntf_returnTest3(__inS);
    try
    {
        returnTest3_async(__cb, p1, p2, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___sequenceTest(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::SS1Ptr p1;
    ::Test::SS2Ptr p2;
    __is->read(p1);
    __is->read(p2);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_sequenceTestPtr __cb = new IceAsync::Test::AMD_TestIntf_sequenceTest(__inS);
    try
    {
        sequenceTest_async(__cb, p1, p2, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___dictionaryTest(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::BDict bin;
    __is->read(bin);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_dictionaryTestPtr __cb = new IceAsync::Test::AMD_TestIntf_dictionaryTest(__inS);
    try
    {
        dictionaryTest_async(__cb, bin, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___exchangePBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::PBasePtr pb;
    __is->read(pb);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_exchangePBasePtr __cb = new IceAsync::Test::AMD_TestIntf_exchangePBase(__inS);
    try
    {
        exchangePBase_async(__cb, pb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___PBSUnknownAsPreserved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_PBSUnknownAsPreservedPtr __cb = new IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreserved(__inS);
    try
    {
        PBSUnknownAsPreserved_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___checkPBSUnknown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::PreservedPtr p;
    __is->read(p);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_checkPBSUnknownPtr __cb = new IceAsync::Test::AMD_TestIntf_checkPBSUnknown(__inS);
    try
    {
        checkPBSUnknown_async(__cb, p, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraphPtr __cb = new IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph(__inS);
    try
    {
        PBSUnknownAsPreservedWithGraph_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___checkPBSUnknownWithGraph(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::PreservedPtr p;
    __is->read(p);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_checkPBSUnknownWithGraphPtr __cb = new IceAsync::Test::AMD_TestIntf_checkPBSUnknownWithGraph(__inS);
    try
    {
        checkPBSUnknownWithGraph_async(__cb, p, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraphPtr __cb = new IceAsync::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph(__inS);
    try
    {
        PBSUnknown2AsPreservedWithGraph_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___checkPBSUnknown2WithGraph(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::PreservedPtr p;
    __is->read(p);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_checkPBSUnknown2WithGraphPtr __cb = new IceAsync::Test::AMD_TestIntf_checkPBSUnknown2WithGraph(__inS);
    try
    {
        checkPBSUnknown2WithGraph_async(__cb, p, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___exchangePNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::PNodePtr pn;
    __is->read(pn);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::Test::AMD_TestIntf_exchangePNodePtr __cb = new IceAsync::Test::AMD_TestIntf_exchangePNode(__inS);
    try
    {
        exchangePNode_async(__cb, pn, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___throwBaseAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_throwBaseAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_throwBaseAsBase(__inS);
    try
    {
        throwBaseAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___throwDerivedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_throwDerivedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_throwDerivedAsBase(__inS);
    try
    {
        throwDerivedAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___throwDerivedAsDerived(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_throwDerivedAsDerivedPtr __cb = new IceAsync::Test::AMD_TestIntf_throwDerivedAsDerived(__inS);
    try
    {
        throwDerivedAsDerived_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___throwUnknownDerivedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_throwUnknownDerivedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_throwUnknownDerivedAsBase(__inS);
    try
    {
        throwUnknownDerivedAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___throwPreservedException(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_throwPreservedExceptionPtr __cb = new IceAsync::Test::AMD_TestIntf_throwPreservedException(__inS);
    try
    {
        throwPreservedException_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___useForward(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_useForwardPtr __cb = new IceAsync::Test::AMD_TestIntf_useForward(__inS);
    try
    {
        useForward_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_shutdownPtr __cb = new IceAsync::Test::AMD_TestIntf_shutdown(__inS);
    try
    {
        shutdown_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __Test__TestIntf_all[] =
{
    "D1AsB",
    "D1AsD1",
    "D2AsB",
    "PBSUnknown2AsPreservedWithGraph",
    "PBSUnknownAsPreserved",
    "PBSUnknownAsPreservedWithGraph",
    "SBSKnownDerivedAsSBSKnownDerived",
    "SBSKnownDerivedAsSBase",
    "SBSUnknownDerivedAsSBase",
    "SBSUnknownDerivedAsSBaseCompact",
    "SBaseAsObject",
    "SBaseAsSBase",
    "SUnknownAsObject",
    "checkPBSUnknown",
    "checkPBSUnknown2WithGraph",
    "checkPBSUnknownWithGraph",
    "checkSUnknown",
    "dictionaryTest",
    "exchangePBase",
    "exchangePNode",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "oneElementCycle",
    "paramTest1",
    "paramTest2",
    "paramTest3",
    "paramTest4",
    "returnTest1",
    "returnTest2",
    "returnTest3",
    "sequenceTest",
    "shutdown",
    "throwBaseAsBase",
    "throwDerivedAsBase",
    "throwDerivedAsDerived",
    "throwPreservedException",
    "throwUnknownDerivedAsBase",
    "twoElementCycle",
    "useForward"
};

}

::Ice::DispatchStatus
Test::TestIntf::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__TestIntf_all, __Test__TestIntf_all + 41, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__TestIntf_all)
    {
        case 0:
        {
            return ___D1AsB(in, current);
        }
        case 1:
        {
            return ___D1AsD1(in, current);
        }
        case 2:
        {
            return ___D2AsB(in, current);
        }
        case 3:
        {
            return ___PBSUnknown2AsPreservedWithGraph(in, current);
        }
        case 4:
        {
            return ___PBSUnknownAsPreserved(in, current);
        }
        case 5:
        {
            return ___PBSUnknownAsPreservedWithGraph(in, current);
        }
        case 6:
        {
            return ___SBSKnownDerivedAsSBSKnownDerived(in, current);
        }
        case 7:
        {
            return ___SBSKnownDerivedAsSBase(in, current);
        }
        case 8:
        {
            return ___SBSUnknownDerivedAsSBase(in, current);
        }
        case 9:
        {
            return ___SBSUnknownDerivedAsSBaseCompact(in, current);
        }
        case 10:
        {
            return ___SBaseAsObject(in, current);
        }
        case 11:
        {
            return ___SBaseAsSBase(in, current);
        }
        case 12:
        {
            return ___SUnknownAsObject(in, current);
        }
        case 13:
        {
            return ___checkPBSUnknown(in, current);
        }
        case 14:
        {
            return ___checkPBSUnknown2WithGraph(in, current);
        }
        case 15:
        {
            return ___checkPBSUnknownWithGraph(in, current);
        }
        case 16:
        {
            return ___checkSUnknown(in, current);
        }
        case 17:
        {
            return ___dictionaryTest(in, current);
        }
        case 18:
        {
            return ___exchangePBase(in, current);
        }
        case 19:
        {
            return ___exchangePNode(in, current);
        }
        case 20:
        {
            return ___ice_id(in, current);
        }
        case 21:
        {
            return ___ice_ids(in, current);
        }
        case 22:
        {
            return ___ice_isA(in, current);
        }
        case 23:
        {
            return ___ice_ping(in, current);
        }
        case 24:
        {
            return ___oneElementCycle(in, current);
        }
        case 25:
        {
            return ___paramTest1(in, current);
        }
        case 26:
        {
            return ___paramTest2(in, current);
        }
        case 27:
        {
            return ___paramTest3(in, current);
        }
        case 28:
        {
            return ___paramTest4(in, current);
        }
        case 29:
        {
            return ___returnTest1(in, current);
        }
        case 30:
        {
            return ___returnTest2(in, current);
        }
        case 31:
        {
            return ___returnTest3(in, current);
        }
        case 32:
        {
            return ___sequenceTest(in, current);
        }
        case 33:
        {
            return ___shutdown(in, current);
        }
        case 34:
        {
            return ___throwBaseAsBase(in, current);
        }
        case 35:
        {
            return ___throwDerivedAsBase(in, current);
        }
        case 36:
        {
            return ___throwDerivedAsDerived(in, current);
        }
        case 37:
        {
            return ___throwPreservedException(in, current);
        }
        case 38:
        {
            return ___throwUnknownDerivedAsBase(in, current);
        }
        case 39:
        {
            return ___twoElementCycle(in, current);
        }
        case 40:
        {
            return ___useForward(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::TestIntf::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::TestIntf::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(TestIntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::TestIntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::TestIntf::ice_staticId(), v);
    }
}
