// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TestAMD_h__
#define __TestAMD_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class SBase;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SBase>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SBase*);

class SBSKnownDerived;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SBSKnownDerived>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SBSKnownDerived*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::B*);

class D1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::D1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::D1*);

class SS1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SS1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SS1*);

class SS2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::SS2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::SS2*);

class Forward;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Forward>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Forward*);

class PBase;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::PBase>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::PBase*);

class Preserved;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Preserved>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Preserved*);

class PDerived;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::PDerived>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::PDerived*);

class PNode;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::PNode>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::PNode*);

class TestIntf;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::TestIntf*);

}

}

namespace Test
{

class SBase;
bool operator==(const SBase&, const SBase&);
bool operator<(const SBase&, const SBase&);
::Ice::Object* upCast(::Test::SBase*);
typedef ::IceInternal::Handle< ::Test::SBase> SBasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SBase> SBasePrx;
void __patch(SBasePtr&, const ::Ice::ObjectPtr&);

class SBSKnownDerived;
bool operator==(const SBSKnownDerived&, const SBSKnownDerived&);
bool operator<(const SBSKnownDerived&, const SBSKnownDerived&);
::Ice::Object* upCast(::Test::SBSKnownDerived*);
typedef ::IceInternal::Handle< ::Test::SBSKnownDerived> SBSKnownDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SBSKnownDerived> SBSKnownDerivedPrx;
void __patch(SBSKnownDerivedPtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::B*);
typedef ::IceInternal::Handle< ::Test::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class D1;
bool operator==(const D1&, const D1&);
bool operator<(const D1&, const D1&);
::Ice::Object* upCast(::Test::D1*);
typedef ::IceInternal::Handle< ::Test::D1> D1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D1> D1Prx;
void __patch(D1Ptr&, const ::Ice::ObjectPtr&);

class SS1;
bool operator==(const SS1&, const SS1&);
bool operator<(const SS1&, const SS1&);
::Ice::Object* upCast(::Test::SS1*);
typedef ::IceInternal::Handle< ::Test::SS1> SS1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SS1> SS1Prx;
void __patch(SS1Ptr&, const ::Ice::ObjectPtr&);

class SS2;
bool operator==(const SS2&, const SS2&);
bool operator<(const SS2&, const SS2&);
::Ice::Object* upCast(::Test::SS2*);
typedef ::IceInternal::Handle< ::Test::SS2> SS2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SS2> SS2Prx;
void __patch(SS2Ptr&, const ::Ice::ObjectPtr&);

class Forward;
bool operator==(const Forward&, const Forward&);
bool operator<(const Forward&, const Forward&);
::Ice::Object* upCast(::Test::Forward*);
typedef ::IceInternal::Handle< ::Test::Forward> ForwardPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Forward> ForwardPrx;
void __patch(ForwardPtr&, const ::Ice::ObjectPtr&);

class PBase;
bool operator==(const PBase&, const PBase&);
bool operator<(const PBase&, const PBase&);
::Ice::Object* upCast(::Test::PBase*);
typedef ::IceInternal::Handle< ::Test::PBase> PBasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PBase> PBasePrx;
void __patch(PBasePtr&, const ::Ice::ObjectPtr&);

class Preserved;
bool operator==(const Preserved&, const Preserved&);
bool operator<(const Preserved&, const Preserved&);
::Ice::Object* upCast(::Test::Preserved*);
typedef ::IceInternal::Handle< ::Test::Preserved> PreservedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Preserved> PreservedPrx;
void __patch(PreservedPtr&, const ::Ice::ObjectPtr&);

class PDerived;
bool operator==(const PDerived&, const PDerived&);
bool operator<(const PDerived&, const PDerived&);
::Ice::Object* upCast(::Test::PDerived*);
typedef ::IceInternal::Handle< ::Test::PDerived> PDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PDerived> PDerivedPrx;
void __patch(PDerivedPtr&, const ::Ice::ObjectPtr&);

class PNode;
bool operator==(const PNode&, const PNode&);
bool operator<(const PNode&, const PNode&);
::Ice::Object* upCast(::Test::PNode*);
typedef ::IceInternal::Handle< ::Test::PNode> PNodePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PNode> PNodePrx;
void __patch(PNodePtr&, const ::Ice::ObjectPtr&);

class TestIntf;
bool operator==(const TestIntf&, const TestIntf&);
bool operator<(const TestIntf&, const TestIntf&);
::Ice::Object* upCast(::Test::TestIntf*);
typedef ::IceInternal::Handle< ::Test::TestIntf> TestIntfPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
void __patch(TestIntfPtr&, const ::Ice::ObjectPtr&);

}

namespace Test
{

typedef ::std::vector< ::Test::BPtr> BSeq;

struct SS3
{
    ::Test::SS1Ptr c1;
    ::Test::SS2Ptr c2;
};

typedef ::std::map< ::Ice::Int, ::Test::BPtr> BDict;

class BaseException : public ::Ice::UserException
{
public:

    BaseException() {}
    BaseException(const ::std::string&, const ::Test::BPtr&);
    virtual ~BaseException() throw();

    virtual ::std::string ice_name() const;
    virtual BaseException* ice_clone() const;
    virtual void ice_throw() const;

    virtual bool __usesClasses() const;

    ::std::string sbe;
    ::Test::BPtr pb;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

static BaseException __BaseException_init;

class DerivedException : public ::Test::BaseException
{
public:

    DerivedException() {}
    DerivedException(const ::std::string&, const ::Test::BPtr&, const ::std::string&, const ::Test::D1Ptr&);
    virtual ~DerivedException() throw();

    virtual ::std::string ice_name() const;
    virtual DerivedException* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string sde;
    ::Test::D1Ptr pd1;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::BaseException::__writeImpl;
    using ::Test::BaseException::__readImpl;
    #endif
};

typedef ::std::vector< ::Test::PBasePtr> PBaseSeq;

class PreservedException : public ::Ice::UserException
{
public:

    PreservedException() {}
    virtual ~PreservedException() throw();

    virtual ::std::string ice_name() const;
    virtual PreservedException* ice_clone() const;
    virtual void ice_throw() const;

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__write;
    using ::Ice::UserException::__read;
    #endif

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif

    ::Ice::SlicedDataPtr __slicedData;
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::SS3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::SS3, S>
{
    static void write(S* __os, const ::Test::SS3& v)
    {
        __os->write(v.c1);
        __os->write(v.c2);
    }
};

template<class S>
struct StreamReader< ::Test::SS3, S>
{
    static void read(S* __is, ::Test::SS3& v)
    {
        __is->read(v.c1);
        __is->read(v.c2);
    }
};

template<>
struct StreamableTraits< ::Test::BaseException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::DerivedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::PreservedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Test
{

class AMD_TestIntf_SBaseAsObject : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ObjectPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_SBaseAsObject> AMD_TestIntf_SBaseAsObjectPtr;

class AMD_TestIntf_SBaseAsSBase : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::SBasePtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_SBaseAsSBase> AMD_TestIntf_SBaseAsSBasePtr;

class AMD_TestIntf_SBSKnownDerivedAsSBase : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::SBasePtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_SBSKnownDerivedAsSBase> AMD_TestIntf_SBSKnownDerivedAsSBasePtr;

class AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::SBSKnownDerivedPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived> AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr;

class AMD_TestIntf_SBSUnknownDerivedAsSBase : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::SBasePtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase> AMD_TestIntf_SBSUnknownDerivedAsSBasePtr;

class AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::SBasePtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact> AMD_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr;

class AMD_TestIntf_SUnknownAsObject : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ObjectPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_SUnknownAsObject> AMD_TestIntf_SUnknownAsObjectPtr;

class AMD_TestIntf_checkSUnknown : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_checkSUnknown> AMD_TestIntf_checkSUnknownPtr;

class AMD_TestIntf_oneElementCycle : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_oneElementCycle> AMD_TestIntf_oneElementCyclePtr;

class AMD_TestIntf_twoElementCycle : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_twoElementCycle> AMD_TestIntf_twoElementCyclePtr;

class AMD_TestIntf_D1AsB : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_D1AsB> AMD_TestIntf_D1AsBPtr;

class AMD_TestIntf_D1AsD1 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::D1Ptr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_D1AsD1> AMD_TestIntf_D1AsD1Ptr;

class AMD_TestIntf_D2AsB : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_D2AsB> AMD_TestIntf_D2AsBPtr;

class AMD_TestIntf_paramTest1 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_paramTest1> AMD_TestIntf_paramTest1Ptr;

class AMD_TestIntf_paramTest2 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_paramTest2> AMD_TestIntf_paramTest2Ptr;

class AMD_TestIntf_paramTest3 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_paramTest3> AMD_TestIntf_paramTest3Ptr;

class AMD_TestIntf_paramTest4 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_paramTest4> AMD_TestIntf_paramTest4Ptr;

class AMD_TestIntf_returnTest1 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_returnTest1> AMD_TestIntf_returnTest1Ptr;

class AMD_TestIntf_returnTest2 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_returnTest2> AMD_TestIntf_returnTest2Ptr;

class AMD_TestIntf_returnTest3 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_returnTest3> AMD_TestIntf_returnTest3Ptr;

class AMD_TestIntf_sequenceTest : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::SS3&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_sequenceTest> AMD_TestIntf_sequenceTestPtr;

class AMD_TestIntf_dictionaryTest : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::BDict&, const ::Test::BDict&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_dictionaryTest> AMD_TestIntf_dictionaryTestPtr;

class AMD_TestIntf_exchangePBase : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::PBasePtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_exchangePBase> AMD_TestIntf_exchangePBasePtr;

class AMD_TestIntf_PBSUnknownAsPreserved : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::PreservedPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_PBSUnknownAsPreserved> AMD_TestIntf_PBSUnknownAsPreservedPtr;

class AMD_TestIntf_checkPBSUnknown : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_checkPBSUnknown> AMD_TestIntf_checkPBSUnknownPtr;

class AMD_TestIntf_PBSUnknownAsPreservedWithGraph : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::PreservedPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph> AMD_TestIntf_PBSUnknownAsPreservedWithGraphPtr;

class AMD_TestIntf_checkPBSUnknownWithGraph : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_checkPBSUnknownWithGraph> AMD_TestIntf_checkPBSUnknownWithGraphPtr;

class AMD_TestIntf_PBSUnknown2AsPreservedWithGraph : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::PreservedPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph> AMD_TestIntf_PBSUnknown2AsPreservedWithGraphPtr;

class AMD_TestIntf_checkPBSUnknown2WithGraph : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_checkPBSUnknown2WithGraph> AMD_TestIntf_checkPBSUnknown2WithGraphPtr;

class AMD_TestIntf_exchangePNode : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::PNodePtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_exchangePNode> AMD_TestIntf_exchangePNodePtr;

class AMD_TestIntf_throwBaseAsBase : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_throwBaseAsBase> AMD_TestIntf_throwBaseAsBasePtr;

class AMD_TestIntf_throwDerivedAsBase : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_throwDerivedAsBase> AMD_TestIntf_throwDerivedAsBasePtr;

class AMD_TestIntf_throwDerivedAsDerived : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_throwDerivedAsDerived> AMD_TestIntf_throwDerivedAsDerivedPtr;

class AMD_TestIntf_throwUnknownDerivedAsBase : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_throwUnknownDerivedAsBase> AMD_TestIntf_throwUnknownDerivedAsBasePtr;

class AMD_TestIntf_throwPreservedException : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_throwPreservedException> AMD_TestIntf_throwPreservedExceptionPtr;

class AMD_TestIntf_useForward : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Test::ForwardPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_useForward> AMD_TestIntf_useForwardPtr;

class AMD_TestIntf_shutdown : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_shutdown> AMD_TestIntf_shutdownPtr;

}

namespace IceAsync
{

namespace Test
{

class AMD_TestIntf_SBaseAsObject : public ::Test::AMD_TestIntf_SBaseAsObject, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_SBaseAsObject(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ObjectPtr&);
};

class AMD_TestIntf_SBaseAsSBase : public ::Test::AMD_TestIntf_SBaseAsSBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_SBaseAsSBase(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SBasePtr&);
};

class AMD_TestIntf_SBSKnownDerivedAsSBase : public ::Test::AMD_TestIntf_SBSKnownDerivedAsSBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_SBSKnownDerivedAsSBase(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SBasePtr&);
};

class AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived : public ::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SBSKnownDerivedPtr&);
};

class AMD_TestIntf_SBSUnknownDerivedAsSBase : public ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_SBSUnknownDerivedAsSBase(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SBasePtr&);
};

class AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact : public ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SBasePtr&);
};

class AMD_TestIntf_SUnknownAsObject : public ::Test::AMD_TestIntf_SUnknownAsObject, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_SUnknownAsObject(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ObjectPtr&);
};

class AMD_TestIntf_checkSUnknown : public ::Test::AMD_TestIntf_checkSUnknown, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_checkSUnknown(::IceInternal::Incoming&);

    virtual void ice_response();
};

class AMD_TestIntf_oneElementCycle : public ::Test::AMD_TestIntf_oneElementCycle, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_oneElementCycle(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&);
};

class AMD_TestIntf_twoElementCycle : public ::Test::AMD_TestIntf_twoElementCycle, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_twoElementCycle(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&);
};

class AMD_TestIntf_D1AsB : public ::Test::AMD_TestIntf_D1AsB, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_D1AsB(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&);
};

class AMD_TestIntf_D1AsD1 : public ::Test::AMD_TestIntf_D1AsD1, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_D1AsD1(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::D1Ptr&);
};

class AMD_TestIntf_D2AsB : public ::Test::AMD_TestIntf_D2AsB, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_D2AsB(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&);
};

class AMD_TestIntf_paramTest1 : public ::Test::AMD_TestIntf_paramTest1, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_paramTest1(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&);
};

class AMD_TestIntf_paramTest2 : public ::Test::AMD_TestIntf_paramTest2, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_paramTest2(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&);
};

class AMD_TestIntf_paramTest3 : public ::Test::AMD_TestIntf_paramTest3, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_paramTest3(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&);
};

class AMD_TestIntf_paramTest4 : public ::Test::AMD_TestIntf_paramTest4, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_paramTest4(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&);
};

class AMD_TestIntf_returnTest1 : public ::Test::AMD_TestIntf_returnTest1, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_returnTest1(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&);
};

class AMD_TestIntf_returnTest2 : public ::Test::AMD_TestIntf_returnTest2, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_returnTest2(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&);
};

class AMD_TestIntf_returnTest3 : public ::Test::AMD_TestIntf_returnTest3, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_returnTest3(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&);
};

class AMD_TestIntf_sequenceTest : public ::Test::AMD_TestIntf_sequenceTest, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_sequenceTest(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SS3&);
};

class AMD_TestIntf_dictionaryTest : public ::Test::AMD_TestIntf_dictionaryTest, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_dictionaryTest(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BDict&, const ::Test::BDict&);
};

class AMD_TestIntf_exchangePBase : public ::Test::AMD_TestIntf_exchangePBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_exchangePBase(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::PBasePtr&);
};

class AMD_TestIntf_PBSUnknownAsPreserved : public ::Test::AMD_TestIntf_PBSUnknownAsPreserved, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_PBSUnknownAsPreserved(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::PreservedPtr&);
};

class AMD_TestIntf_checkPBSUnknown : public ::Test::AMD_TestIntf_checkPBSUnknown, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_checkPBSUnknown(::IceInternal::Incoming&);

    virtual void ice_response();
};

class AMD_TestIntf_PBSUnknownAsPreservedWithGraph : public ::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::PreservedPtr&);
};

class AMD_TestIntf_checkPBSUnknownWithGraph : public ::Test::AMD_TestIntf_checkPBSUnknownWithGraph, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_checkPBSUnknownWithGraph(::IceInternal::Incoming&);

    virtual void ice_response();
};

class AMD_TestIntf_PBSUnknown2AsPreservedWithGraph : public ::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::PreservedPtr&);
};

class AMD_TestIntf_checkPBSUnknown2WithGraph : public ::Test::AMD_TestIntf_checkPBSUnknown2WithGraph, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_checkPBSUnknown2WithGraph(::IceInternal::Incoming&);

    virtual void ice_response();
};

class AMD_TestIntf_exchangePNode : public ::Test::AMD_TestIntf_exchangePNode, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_exchangePNode(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::PNodePtr&);
};

class AMD_TestIntf_throwBaseAsBase : public ::Test::AMD_TestIntf_throwBaseAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_throwBaseAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TestIntf_throwDerivedAsBase : public ::Test::AMD_TestIntf_throwDerivedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_throwDerivedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TestIntf_throwDerivedAsDerived : public ::Test::AMD_TestIntf_throwDerivedAsDerived, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_throwDerivedAsDerived(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TestIntf_throwUnknownDerivedAsBase : public ::Test::AMD_TestIntf_throwUnknownDerivedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_throwUnknownDerivedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TestIntf_throwPreservedException : public ::Test::AMD_TestIntf_throwPreservedException, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_throwPreservedException(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TestIntf_useForward : public ::Test::AMD_TestIntf_useForward, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_useForward(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ForwardPtr&);
};

class AMD_TestIntf_shutdown : public ::Test::AMD_TestIntf_shutdown, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_shutdown(::IceInternal::Incoming&);

    virtual void ice_response();
};

}

}

namespace Test
{

class Callback_TestIntf_SBaseAsObject_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBaseAsObject_Base> Callback_TestIntf_SBaseAsObjectPtr;

class Callback_TestIntf_SBaseAsSBase_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBaseAsSBase_Base> Callback_TestIntf_SBaseAsSBasePtr;

class Callback_TestIntf_SBSKnownDerivedAsSBase_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSKnownDerivedAsSBase_Base> Callback_TestIntf_SBSKnownDerivedAsSBasePtr;

class Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr;

class Callback_TestIntf_SBSUnknownDerivedAsSBase_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSUnknownDerivedAsSBase_Base> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr;

class Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr;

class Callback_TestIntf_SUnknownAsObject_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SUnknownAsObject_Base> Callback_TestIntf_SUnknownAsObjectPtr;

class Callback_TestIntf_checkSUnknown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkSUnknown_Base> Callback_TestIntf_checkSUnknownPtr;

class Callback_TestIntf_oneElementCycle_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_oneElementCycle_Base> Callback_TestIntf_oneElementCyclePtr;

class Callback_TestIntf_twoElementCycle_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_twoElementCycle_Base> Callback_TestIntf_twoElementCyclePtr;

class Callback_TestIntf_D1AsB_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_D1AsB_Base> Callback_TestIntf_D1AsBPtr;

class Callback_TestIntf_D1AsD1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_D1AsD1_Base> Callback_TestIntf_D1AsD1Ptr;

class Callback_TestIntf_D2AsB_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_D2AsB_Base> Callback_TestIntf_D2AsBPtr;

class Callback_TestIntf_paramTest1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest1_Base> Callback_TestIntf_paramTest1Ptr;

class Callback_TestIntf_paramTest2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest2_Base> Callback_TestIntf_paramTest2Ptr;

class Callback_TestIntf_paramTest3_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest3_Base> Callback_TestIntf_paramTest3Ptr;

class Callback_TestIntf_paramTest4_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest4_Base> Callback_TestIntf_paramTest4Ptr;

class Callback_TestIntf_returnTest1_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_returnTest1_Base> Callback_TestIntf_returnTest1Ptr;

class Callback_TestIntf_returnTest2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_returnTest2_Base> Callback_TestIntf_returnTest2Ptr;

class Callback_TestIntf_returnTest3_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_returnTest3_Base> Callback_TestIntf_returnTest3Ptr;

class Callback_TestIntf_sequenceTest_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_sequenceTest_Base> Callback_TestIntf_sequenceTestPtr;

class Callback_TestIntf_dictionaryTest_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_dictionaryTest_Base> Callback_TestIntf_dictionaryTestPtr;

class Callback_TestIntf_exchangePBase_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_exchangePBase_Base> Callback_TestIntf_exchangePBasePtr;

class Callback_TestIntf_PBSUnknownAsPreserved_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_PBSUnknownAsPreserved_Base> Callback_TestIntf_PBSUnknownAsPreservedPtr;

class Callback_TestIntf_checkPBSUnknown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkPBSUnknown_Base> Callback_TestIntf_checkPBSUnknownPtr;

class Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr;

class Callback_TestIntf_checkPBSUnknownWithGraph_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkPBSUnknownWithGraph_Base> Callback_TestIntf_checkPBSUnknownWithGraphPtr;

class Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr;

class Callback_TestIntf_checkPBSUnknown2WithGraph_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkPBSUnknown2WithGraph_Base> Callback_TestIntf_checkPBSUnknown2WithGraphPtr;

class Callback_TestIntf_exchangePNode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_exchangePNode_Base> Callback_TestIntf_exchangePNodePtr;

class Callback_TestIntf_throwBaseAsBase_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwBaseAsBase_Base> Callback_TestIntf_throwBaseAsBasePtr;

class Callback_TestIntf_throwDerivedAsBase_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwDerivedAsBase_Base> Callback_TestIntf_throwDerivedAsBasePtr;

class Callback_TestIntf_throwDerivedAsDerived_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwDerivedAsDerived_Base> Callback_TestIntf_throwDerivedAsDerivedPtr;

class Callback_TestIntf_throwUnknownDerivedAsBase_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwUnknownDerivedAsBase_Base> Callback_TestIntf_throwUnknownDerivedAsBasePtr;

class Callback_TestIntf_throwPreservedException_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwPreservedException_Base> Callback_TestIntf_throwPreservedExceptionPtr;

class Callback_TestIntf_useForward_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_useForward_Base> Callback_TestIntf_useForwardPtr;

class Callback_TestIntf_shutdown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class SBase : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SBase> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_secure(bool __secure) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_twoway() const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_oneway() const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_batchOneway() const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_datagram() const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_batchDatagram() const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_compress(bool __compress) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SBase> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SBase*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SBSKnownDerived : virtual public ::IceProxy::Test::SBase
{
public:
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_secure(bool __secure) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_twoway() const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_oneway() const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_batchOneway() const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_datagram() const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_batchDatagram() const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_compress(bool __compress) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SBSKnownDerived> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SBSKnownDerived*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D1 : virtual public ::IceProxy::Test::B
{
public:
    
    ::IceInternal::ProxyHandle<D1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_secure(bool __secure) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_twoway() const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_oneway() const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_batchOneway() const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_datagram() const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_batchDatagram() const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_compress(bool __compress) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SS1 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SS1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_secure(bool __secure) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_twoway() const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_oneway() const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_batchOneway() const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_datagram() const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_batchDatagram() const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_compress(bool __compress) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SS1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SS1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class SS2 : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<SS2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_secure(bool __secure) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_twoway() const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_oneway() const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_batchOneway() const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_datagram() const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_batchDatagram() const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_compress(bool __compress) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<SS2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<SS2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PBase : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<PBase> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_secure(bool __secure) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_twoway() const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_oneway() const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_batchOneway() const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_datagram() const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_batchDatagram() const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_compress(bool __compress) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_timeout(int __timeout) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PBase> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<PBase*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Preserved : virtual public ::IceProxy::Test::PBase
{
public:
    
    ::IceInternal::ProxyHandle<Preserved> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_secure(bool __secure) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_twoway() const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_oneway() const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_batchOneway() const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_datagram() const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_batchDatagram() const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_compress(bool __compress) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Preserved> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Preserved*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PDerived : virtual public ::IceProxy::Test::Preserved
{
public:
    
    ::IceInternal::ProxyHandle<PDerived> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_secure(bool __secure) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_twoway() const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_oneway() const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_batchOneway() const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_datagram() const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_batchDatagram() const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_compress(bool __compress) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_timeout(int __timeout) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PDerived> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<PDerived*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PNode : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<PNode> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_secure(bool __secure) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_twoway() const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_oneway() const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_batchOneway() const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_datagram() const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_batchDatagram() const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_compress(bool __compress) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_timeout(int __timeout) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PNode> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<PNode*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class TestIntf : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::ObjectPtr SBaseAsObject()
    {
        return SBaseAsObject(0);
    }
    ::Ice::ObjectPtr SBaseAsObject(const ::Ice::Context& __ctx)
    {
        return SBaseAsObject(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SBaseAsObject(const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBaseAsObject(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBaseAsObject(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBaseAsObject(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SBaseAsObject(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBaseAsObject(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBaseAsObject(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBaseAsObject(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SBaseAsObject(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ObjectPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Ice::ObjectPtr __ret;
                try
                {
                    __ret = __proxy->end_SBaseAsObject(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ObjectPtr&)> _response;
        };
        return begin_SBaseAsObject(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SBaseAsObject()
    {
        return begin_SBaseAsObject(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::Context& __ctx)
    {
        return begin_SBaseAsObject(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsObject(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsObject(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Test::Callback_TestIntf_SBaseAsObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsObject(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_SBaseAsObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsObject(&__ctx, __del, __cookie);
    }

    ::Ice::ObjectPtr end_SBaseAsObject(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ObjectPtr SBaseAsObject(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::SBasePtr SBaseAsSBase()
    {
        return SBaseAsSBase(0);
    }
    ::Test::SBasePtr SBaseAsSBase(const ::Ice::Context& __ctx)
    {
        return SBaseAsSBase(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SBaseAsSBase(const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBaseAsSBase(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBaseAsSBase(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBaseAsSBase(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SBaseAsSBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBaseAsSBase(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBaseAsSBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBaseAsSBase(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SBaseAsSBase(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::SBasePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::SBasePtr __ret;
                try
                {
                    __ret = __proxy->end_SBaseAsSBase(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::SBasePtr&)> _response;
        };
        return begin_SBaseAsSBase(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SBaseAsSBase()
    {
        return begin_SBaseAsSBase(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::Context& __ctx)
    {
        return begin_SBaseAsSBase(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsSBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsSBase(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Test::Callback_TestIntf_SBaseAsSBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsSBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_SBaseAsSBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBaseAsSBase(&__ctx, __del, __cookie);
    }

    ::Test::SBasePtr end_SBaseAsSBase(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::SBasePtr SBaseAsSBase(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::SBasePtr SBSKnownDerivedAsSBase()
    {
        return SBSKnownDerivedAsSBase(0);
    }
    ::Test::SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Context& __ctx)
    {
        return SBSKnownDerivedAsSBase(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBase(const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSKnownDerivedAsSBase(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBase(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSKnownDerivedAsSBase(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSKnownDerivedAsSBase(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSKnownDerivedAsSBase(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SBSKnownDerivedAsSBase(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::SBasePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::SBasePtr __ret;
                try
                {
                    __ret = __proxy->end_SBSKnownDerivedAsSBase(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::SBasePtr&)> _response;
        };
        return begin_SBSKnownDerivedAsSBase(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase()
    {
        return begin_SBSKnownDerivedAsSBase(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::Context& __ctx)
    {
        return begin_SBSKnownDerivedAsSBase(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBase(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBase(&__ctx, __del, __cookie);
    }

    ::Test::SBasePtr end_SBSKnownDerivedAsSBase(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived()
    {
        return SBSKnownDerivedAsSBSKnownDerived(0);
    }
    ::Test::SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& __ctx)
    {
        return SBSKnownDerivedAsSBSKnownDerived(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBSKnownDerived(const ::IceInternal::Function<void (const ::Test::SBSKnownDerivedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSKnownDerivedAsSBSKnownDerived(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBSKnownDerived(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::SBSKnownDerivedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSKnownDerivedAsSBSKnownDerived(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::SBSKnownDerivedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::SBSKnownDerivedPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::SBSKnownDerivedPtr __ret;
                try
                {
                    __ret = __proxy->end_SBSKnownDerivedAsSBSKnownDerived(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::SBSKnownDerivedPtr&)> _response;
        };
        return begin_SBSKnownDerivedAsSBSKnownDerived(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived()
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& __ctx)
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSKnownDerivedAsSBSKnownDerived(&__ctx, __del, __cookie);
    }

    ::Test::SBSKnownDerivedPtr end_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::SBasePtr SBSUnknownDerivedAsSBase()
    {
        return SBSUnknownDerivedAsSBase(0);
    }
    ::Test::SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Context& __ctx)
    {
        return SBSUnknownDerivedAsSBase(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBase(const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSUnknownDerivedAsSBase(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBase(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSUnknownDerivedAsSBase(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSUnknownDerivedAsSBase(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSUnknownDerivedAsSBase(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SBSUnknownDerivedAsSBase(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::SBasePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::SBasePtr __ret;
                try
                {
                    __ret = __proxy->end_SBSUnknownDerivedAsSBase(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::SBasePtr&)> _response;
        };
        return begin_SBSUnknownDerivedAsSBase(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase()
    {
        return begin_SBSUnknownDerivedAsSBase(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& __ctx)
    {
        return begin_SBSUnknownDerivedAsSBase(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBase(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBase(&__ctx, __del, __cookie);
    }

    ::Test::SBasePtr end_SBSUnknownDerivedAsSBase(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::SBasePtr SBSUnknownDerivedAsSBaseCompact()
    {
        return SBSUnknownDerivedAsSBaseCompact(0);
    }
    ::Test::SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& __ctx)
    {
        return SBSUnknownDerivedAsSBaseCompact(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBaseCompact(const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSUnknownDerivedAsSBaseCompact(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBaseCompact(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SBSUnknownDerivedAsSBaseCompact(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::SBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::SBasePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::SBasePtr __ret;
                try
                {
                    __ret = __proxy->end_SBSUnknownDerivedAsSBaseCompact(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::SBasePtr&)> _response;
        };
        return begin_SBSUnknownDerivedAsSBaseCompact(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact()
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& __ctx)
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SBSUnknownDerivedAsSBaseCompact(&__ctx, __del, __cookie);
    }

    ::Test::SBasePtr end_SBSUnknownDerivedAsSBaseCompact(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::ObjectPtr SUnknownAsObject()
    {
        return SUnknownAsObject(0);
    }
    ::Ice::ObjectPtr SUnknownAsObject(const ::Ice::Context& __ctx)
    {
        return SUnknownAsObject(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SUnknownAsObject(const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SUnknownAsObject(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SUnknownAsObject(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SUnknownAsObject(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SUnknownAsObject(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SUnknownAsObject(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SUnknownAsObject(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SUnknownAsObject(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SUnknownAsObject(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ObjectPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Ice::ObjectPtr __ret;
                try
                {
                    __ret = __proxy->end_SUnknownAsObject(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ObjectPtr&)> _response;
        };
        return begin_SUnknownAsObject(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SUnknownAsObject()
    {
        return begin_SUnknownAsObject(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::Context& __ctx)
    {
        return begin_SUnknownAsObject(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SUnknownAsObject(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SUnknownAsObject(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Test::Callback_TestIntf_SUnknownAsObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SUnknownAsObject(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_SUnknownAsObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SUnknownAsObject(&__ctx, __del, __cookie);
    }

    ::Ice::ObjectPtr end_SUnknownAsObject(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ObjectPtr SUnknownAsObject(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void checkSUnknown(const ::Ice::ObjectPtr& o)
    {
        checkSUnknown(o, 0);
    }
    void checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx)
    {
        checkSUnknown(o, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkSUnknown(o, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkSUnknown(o, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkSUnknown(o, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkSUnknown(o, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o)
    {
        return begin_checkSUnknown(o, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx)
    {
        return begin_checkSUnknown(o, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkSUnknown(o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkSUnknown(o, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Test::Callback_TestIntf_checkSUnknownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkSUnknown(o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_checkSUnknownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkSUnknown(o, &__ctx, __del, __cookie);
    }

    void end_checkSUnknown(const ::Ice::AsyncResultPtr&);
    
private:

    void checkSUnknown(const ::Ice::ObjectPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr oneElementCycle()
    {
        return oneElementCycle(0);
    }
    ::Test::BPtr oneElementCycle(const ::Ice::Context& __ctx)
    {
        return oneElementCycle(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_oneElementCycle(const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_oneElementCycle(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_oneElementCycle(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_oneElementCycle(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_oneElementCycle(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_oneElementCycle(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_oneElementCycle(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_oneElementCycle(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_oneElementCycle(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_oneElementCycle(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&)> _response;
        };
        return begin_oneElementCycle(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_oneElementCycle()
    {
        return begin_oneElementCycle(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::Context& __ctx)
    {
        return begin_oneElementCycle(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_oneElementCycle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_oneElementCycle(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Test::Callback_TestIntf_oneElementCyclePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_oneElementCycle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_oneElementCyclePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_oneElementCycle(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_oneElementCycle(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr oneElementCycle(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr twoElementCycle()
    {
        return twoElementCycle(0);
    }
    ::Test::BPtr twoElementCycle(const ::Ice::Context& __ctx)
    {
        return twoElementCycle(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_twoElementCycle(const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_twoElementCycle(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_twoElementCycle(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_twoElementCycle(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_twoElementCycle(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_twoElementCycle(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_twoElementCycle(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_twoElementCycle(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_twoElementCycle(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_twoElementCycle(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&)> _response;
        };
        return begin_twoElementCycle(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_twoElementCycle()
    {
        return begin_twoElementCycle(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::Context& __ctx)
    {
        return begin_twoElementCycle(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_twoElementCycle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_twoElementCycle(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Test::Callback_TestIntf_twoElementCyclePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_twoElementCycle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_twoElementCyclePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_twoElementCycle(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_twoElementCycle(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr twoElementCycle(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr D1AsB()
    {
        return D1AsB(0);
    }
    ::Test::BPtr D1AsB(const ::Ice::Context& __ctx)
    {
        return D1AsB(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_D1AsB(const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_D1AsB(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_D1AsB(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_D1AsB(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_D1AsB(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_D1AsB(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_D1AsB(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_D1AsB(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_D1AsB(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_D1AsB(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&)> _response;
        };
        return begin_D1AsB(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_D1AsB()
    {
        return begin_D1AsB(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::Context& __ctx)
    {
        return begin_D1AsB(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsB(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsB(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Test::Callback_TestIntf_D1AsBPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsB(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_D1AsBPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsB(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_D1AsB(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr D1AsB(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::D1Ptr D1AsD1()
    {
        return D1AsD1(0);
    }
    ::Test::D1Ptr D1AsD1(const ::Ice::Context& __ctx)
    {
        return D1AsD1(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_D1AsD1(const ::IceInternal::Function<void (const ::Test::D1Ptr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_D1AsD1(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_D1AsD1(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_D1AsD1(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_D1AsD1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::D1Ptr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_D1AsD1(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_D1AsD1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_D1AsD1(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_D1AsD1(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::D1Ptr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::D1Ptr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::D1Ptr __ret;
                try
                {
                    __ret = __proxy->end_D1AsD1(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::D1Ptr&)> _response;
        };
        return begin_D1AsD1(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_D1AsD1()
    {
        return begin_D1AsD1(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::Context& __ctx)
    {
        return begin_D1AsD1(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsD1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsD1(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Test::Callback_TestIntf_D1AsD1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsD1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_D1AsD1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D1AsD1(&__ctx, __del, __cookie);
    }

    ::Test::D1Ptr end_D1AsD1(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::D1Ptr D1AsD1(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr D2AsB()
    {
        return D2AsB(0);
    }
    ::Test::BPtr D2AsB(const ::Ice::Context& __ctx)
    {
        return D2AsB(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_D2AsB(const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_D2AsB(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_D2AsB(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_D2AsB(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_D2AsB(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_D2AsB(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_D2AsB(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_D2AsB(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_D2AsB(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_D2AsB(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&)> _response;
        };
        return begin_D2AsB(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_D2AsB()
    {
        return begin_D2AsB(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::Context& __ctx)
    {
        return begin_D2AsB(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D2AsB(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D2AsB(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Test::Callback_TestIntf_D2AsBPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D2AsB(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_D2AsBPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_D2AsB(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_D2AsB(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr D2AsB(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2)
    {
        paramTest1(p1, p2, 0);
    }
    void paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context& __ctx)
    {
        paramTest1(p1, p2, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_paramTest1(const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest1(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest1(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest1(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest1(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest1(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_paramTest1(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr p1;
                ::Test::BPtr p2;
                try
                {
                    __proxy->end_paramTest1(p1, p2, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(p1, p2);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&)> _response;
        };
        return begin_paramTest1(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_paramTest1()
    {
        return begin_paramTest1(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::Context& __ctx)
    {
        return begin_paramTest1(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest1(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Test::Callback_TestIntf_paramTest1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_paramTest1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest1(&__ctx, __del, __cookie);
    }

    void end_paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr&);
    
private:

    void paramTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1)
    {
        paramTest2(p2, p1, 0);
    }
    void paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context& __ctx)
    {
        paramTest2(p2, p1, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_paramTest2(const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest2(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest2(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest2(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest2(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest2(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest2(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest2(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_paramTest2(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr p2;
                ::Test::BPtr p1;
                try
                {
                    __proxy->end_paramTest2(p2, p1, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(p2, p1);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&)> _response;
        };
        return begin_paramTest2(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_paramTest2()
    {
        return begin_paramTest2(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::Context& __ctx)
    {
        return begin_paramTest2(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest2(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest2(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Test::Callback_TestIntf_paramTest2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest2(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_paramTest2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest2(&__ctx, __del, __cookie);
    }

    void end_paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::AsyncResultPtr&);
    
private:

    void paramTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2)
    {
        return paramTest3(p1, p2, 0);
    }
    ::Test::BPtr paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context& __ctx)
    {
        return paramTest3(p1, p2, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_paramTest3(const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest3(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest3(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest3(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest3(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest3(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest3(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest3(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_paramTest3(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr p1;
                ::Test::BPtr p2;
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_paramTest3(p1, p2, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p1, p2);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)> _response;
        };
        return begin_paramTest3(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_paramTest3()
    {
        return begin_paramTest3(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::Context& __ctx)
    {
        return begin_paramTest3(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest3(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest3(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Test::Callback_TestIntf_paramTest3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest3(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_paramTest3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest3(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr paramTest3(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr paramTest4(::Test::BPtr& p)
    {
        return paramTest4(p, 0);
    }
    ::Test::BPtr paramTest4(::Test::BPtr& p, const ::Ice::Context& __ctx)
    {
        return paramTest4(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_paramTest4(const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest4(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest4(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest4(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest4(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_paramTest4(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_paramTest4(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_paramTest4(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_paramTest4(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr p;
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_paramTest4(p, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&)> _response;
        };
        return begin_paramTest4(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_paramTest4()
    {
        return begin_paramTest4(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::Context& __ctx)
    {
        return begin_paramTest4(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest4(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest4(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Test::Callback_TestIntf_paramTest4Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest4(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_paramTest4Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_paramTest4(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_paramTest4(::Test::BPtr& p, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr paramTest4(::Test::BPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2)
    {
        return returnTest1(p1, p2, 0);
    }
    ::Test::BPtr returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context& __ctx)
    {
        return returnTest1(p1, p2, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_returnTest1(const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnTest1(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest1(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnTest1(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnTest1(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest1(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnTest1(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_returnTest1(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr p1;
                ::Test::BPtr p2;
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_returnTest1(p1, p2, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p1, p2);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)> _response;
        };
        return begin_returnTest1(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_returnTest1()
    {
        return begin_returnTest1(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::Context& __ctx)
    {
        return begin_returnTest1(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest1(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Test::Callback_TestIntf_returnTest1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest1(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_returnTest1Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest1(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr returnTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1)
    {
        return returnTest2(p2, p1, 0);
    }
    ::Test::BPtr returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context& __ctx)
    {
        return returnTest2(p2, p1, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_returnTest2(const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnTest2(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest2(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnTest2(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest2(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnTest2(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest2(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnTest2(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_returnTest2(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr p2;
                ::Test::BPtr p1;
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_returnTest2(p2, p1, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, p2, p1);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&)> _response;
        };
        return begin_returnTest2(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_returnTest2()
    {
        return begin_returnTest2(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::Context& __ctx)
    {
        return begin_returnTest2(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest2(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest2(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Test::Callback_TestIntf_returnTest2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest2(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_returnTest2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest2(&__ctx, __del, __cookie);
    }

    ::Test::BPtr end_returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr returnTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BPtr returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2)
    {
        return returnTest3(p1, p2, 0);
    }
    ::Test::BPtr returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& __ctx)
    {
        return returnTest3(p1, p2, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnTest3(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnTest3(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnTest3(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnTest3(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BPtr __ret;
                try
                {
                    __ret = __proxy->end_returnTest3(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BPtr&)> _response;
        };
        return begin_returnTest3(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2)
    {
        return begin_returnTest3(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& __ctx)
    {
        return begin_returnTest3(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest3(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest3(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Test::Callback_TestIntf_returnTest3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest3(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_returnTest3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnTest3(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::BPtr end_returnTest3(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BPtr returnTest3(const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::SS3 sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2)
    {
        return sequenceTest(p1, p2, 0);
    }
    ::Test::SS3 sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& __ctx)
    {
        return sequenceTest(p1, p2, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::IceInternal::Function<void (const ::Test::SS3&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_sequenceTest(p1, p2, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sequenceTest(p1, p2, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::SS3&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_sequenceTest(p1, p2, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sequenceTest(p1, p2, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::SS3&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::SS3&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::SS3 __ret;
                try
                {
                    __ret = __proxy->end_sequenceTest(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::SS3&)> _response;
        };
        return begin_sequenceTest(p1, p2, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2)
    {
        return begin_sequenceTest(p1, p2, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& __ctx)
    {
        return begin_sequenceTest(p1, p2, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sequenceTest(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sequenceTest(p1, p2, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Test::Callback_TestIntf_sequenceTestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sequenceTest(p1, p2, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_sequenceTestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sequenceTest(p1, p2, &__ctx, __del, __cookie);
    }

    ::Test::SS3 end_sequenceTest(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::SS3 sequenceTest(const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::BDict dictionaryTest(const ::Test::BDict& bin, ::Test::BDict& bout)
    {
        return dictionaryTest(bin, bout, 0);
    }
    ::Test::BDict dictionaryTest(const ::Test::BDict& bin, ::Test::BDict& bout, const ::Ice::Context& __ctx)
    {
        return dictionaryTest(bin, bout, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_dictionaryTest(const ::Test::BDict& bin, const ::IceInternal::Function<void (const ::Test::BDict&, const ::Test::BDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_dictionaryTest(bin, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_dictionaryTest(const ::Test::BDict& bin, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_dictionaryTest(bin, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::BDict&, const ::Test::BDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_dictionaryTest(bin, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_dictionaryTest(bin, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::BDict&, const ::Test::BDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::BDict&, const ::Test::BDict&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::BDict bout;
                ::Test::BDict __ret;
                try
                {
                    __ret = __proxy->end_dictionaryTest(bout, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret, bout);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::BDict&, const ::Test::BDict&)> _response;
        };
        return begin_dictionaryTest(bin, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin)
    {
        return begin_dictionaryTest(bin, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& __ctx)
    {
        return begin_dictionaryTest(bin, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dictionaryTest(bin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dictionaryTest(bin, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Test::Callback_TestIntf_dictionaryTestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dictionaryTest(bin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_dictionaryTestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dictionaryTest(bin, &__ctx, __del, __cookie);
    }

    ::Test::BDict end_dictionaryTest(::Test::BDict& bout, const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::BDict dictionaryTest(const ::Test::BDict&, ::Test::BDict&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::PBasePtr exchangePBase(const ::Test::PBasePtr& pb)
    {
        return exchangePBase(pb, 0);
    }
    ::Test::PBasePtr exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& __ctx)
    {
        return exchangePBase(pb, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_exchangePBase(const ::Test::PBasePtr& pb, const ::IceInternal::Function<void (const ::Test::PBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_exchangePBase(pb, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_exchangePBase(const ::Test::PBasePtr& pb, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exchangePBase(pb, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::PBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_exchangePBase(pb, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exchangePBase(pb, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::PBasePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::PBasePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::PBasePtr __ret;
                try
                {
                    __ret = __proxy->end_exchangePBase(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::PBasePtr&)> _response;
        };
        return begin_exchangePBase(pb, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb)
    {
        return begin_exchangePBase(pb, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& __ctx)
    {
        return begin_exchangePBase(pb, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePBase(pb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePBase(pb, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Test::Callback_TestIntf_exchangePBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePBase(pb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_exchangePBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePBase(pb, &__ctx, __del, __cookie);
    }

    ::Test::PBasePtr end_exchangePBase(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::PBasePtr exchangePBase(const ::Test::PBasePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::PreservedPtr PBSUnknownAsPreserved()
    {
        return PBSUnknownAsPreserved(0);
    }
    ::Test::PreservedPtr PBSUnknownAsPreserved(const ::Ice::Context& __ctx)
    {
        return PBSUnknownAsPreserved(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreserved(const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_PBSUnknownAsPreserved(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreserved(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_PBSUnknownAsPreserved(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreserved(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_PBSUnknownAsPreserved(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreserved(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_PBSUnknownAsPreserved(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_PBSUnknownAsPreserved(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::PreservedPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::PreservedPtr __ret;
                try
                {
                    __ret = __proxy->end_PBSUnknownAsPreserved(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::PreservedPtr&)> _response;
        };
        return begin_PBSUnknownAsPreserved(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved()
    {
        return begin_PBSUnknownAsPreserved(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::Context& __ctx)
    {
        return begin_PBSUnknownAsPreserved(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreserved(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreserved(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Test::Callback_TestIntf_PBSUnknownAsPreservedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreserved(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_PBSUnknownAsPreservedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreserved(&__ctx, __del, __cookie);
    }

    ::Test::PreservedPtr end_PBSUnknownAsPreserved(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::PreservedPtr PBSUnknownAsPreserved(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void checkPBSUnknown(const ::Test::PreservedPtr& p)
    {
        checkPBSUnknown(p, 0);
    }
    void checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx)
    {
        checkPBSUnknown(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkPBSUnknown(p, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkPBSUnknown(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkPBSUnknown(p, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkPBSUnknown(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p)
    {
        return begin_checkPBSUnknown(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx)
    {
        return begin_checkPBSUnknown(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Test::Callback_TestIntf_checkPBSUnknownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_checkPBSUnknownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown(p, &__ctx, __del, __cookie);
    }

    void end_checkPBSUnknown(const ::Ice::AsyncResultPtr&);
    
private:

    void checkPBSUnknown(const ::Test::PreservedPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::PreservedPtr PBSUnknownAsPreservedWithGraph()
    {
        return PBSUnknownAsPreservedWithGraph(0);
    }
    ::Test::PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Context& __ctx)
    {
        return PBSUnknownAsPreservedWithGraph(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreservedWithGraph(const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_PBSUnknownAsPreservedWithGraph(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreservedWithGraph(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_PBSUnknownAsPreservedWithGraph(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_PBSUnknownAsPreservedWithGraph(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_PBSUnknownAsPreservedWithGraph(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::PreservedPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::PreservedPtr __ret;
                try
                {
                    __ret = __proxy->end_PBSUnknownAsPreservedWithGraph(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::PreservedPtr&)> _response;
        };
        return begin_PBSUnknownAsPreservedWithGraph(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph()
    {
        return begin_PBSUnknownAsPreservedWithGraph(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& __ctx)
    {
        return begin_PBSUnknownAsPreservedWithGraph(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreservedWithGraph(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreservedWithGraph(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Test::Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreservedWithGraph(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknownAsPreservedWithGraph(&__ctx, __del, __cookie);
    }

    ::Test::PreservedPtr end_PBSUnknownAsPreservedWithGraph(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p)
    {
        checkPBSUnknownWithGraph(p, 0);
    }
    void checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx)
    {
        checkPBSUnknownWithGraph(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkPBSUnknownWithGraph(p, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkPBSUnknownWithGraph(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkPBSUnknownWithGraph(p, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkPBSUnknownWithGraph(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p)
    {
        return begin_checkPBSUnknownWithGraph(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx)
    {
        return begin_checkPBSUnknownWithGraph(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknownWithGraph(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknownWithGraph(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Test::Callback_TestIntf_checkPBSUnknownWithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknownWithGraph(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_checkPBSUnknownWithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknownWithGraph(p, &__ctx, __del, __cookie);
    }

    void end_checkPBSUnknownWithGraph(const ::Ice::AsyncResultPtr&);
    
private:

    void checkPBSUnknownWithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::PreservedPtr PBSUnknown2AsPreservedWithGraph()
    {
        return PBSUnknown2AsPreservedWithGraph(0);
    }
    ::Test::PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& __ctx)
    {
        return PBSUnknown2AsPreservedWithGraph(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_PBSUnknown2AsPreservedWithGraph(const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_PBSUnknown2AsPreservedWithGraph(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknown2AsPreservedWithGraph(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_PBSUnknown2AsPreservedWithGraph(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_PBSUnknown2AsPreservedWithGraph(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_PBSUnknown2AsPreservedWithGraph(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::PreservedPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::PreservedPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::PreservedPtr __ret;
                try
                {
                    __ret = __proxy->end_PBSUnknown2AsPreservedWithGraph(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::PreservedPtr&)> _response;
        };
        return begin_PBSUnknown2AsPreservedWithGraph(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph()
    {
        return begin_PBSUnknown2AsPreservedWithGraph(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& __ctx)
    {
        return begin_PBSUnknown2AsPreservedWithGraph(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknown2AsPreservedWithGraph(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknown2AsPreservedWithGraph(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Test::Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknown2AsPreservedWithGraph(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PBSUnknown2AsPreservedWithGraph(&__ctx, __del, __cookie);
    }

    ::Test::PreservedPtr end_PBSUnknown2AsPreservedWithGraph(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p)
    {
        checkPBSUnknown2WithGraph(p, 0);
    }
    void checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx)
    {
        checkPBSUnknown2WithGraph(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkPBSUnknown2WithGraph(p, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkPBSUnknown2WithGraph(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_checkPBSUnknown2WithGraph(p, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkPBSUnknown2WithGraph(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p)
    {
        return begin_checkPBSUnknown2WithGraph(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx)
    {
        return begin_checkPBSUnknown2WithGraph(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown2WithGraph(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown2WithGraph(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Test::Callback_TestIntf_checkPBSUnknown2WithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown2WithGraph(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_checkPBSUnknown2WithGraphPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkPBSUnknown2WithGraph(p, &__ctx, __del, __cookie);
    }

    void end_checkPBSUnknown2WithGraph(const ::Ice::AsyncResultPtr&);
    
private:

    void checkPBSUnknown2WithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::PNodePtr exchangePNode(const ::Test::PNodePtr& pn)
    {
        return exchangePNode(pn, 0);
    }
    ::Test::PNodePtr exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& __ctx)
    {
        return exchangePNode(pn, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_exchangePNode(const ::Test::PNodePtr& pn, const ::IceInternal::Function<void (const ::Test::PNodePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_exchangePNode(pn, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_exchangePNode(const ::Test::PNodePtr& pn, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exchangePNode(pn, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::PNodePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_exchangePNode(pn, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exchangePNode(pn, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::PNodePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::PNodePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::PNodePtr __ret;
                try
                {
                    __ret = __proxy->end_exchangePNode(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::PNodePtr&)> _response;
        };
        return begin_exchangePNode(pn, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn)
    {
        return begin_exchangePNode(pn, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& __ctx)
    {
        return begin_exchangePNode(pn, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePNode(pn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePNode(pn, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Test::Callback_TestIntf_exchangePNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePNode(pn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_exchangePNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exchangePNode(pn, &__ctx, __del, __cookie);
    }

    ::Test::PNodePtr end_exchangePNode(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::PNodePtr exchangePNode(const ::Test::PNodePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void throwBaseAsBase()
    {
        throwBaseAsBase(0);
    }
    void throwBaseAsBase(const ::Ice::Context& __ctx)
    {
        throwBaseAsBase(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_throwBaseAsBase(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwBaseAsBase(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwBaseAsBase(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwBaseAsBase(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_throwBaseAsBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwBaseAsBase(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwBaseAsBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwBaseAsBase(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_throwBaseAsBase(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_throwBaseAsBase(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_throwBaseAsBase(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_throwBaseAsBase()
    {
        return begin_throwBaseAsBase(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::Context& __ctx)
    {
        return begin_throwBaseAsBase(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwBaseAsBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwBaseAsBase(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Test::Callback_TestIntf_throwBaseAsBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwBaseAsBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_throwBaseAsBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwBaseAsBase(&__ctx, __del, __cookie);
    }

    void end_throwBaseAsBase(const ::Ice::AsyncResultPtr&);
    
private:

    void throwBaseAsBase(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void throwDerivedAsBase()
    {
        throwDerivedAsBase(0);
    }
    void throwDerivedAsBase(const ::Ice::Context& __ctx)
    {
        throwDerivedAsBase(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsBase(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwDerivedAsBase(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsBase(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwDerivedAsBase(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwDerivedAsBase(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwDerivedAsBase(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_throwDerivedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_throwDerivedAsBase(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_throwDerivedAsBase(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase()
    {
        return begin_throwDerivedAsBase(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::Context& __ctx)
    {
        return begin_throwDerivedAsBase(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsBase(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Test::Callback_TestIntf_throwDerivedAsBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_throwDerivedAsBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsBase(&__ctx, __del, __cookie);
    }

    void end_throwDerivedAsBase(const ::Ice::AsyncResultPtr&);
    
private:

    void throwDerivedAsBase(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void throwDerivedAsDerived()
    {
        throwDerivedAsDerived(0);
    }
    void throwDerivedAsDerived(const ::Ice::Context& __ctx)
    {
        throwDerivedAsDerived(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsDerived(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwDerivedAsDerived(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsDerived(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwDerivedAsDerived(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsDerived(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwDerivedAsDerived(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwDerivedAsDerived(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwDerivedAsDerived(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_throwDerivedAsDerived(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_throwDerivedAsDerived(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_throwDerivedAsDerived(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived()
    {
        return begin_throwDerivedAsDerived(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::Context& __ctx)
    {
        return begin_throwDerivedAsDerived(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsDerived(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsDerived(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Test::Callback_TestIntf_throwDerivedAsDerivedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsDerived(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_throwDerivedAsDerivedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwDerivedAsDerived(&__ctx, __del, __cookie);
    }

    void end_throwDerivedAsDerived(const ::Ice::AsyncResultPtr&);
    
private:

    void throwDerivedAsDerived(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void throwUnknownDerivedAsBase()
    {
        throwUnknownDerivedAsBase(0);
    }
    void throwUnknownDerivedAsBase(const ::Ice::Context& __ctx)
    {
        throwUnknownDerivedAsBase(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_throwUnknownDerivedAsBase(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwUnknownDerivedAsBase(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwUnknownDerivedAsBase(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwUnknownDerivedAsBase(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_throwUnknownDerivedAsBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwUnknownDerivedAsBase(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwUnknownDerivedAsBase(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwUnknownDerivedAsBase(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_throwUnknownDerivedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_throwUnknownDerivedAsBase(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_throwUnknownDerivedAsBase(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase()
    {
        return begin_throwUnknownDerivedAsBase(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::Context& __ctx)
    {
        return begin_throwUnknownDerivedAsBase(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwUnknownDerivedAsBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwUnknownDerivedAsBase(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Test::Callback_TestIntf_throwUnknownDerivedAsBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwUnknownDerivedAsBase(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_throwUnknownDerivedAsBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwUnknownDerivedAsBase(&__ctx, __del, __cookie);
    }

    void end_throwUnknownDerivedAsBase(const ::Ice::AsyncResultPtr&);
    
private:

    void throwUnknownDerivedAsBase(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void throwPreservedException()
    {
        throwPreservedException(0);
    }
    void throwPreservedException(const ::Ice::Context& __ctx)
    {
        throwPreservedException(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_throwPreservedException(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwPreservedException(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwPreservedException(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwPreservedException(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_throwPreservedException(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_throwPreservedException(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_throwPreservedException(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_throwPreservedException(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_throwPreservedException(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_throwPreservedException(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_throwPreservedException(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_throwPreservedException()
    {
        return begin_throwPreservedException(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::Context& __ctx)
    {
        return begin_throwPreservedException(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwPreservedException(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwPreservedException(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Test::Callback_TestIntf_throwPreservedExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwPreservedException(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_throwPreservedExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_throwPreservedException(&__ctx, __del, __cookie);
    }

    void end_throwPreservedException(const ::Ice::AsyncResultPtr&);
    
private:

    void throwPreservedException(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void useForward(::Test::ForwardPtr& f)
    {
        useForward(f, 0);
    }
    void useForward(::Test::ForwardPtr& f, const ::Ice::Context& __ctx)
    {
        useForward(f, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_useForward(const ::IceInternal::Function<void (const ::Test::ForwardPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_useForward(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_useForward(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_useForward(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_useForward(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::ForwardPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_useForward(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_useForward(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_useForward(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_useForward(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::ForwardPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::ForwardPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
                ::Test::ForwardPtr f;
                try
                {
                    __proxy->end_useForward(f, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(f);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::ForwardPtr&)> _response;
        };
        return begin_useForward(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_useForward()
    {
        return begin_useForward(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::Context& __ctx)
    {
        return begin_useForward(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_useForward(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_useForward(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Test::Callback_TestIntf_useForwardPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_useForward(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_useForwardPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_useForward(&__ctx, __del, __cookie);
    }

    void end_useForward(::Test::ForwardPtr& f, const ::Ice::AsyncResultPtr&);
    
private:

    void useForward(::Test::ForwardPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void shutdown()
    {
        shutdown(0);
    }
    void shutdown(const ::Ice::Context& __ctx)
    {
        shutdown(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_shutdown()
    {
        return begin_shutdown(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx)
    {
        return begin_shutdown(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Test::Callback_TestIntf_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);
    
private:

    void shutdown(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<TestIntf> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_secure(bool __secure) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_twoway() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_oneway() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_batchOneway() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_datagram() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_batchDatagram() const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_compress(bool __compress) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_timeout(int __timeout) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TestIntf> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<TestIntf*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Test
{

class SBase : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SBSKnownDerived : virtual public ::IceDelegate::Test::SBase
{
public:
};

class B : virtual public ::IceDelegate::Ice::Object
{
public:
};

class D1 : virtual public ::IceDelegate::Test::B
{
public:
};

class SS1 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class SS2 : virtual public ::IceDelegate::Ice::Object
{
public:
};

class PBase : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Preserved : virtual public ::IceDelegate::Test::PBase
{
public:
};

class PDerived : virtual public ::IceDelegate::Test::Preserved
{
public:
};

class PNode : virtual public ::IceDelegate::Ice::Object
{
public:
};

class TestIntf : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Ice::ObjectPtr SBaseAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::SBasePtr SBaseAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ObjectPtr SUnknownAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void checkSUnknown(const ::Ice::ObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr oneElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr twoElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr D1AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::D1Ptr D1AsD1(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr D2AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void paramTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void paramTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr paramTest3(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr paramTest4(::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr returnTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr returnTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BPtr returnTest3(const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::SS3 sequenceTest(const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::BDict dictionaryTest(const ::Test::BDict&, ::Test::BDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::PBasePtr exchangePBase(const ::Test::PBasePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::PreservedPtr PBSUnknownAsPreserved(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void checkPBSUnknown(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void checkPBSUnknownWithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void checkPBSUnknown2WithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::PNodePtr exchangePNode(const ::Test::PNodePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void throwBaseAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void throwDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void throwDerivedAsDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void throwUnknownDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void throwPreservedException(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void useForward(::Test::ForwardPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

namespace IceDelegateM
{

namespace Test
{

class SBase : virtual public ::IceDelegate::Test::SBase,
              virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SBSKnownDerived : virtual public ::IceDelegate::Test::SBSKnownDerived,
                        virtual public ::IceDelegateM::Test::SBase
{
public:
};

class B : virtual public ::IceDelegate::Test::B,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class D1 : virtual public ::IceDelegate::Test::D1,
           virtual public ::IceDelegateM::Test::B
{
public:
};

class SS1 : virtual public ::IceDelegate::Test::SS1,
            virtual public ::IceDelegateM::Ice::Object
{
public:
};

class SS2 : virtual public ::IceDelegate::Test::SS2,
            virtual public ::IceDelegateM::Ice::Object
{
public:
};

class PBase : virtual public ::IceDelegate::Test::PBase,
              virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Preserved : virtual public ::IceDelegate::Test::Preserved,
                  virtual public ::IceDelegateM::Test::PBase
{
public:
};

class PDerived : virtual public ::IceDelegate::Test::PDerived,
                 virtual public ::IceDelegateM::Test::Preserved
{
public:
};

class PNode : virtual public ::IceDelegate::Test::PNode,
              virtual public ::IceDelegateM::Ice::Object
{
public:
};

class TestIntf : virtual public ::IceDelegate::Test::TestIntf,
                 virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Ice::ObjectPtr SBaseAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBaseAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ObjectPtr SUnknownAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkSUnknown(const ::Ice::ObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr oneElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr twoElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr D1AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::D1Ptr D1AsD1(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr D2AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void paramTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void paramTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr paramTest3(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr paramTest4(::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr returnTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr returnTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr returnTest3(const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SS3 sequenceTest(const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BDict dictionaryTest(const ::Test::BDict&, ::Test::BDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PBasePtr exchangePBase(const ::Test::PBasePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PreservedPtr PBSUnknownAsPreserved(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkPBSUnknown(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkPBSUnknownWithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkPBSUnknown2WithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PNodePtr exchangePNode(const ::Test::PNodePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwBaseAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwDerivedAsDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwUnknownDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwPreservedException(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void useForward(::Test::ForwardPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceDelegateD
{

namespace Test
{

class SBase : virtual public ::IceDelegate::Test::SBase,
              virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SBSKnownDerived : virtual public ::IceDelegate::Test::SBSKnownDerived,
                        virtual public ::IceDelegateD::Test::SBase
{
public:
};

class B : virtual public ::IceDelegate::Test::B,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class D1 : virtual public ::IceDelegate::Test::D1,
           virtual public ::IceDelegateD::Test::B
{
public:
};

class SS1 : virtual public ::IceDelegate::Test::SS1,
            virtual public ::IceDelegateD::Ice::Object
{
public:
};

class SS2 : virtual public ::IceDelegate::Test::SS2,
            virtual public ::IceDelegateD::Ice::Object
{
public:
};

class PBase : virtual public ::IceDelegate::Test::PBase,
              virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Preserved : virtual public ::IceDelegate::Test::Preserved,
                  virtual public ::IceDelegateD::Test::PBase
{
public:
};

class PDerived : virtual public ::IceDelegate::Test::PDerived,
                 virtual public ::IceDelegateD::Test::Preserved
{
public:
};

class PNode : virtual public ::IceDelegate::Test::PNode,
              virtual public ::IceDelegateD::Ice::Object
{
public:
};

class TestIntf : virtual public ::IceDelegate::Test::TestIntf,
                 virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Ice::ObjectPtr SBaseAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBaseAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ObjectPtr SUnknownAsObject(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkSUnknown(const ::Ice::ObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr oneElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr twoElementCycle(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr D1AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::D1Ptr D1AsD1(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr D2AsB(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void paramTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void paramTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr paramTest3(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr paramTest4(::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr returnTest1(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr returnTest2(::Test::BPtr&, ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BPtr returnTest3(const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::SS3 sequenceTest(const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::BDict dictionaryTest(const ::Test::BDict&, ::Test::BDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PBasePtr exchangePBase(const ::Test::PBasePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PreservedPtr PBSUnknownAsPreserved(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkPBSUnknown(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkPBSUnknownWithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void checkPBSUnknown2WithGraph(const ::Test::PreservedPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::PNodePtr exchangePNode(const ::Test::PNodePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwBaseAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwDerivedAsDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwUnknownDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void throwPreservedException(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void useForward(::Test::ForwardPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace Test
{

class SBase : virtual public ::Ice::Object
{
public:

    typedef SBasePrx ProxyType;
    typedef SBasePtr PointerType;

    SBase()
    {
    }

    explicit SBase(const ::std::string& __ice_sb) :
        sb(__ice_sb)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string sb;

protected:

    virtual ~SBase() {}

    friend class SBase__staticInit;
};

class SBase__staticInit
{
public:

    ::Test::SBase _init;
};

static SBase__staticInit _SBase_init;

inline bool operator==(const SBase& l, const SBase& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SBase& l, const SBase& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SBSKnownDerived : public ::Test::SBase
{
public:

    typedef SBSKnownDerivedPrx ProxyType;
    typedef SBSKnownDerivedPtr PointerType;

    SBSKnownDerived()
    {
    }

    SBSKnownDerived(const ::std::string& __ice_sb, const ::std::string& __ice_sbskd) :
        ::Test::SBase(__ice_sb)
        ,
        sbskd(__ice_sbskd)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::SBase::__writeImpl;
    using ::Test::SBase::__readImpl;
    #endif

public:

    ::std::string sbskd;

protected:

    virtual ~SBSKnownDerived() {}
};

inline bool operator==(const SBSKnownDerived& l, const SBSKnownDerived& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SBSKnownDerived& l, const SBSKnownDerived& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(const ::std::string& __ice_sb, const ::Test::BPtr& __ice_pb) :
        sb(__ice_sb),
        pb(__ice_pb)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string sb;

    ::Test::BPtr pb;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D1 : public ::Test::B
{
public:

    typedef D1Prx ProxyType;
    typedef D1Ptr PointerType;

    D1()
    {
    }

    D1(const ::std::string& __ice_sb, const ::Test::BPtr& __ice_pb, const ::std::string& __ice_sd1, const ::Test::BPtr& __ice_pd1) :
        ::Test::B(__ice_sb, __ice_pb)
        ,
        sd1(__ice_sd1),
        pd1(__ice_pd1)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::B::__writeImpl;
    using ::Test::B::__readImpl;
    #endif

public:

    ::std::string sd1;

    ::Test::BPtr pd1;

protected:

    virtual ~D1() {}
};

inline bool operator==(const D1& l, const D1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D1& l, const D1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SS1 : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef SS1Prx ProxyType;
    typedef SS1Ptr PointerType;

    SS1()
    {
    }

    explicit SS1(const ::Test::BSeq& __ice_s) :
        s(__ice_s)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::BSeq s;

protected:

    virtual ~SS1() {}
};

inline bool operator==(const SS1& l, const SS1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SS1& l, const SS1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class SS2 : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef SS2Prx ProxyType;
    typedef SS2Ptr PointerType;

    SS2()
    {
    }

    explicit SS2(const ::Test::BSeq& __ice_s) :
        s(__ice_s)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::BSeq s;

protected:

    virtual ~SS2() {}
};

inline bool operator==(const SS2& l, const SS2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SS2& l, const SS2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PBase : virtual public ::Ice::Object
{
public:

    typedef PBasePrx ProxyType;
    typedef PBasePtr PointerType;

    PBase()
    {
    }

    explicit PBase(::Ice::Int __ice_pi) :
        pi(__ice_pi)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int pi;

protected:

    virtual ~PBase() {}
};

inline bool operator==(const PBase& l, const PBase& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PBase& l, const PBase& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Preserved : public ::Test::PBase, public IceInternal::GCShared
{
public:

    typedef PreservedPrx ProxyType;
    typedef PreservedPtr PointerType;

    Preserved()
    {
    }

    Preserved(::Ice::Int __ice_pi, const ::std::string& __ice_ps) :
        ::Test::PBase(__ice_pi)
        ,
        ps(__ice_ps)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::PBase::__write;
    using ::Test::PBase::__read;
    #endif

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::PBase::__writeImpl;
    using ::Test::PBase::__readImpl;
    #endif

public:

    ::std::string ps;

protected:

    virtual ~Preserved() {}

    ::Ice::SlicedDataPtr __slicedData;
};

inline bool operator==(const Preserved& l, const Preserved& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Preserved& l, const Preserved& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PDerived : public ::Test::Preserved
{
public:

    typedef PDerivedPrx ProxyType;
    typedef PDerivedPtr PointerType;

    PDerived()
    {
    }

    PDerived(::Ice::Int __ice_pi, const ::std::string& __ice_ps, const ::Test::PBasePtr& __ice_pb) :
        ::Test::Preserved(__ice_pi, __ice_ps)
        ,
        pb(__ice_pb)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::Preserved::__writeImpl;
    using ::Test::Preserved::__readImpl;
    #endif

public:

    ::Test::PBasePtr pb;

protected:

    virtual ~PDerived() {}
};

inline bool operator==(const PDerived& l, const PDerived& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PDerived& l, const PDerived& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PNode : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef PNodePrx ProxyType;
    typedef PNodePtr PointerType;

    PNode()
    {
    }

    explicit PNode(const ::Test::PNodePtr& __ice_next) :
        next(__ice_next)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__write;
    using ::Ice::Object::__read;
    #endif

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::PNodePtr next;

protected:

    virtual ~PNode() {}

    ::Ice::SlicedDataPtr __slicedData;
};

inline bool operator==(const PNode& l, const PNode& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PNode& l, const PNode& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class TestIntf : virtual public ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;
    typedef TestIntfPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void SBaseAsObject_async(const ::Test::AMD_TestIntf_SBaseAsObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SBaseAsObject(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SBaseAsSBase_async(const ::Test::AMD_TestIntf_SBaseAsSBasePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SBaseAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SBSKnownDerivedAsSBase_async(const ::Test::AMD_TestIntf_SBSKnownDerivedAsSBasePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SBSKnownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SBSKnownDerivedAsSBSKnownDerived_async(const ::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SBSUnknownDerivedAsSBase_async(const ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBasePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SBSUnknownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SBSUnknownDerivedAsSBaseCompact_async(const ::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SUnknownAsObject_async(const ::Test::AMD_TestIntf_SUnknownAsObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SUnknownAsObject(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void checkSUnknown_async(const ::Test::AMD_TestIntf_checkSUnknownPtr&, const ::Ice::ObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___checkSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void oneElementCycle_async(const ::Test::AMD_TestIntf_oneElementCyclePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___oneElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void twoElementCycle_async(const ::Test::AMD_TestIntf_twoElementCyclePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___twoElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void D1AsB_async(const ::Test::AMD_TestIntf_D1AsBPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___D1AsB(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void D1AsD1_async(const ::Test::AMD_TestIntf_D1AsD1Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___D1AsD1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void D2AsB_async(const ::Test::AMD_TestIntf_D2AsBPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___D2AsB(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void paramTest1_async(const ::Test::AMD_TestIntf_paramTest1Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___paramTest1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void paramTest2_async(const ::Test::AMD_TestIntf_paramTest2Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___paramTest2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void paramTest3_async(const ::Test::AMD_TestIntf_paramTest3Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___paramTest3(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void paramTest4_async(const ::Test::AMD_TestIntf_paramTest4Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___paramTest4(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void returnTest1_async(const ::Test::AMD_TestIntf_returnTest1Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___returnTest1(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void returnTest2_async(const ::Test::AMD_TestIntf_returnTest2Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___returnTest2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void returnTest3_async(const ::Test::AMD_TestIntf_returnTest3Ptr&, const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___returnTest3(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sequenceTest_async(const ::Test::AMD_TestIntf_sequenceTestPtr&, const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sequenceTest(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void dictionaryTest_async(const ::Test::AMD_TestIntf_dictionaryTestPtr&, const ::Test::BDict&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___dictionaryTest(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void exchangePBase_async(const ::Test::AMD_TestIntf_exchangePBasePtr&, const ::Test::PBasePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___exchangePBase(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void PBSUnknownAsPreserved_async(const ::Test::AMD_TestIntf_PBSUnknownAsPreservedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___PBSUnknownAsPreserved(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void checkPBSUnknown_async(const ::Test::AMD_TestIntf_checkPBSUnknownPtr&, const ::Test::PreservedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___checkPBSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void PBSUnknownAsPreservedWithGraph_async(const ::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraphPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void checkPBSUnknownWithGraph_async(const ::Test::AMD_TestIntf_checkPBSUnknownWithGraphPtr&, const ::Test::PreservedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___checkPBSUnknownWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void PBSUnknown2AsPreservedWithGraph_async(const ::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraphPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void checkPBSUnknown2WithGraph_async(const ::Test::AMD_TestIntf_checkPBSUnknown2WithGraphPtr&, const ::Test::PreservedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___checkPBSUnknown2WithGraph(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void exchangePNode_async(const ::Test::AMD_TestIntf_exchangePNodePtr&, const ::Test::PNodePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___exchangePNode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void throwBaseAsBase_async(const ::Test::AMD_TestIntf_throwBaseAsBasePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___throwBaseAsBase(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void throwDerivedAsBase_async(const ::Test::AMD_TestIntf_throwDerivedAsBasePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___throwDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void throwDerivedAsDerived_async(const ::Test::AMD_TestIntf_throwDerivedAsDerivedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___throwDerivedAsDerived(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void throwUnknownDerivedAsBase_async(const ::Test::AMD_TestIntf_throwUnknownDerivedAsBasePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___throwUnknownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void throwPreservedException_async(const ::Test::AMD_TestIntf_throwPreservedExceptionPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___throwPreservedException(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void useForward_async(const ::Test::AMD_TestIntf_useForwardPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___useForward(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void shutdown_async(const ::Test::AMD_TestIntf_shutdownPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const TestIntf& l, const TestIntf& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const TestIntf& l, const TestIntf& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Test
{

template<class T>
class CallbackNC_TestIntf_SBaseAsObject : public Callback_TestIntf_SBaseAsObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&);

    CallbackNC_TestIntf_SBaseAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPtr __ret;
        try
        {
            __ret = __proxy->end_SBaseAsObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsObject<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_SBaseAsObject : public Callback_TestIntf_SBaseAsObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&, const CT&);

    Callback_TestIntf_SBaseAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPtr __ret;
        try
        {
            __ret = __proxy->end_SBaseAsObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_SBaseAsSBase : public Callback_TestIntf_SBaseAsSBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::SBasePtr&);

    CallbackNC_TestIntf_SBaseAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBaseAsSBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsSBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(T* instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsSBase<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_SBaseAsSBase : public Callback_TestIntf_SBaseAsSBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::SBasePtr&, const CT&);

    Callback_TestIntf_SBaseAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBaseAsSBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsSBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(T* instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsSBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_SBSKnownDerivedAsSBase : public Callback_TestIntf_SBSKnownDerivedAsSBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::SBasePtr&);

    CallbackNC_TestIntf_SBSKnownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBSKnownDerivedAsSBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(T* instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_SBSKnownDerivedAsSBase : public Callback_TestIntf_SBSKnownDerivedAsSBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::SBasePtr&, const CT&);

    Callback_TestIntf_SBSKnownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBSKnownDerivedAsSBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(T* instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived : public Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::SBSKnownDerivedPtr&);

    CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBSKnownDerivedPtr __ret;
        try
        {
            __ret = __proxy->end_SBSKnownDerivedAsSBSKnownDerived(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBSKnownDerivedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(T* instance, void (T::*cb)(const ::Test::SBSKnownDerivedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived : public Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::SBSKnownDerivedPtr&, const CT&);

    Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBSKnownDerivedPtr __ret;
        try
        {
            __ret = __proxy->end_SBSKnownDerivedAsSBSKnownDerived(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBSKnownDerivedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(T* instance, void (T::*cb)(const ::Test::SBSKnownDerivedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_SBSUnknownDerivedAsSBase : public Callback_TestIntf_SBSUnknownDerivedAsSBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::SBasePtr&);

    CallbackNC_TestIntf_SBSUnknownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBSUnknownDerivedAsSBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(T* instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_SBSUnknownDerivedAsSBase : public Callback_TestIntf_SBSUnknownDerivedAsSBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::SBasePtr&, const CT&);

    Callback_TestIntf_SBSUnknownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBSUnknownDerivedAsSBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(T* instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact : public Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::SBasePtr&);

    CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBSUnknownDerivedAsSBaseCompact(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(T* instance, void (T::*cb)(const ::Test::SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact : public Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::SBasePtr&, const CT&);

    Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SBasePtr __ret;
        try
        {
            __ret = __proxy->end_SBSUnknownDerivedAsSBaseCompact(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(T* instance, void (T::*cb)(const ::Test::SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_SUnknownAsObject : public Callback_TestIntf_SUnknownAsObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&);

    CallbackNC_TestIntf_SUnknownAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPtr __ret;
        try
        {
            __ret = __proxy->end_SUnknownAsObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SUnknownAsObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SUnknownAsObject<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_SUnknownAsObject : public Callback_TestIntf_SUnknownAsObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&, const CT&);

    Callback_TestIntf_SUnknownAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPtr __ret;
        try
        {
            __ret = __proxy->end_SUnknownAsObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SUnknownAsObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SUnknownAsObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_checkSUnknown : public Callback_TestIntf_checkSUnknown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_checkSUnknown : public Callback_TestIntf_checkSUnknown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_oneElementCycle : public Callback_TestIntf_oneElementCycle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&);

    CallbackNC_TestIntf_oneElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_oneElementCycle(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_oneElementCycle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(T* instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_oneElementCycle<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_oneElementCycle : public Callback_TestIntf_oneElementCycle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const CT&);

    Callback_TestIntf_oneElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_oneElementCycle(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_oneElementCycle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(T* instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_oneElementCycle<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_twoElementCycle : public Callback_TestIntf_twoElementCycle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&);

    CallbackNC_TestIntf_twoElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_twoElementCycle(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_twoElementCycle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(T* instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_twoElementCycle<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_twoElementCycle : public Callback_TestIntf_twoElementCycle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const CT&);

    Callback_TestIntf_twoElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_twoElementCycle(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_twoElementCycle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(T* instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_twoElementCycle<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_D1AsB : public Callback_TestIntf_D1AsB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&);

    CallbackNC_TestIntf_D1AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_D1AsB(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsB<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(T* instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsB<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_D1AsB : public Callback_TestIntf_D1AsB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const CT&);

    Callback_TestIntf_D1AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_D1AsB(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsB<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(T* instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsB<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_D1AsD1 : public Callback_TestIntf_D1AsD1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::D1Ptr&);

    CallbackNC_TestIntf_D1AsD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::D1Ptr __ret;
        try
        {
            __ret = __proxy->end_D1AsD1(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::D1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsD1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(T* instance, void (T::*cb)(const ::Test::D1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsD1<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_D1AsD1 : public Callback_TestIntf_D1AsD1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::D1Ptr&, const CT&);

    Callback_TestIntf_D1AsD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::D1Ptr __ret;
        try
        {
            __ret = __proxy->end_D1AsD1(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::D1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsD1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(T* instance, void (T::*cb)(const ::Test::D1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsD1<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_D2AsB : public Callback_TestIntf_D2AsB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&);

    CallbackNC_TestIntf_D2AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_D2AsB(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D2AsB<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(T* instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D2AsB<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_D2AsB : public Callback_TestIntf_D2AsB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const CT&);

    Callback_TestIntf_D2AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_D2AsB(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D2AsB<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(T* instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D2AsB<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_paramTest1 : public Callback_TestIntf_paramTest1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&);

    CallbackNC_TestIntf_paramTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p1;
        ::Test::BPtr p2;
        try
        {
            __proxy->end_paramTest1(p1, p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(p1, p2);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest1<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_paramTest1 : public Callback_TestIntf_paramTest1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&);

    Callback_TestIntf_paramTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p1;
        ::Test::BPtr p2;
        try
        {
            __proxy->end_paramTest1(p1, p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(p1, p2, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest1<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_paramTest2 : public Callback_TestIntf_paramTest2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&);

    CallbackNC_TestIntf_paramTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p2;
        ::Test::BPtr p1;
        try
        {
            __proxy->end_paramTest2(p2, p1, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(p2, p1);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_paramTest2 : public Callback_TestIntf_paramTest2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&);

    Callback_TestIntf_paramTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p2;
        ::Test::BPtr p1;
        try
        {
            __proxy->end_paramTest2(p2, p1, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(p2, p1, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_paramTest3 : public Callback_TestIntf_paramTest3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&);

    CallbackNC_TestIntf_paramTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p1;
        ::Test::BPtr p2;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_paramTest3(p1, p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p1, p2);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest3<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest3<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_paramTest3 : public Callback_TestIntf_paramTest3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&);

    Callback_TestIntf_paramTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p1;
        ::Test::BPtr p2;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_paramTest3(p1, p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p1, p2, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest3<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest3<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_paramTest4 : public Callback_TestIntf_paramTest4_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&);

    CallbackNC_TestIntf_paramTest4(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_paramTest4(p, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest4<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest4<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_paramTest4 : public Callback_TestIntf_paramTest4_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&);

    Callback_TestIntf_paramTest4(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_paramTest4(p, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest4<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest4<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_returnTest1 : public Callback_TestIntf_returnTest1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&);

    CallbackNC_TestIntf_returnTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p1;
        ::Test::BPtr p2;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_returnTest1(p1, p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p1, p2);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest1<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest1<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_returnTest1 : public Callback_TestIntf_returnTest1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&);

    Callback_TestIntf_returnTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p1;
        ::Test::BPtr p2;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_returnTest1(p1, p2, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p1, p2, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest1<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest1<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_returnTest2 : public Callback_TestIntf_returnTest2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&);

    CallbackNC_TestIntf_returnTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p2;
        ::Test::BPtr p1;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_returnTest2(p2, p1, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, p2, p1);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_returnTest2 : public Callback_TestIntf_returnTest2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&);

    Callback_TestIntf_returnTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr p2;
        ::Test::BPtr p1;
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_returnTest2(p2, p1, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, p2, p1, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(T* instance, void (T::*cb)(const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_returnTest3 : public Callback_TestIntf_returnTest3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BPtr&);

    CallbackNC_TestIntf_returnTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_returnTest3(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest3<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(T* instance, void (T::*cb)(const ::Test::BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest3<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_returnTest3 : public Callback_TestIntf_returnTest3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BPtr&, const CT&);

    Callback_TestIntf_returnTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BPtr __ret;
        try
        {
            __ret = __proxy->end_returnTest3(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest3<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(T* instance, void (T::*cb)(const ::Test::BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest3<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_sequenceTest : public Callback_TestIntf_sequenceTest_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::SS3&);

    CallbackNC_TestIntf_sequenceTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SS3 __ret;
        try
        {
            __ret = __proxy->end_sequenceTest(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SS3&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_sequenceTest<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(T* instance, void (T::*cb)(const ::Test::SS3&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_sequenceTest<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_sequenceTest : public Callback_TestIntf_sequenceTest_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::SS3&, const CT&);

    Callback_TestIntf_sequenceTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::SS3 __ret;
        try
        {
            __ret = __proxy->end_sequenceTest(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::SS3&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_sequenceTest<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(T* instance, void (T::*cb)(const ::Test::SS3&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_sequenceTest<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_dictionaryTest : public Callback_TestIntf_dictionaryTest_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::BDict&, const ::Test::BDict&);

    CallbackNC_TestIntf_dictionaryTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BDict bout;
        ::Test::BDict __ret;
        try
        {
            __ret = __proxy->end_dictionaryTest(bout, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, bout);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BDict&, const ::Test::BDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_dictionaryTest<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(T* instance, void (T::*cb)(const ::Test::BDict&, const ::Test::BDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_dictionaryTest<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_dictionaryTest : public Callback_TestIntf_dictionaryTest_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::BDict&, const ::Test::BDict&, const CT&);

    Callback_TestIntf_dictionaryTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::BDict bout;
        ::Test::BDict __ret;
        try
        {
            __ret = __proxy->end_dictionaryTest(bout, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, bout, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::BDict&, const ::Test::BDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_dictionaryTest<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(T* instance, void (T::*cb)(const ::Test::BDict&, const ::Test::BDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_dictionaryTest<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_exchangePBase : public Callback_TestIntf_exchangePBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::PBasePtr&);

    CallbackNC_TestIntf_exchangePBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PBasePtr __ret;
        try
        {
            __ret = __proxy->end_exchangePBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(T* instance, void (T::*cb)(const ::Test::PBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePBase<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_exchangePBase : public Callback_TestIntf_exchangePBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::PBasePtr&, const CT&);

    Callback_TestIntf_exchangePBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PBasePtr __ret;
        try
        {
            __ret = __proxy->end_exchangePBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(T* instance, void (T::*cb)(const ::Test::PBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_PBSUnknownAsPreserved : public Callback_TestIntf_PBSUnknownAsPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::PreservedPtr&);

    CallbackNC_TestIntf_PBSUnknownAsPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PreservedPtr __ret;
        try
        {
            __ret = __proxy->end_PBSUnknownAsPreserved(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreserved<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(T* instance, void (T::*cb)(const ::Test::PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreserved<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_PBSUnknownAsPreserved : public Callback_TestIntf_PBSUnknownAsPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::PreservedPtr&, const CT&);

    Callback_TestIntf_PBSUnknownAsPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PreservedPtr __ret;
        try
        {
            __ret = __proxy->end_PBSUnknownAsPreserved(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreserved<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(T* instance, void (T::*cb)(const ::Test::PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreserved<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_checkPBSUnknown : public Callback_TestIntf_checkPBSUnknown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkPBSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_checkPBSUnknown : public Callback_TestIntf_checkPBSUnknown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkPBSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph : public Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::PreservedPtr&);

    CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PreservedPtr __ret;
        try
        {
            __ret = __proxy->end_PBSUnknownAsPreservedWithGraph(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(T* instance, void (T::*cb)(const ::Test::PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_PBSUnknownAsPreservedWithGraph : public Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::PreservedPtr&, const CT&);

    Callback_TestIntf_PBSUnknownAsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PreservedPtr __ret;
        try
        {
            __ret = __proxy->end_PBSUnknownAsPreservedWithGraph(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(T* instance, void (T::*cb)(const ::Test::PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_checkPBSUnknownWithGraph : public Callback_TestIntf_checkPBSUnknownWithGraph_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkPBSUnknownWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_checkPBSUnknownWithGraph : public Callback_TestIntf_checkPBSUnknownWithGraph_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkPBSUnknownWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph : public Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::PreservedPtr&);

    CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PreservedPtr __ret;
        try
        {
            __ret = __proxy->end_PBSUnknown2AsPreservedWithGraph(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(T* instance, void (T::*cb)(const ::Test::PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_PBSUnknown2AsPreservedWithGraph : public Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::PreservedPtr&, const CT&);

    Callback_TestIntf_PBSUnknown2AsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PreservedPtr __ret;
        try
        {
            __ret = __proxy->end_PBSUnknown2AsPreservedWithGraph(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknown2AsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(T* instance, void (T::*cb)(const ::Test::PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknown2AsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_checkPBSUnknown2WithGraph : public Callback_TestIntf_checkPBSUnknown2WithGraph_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkPBSUnknown2WithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_checkPBSUnknown2WithGraph : public Callback_TestIntf_checkPBSUnknown2WithGraph_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkPBSUnknown2WithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_exchangePNode : public Callback_TestIntf_exchangePNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::PNodePtr&);

    CallbackNC_TestIntf_exchangePNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PNodePtr __ret;
        try
        {
            __ret = __proxy->end_exchangePNode(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PNodePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(T* instance, void (T::*cb)(const ::Test::PNodePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePNode<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_exchangePNode : public Callback_TestIntf_exchangePNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::PNodePtr&, const CT&);

    Callback_TestIntf_exchangePNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::PNodePtr __ret;
        try
        {
            __ret = __proxy->end_exchangePNode(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::PNodePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(T* instance, void (T::*cb)(const ::Test::PNodePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_throwBaseAsBase : public Callback_TestIntf_throwBaseAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwBaseAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwBaseAsBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_throwBaseAsBase : public Callback_TestIntf_throwBaseAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwBaseAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwBaseAsBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_throwDerivedAsBase : public Callback_TestIntf_throwDerivedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwDerivedAsBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_throwDerivedAsBase : public Callback_TestIntf_throwDerivedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwDerivedAsBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_throwDerivedAsDerived : public Callback_TestIntf_throwDerivedAsDerived_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwDerivedAsDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwDerivedAsDerived(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_throwDerivedAsDerived : public Callback_TestIntf_throwDerivedAsDerived_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwDerivedAsDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwDerivedAsDerived(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_throwUnknownDerivedAsBase : public Callback_TestIntf_throwUnknownDerivedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwUnknownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwUnknownDerivedAsBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_throwUnknownDerivedAsBase : public Callback_TestIntf_throwUnknownDerivedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwUnknownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwUnknownDerivedAsBase(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_throwPreservedException : public Callback_TestIntf_throwPreservedException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwPreservedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwPreservedException(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_throwPreservedException : public Callback_TestIntf_throwPreservedException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwPreservedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_throwPreservedException(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_useForward : public Callback_TestIntf_useForward_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::ForwardPtr&);

    CallbackNC_TestIntf_useForward(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ForwardPtr f;
        try
        {
            __proxy->end_useForward(f, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(f);
        }
    }

    Response response;
};

template<class T> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ForwardPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_useForward<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(T* instance, void (T::*cb)(const ::Test::ForwardPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_useForward<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_useForward : public Callback_TestIntf_useForward_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::ForwardPtr&, const CT&);

    Callback_TestIntf_useForward(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::TestIntfPrx __proxy = ::Test::TestIntfPrx::uncheckedCast(__result->getProxy());
        ::Test::ForwardPtr f;
        try
        {
            __proxy->end_useForward(f, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(f, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::ForwardPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_useForward<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(T* instance, void (T::*cb)(const ::Test::ForwardPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_useForward<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif
