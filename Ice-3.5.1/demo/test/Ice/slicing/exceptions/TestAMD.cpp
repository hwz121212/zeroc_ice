// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <TestAMD.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SlicedData.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Test__Relay__knownPreservedAsBase_name = "knownPreservedAsBase";

const ::std::string __Test__Relay__knownPreservedAsKnownPreserved_name = "knownPreservedAsKnownPreserved";

const ::std::string __Test__Relay__unknownPreservedAsBase_name = "unknownPreservedAsBase";

const ::std::string __Test__Relay__unknownPreservedAsKnownPreserved_name = "unknownPreservedAsKnownPreserved";

const ::std::string __Test__TestIntf__baseAsBase_name = "baseAsBase";

const ::std::string __Test__TestIntf__unknownDerivedAsBase_name = "unknownDerivedAsBase";

const ::std::string __Test__TestIntf__knownDerivedAsBase_name = "knownDerivedAsBase";

const ::std::string __Test__TestIntf__knownDerivedAsKnownDerived_name = "knownDerivedAsKnownDerived";

const ::std::string __Test__TestIntf__unknownIntermediateAsBase_name = "unknownIntermediateAsBase";

const ::std::string __Test__TestIntf__knownIntermediateAsBase_name = "knownIntermediateAsBase";

const ::std::string __Test__TestIntf__knownMostDerivedAsBase_name = "knownMostDerivedAsBase";

const ::std::string __Test__TestIntf__knownIntermediateAsKnownIntermediate_name = "knownIntermediateAsKnownIntermediate";

const ::std::string __Test__TestIntf__knownMostDerivedAsKnownIntermediate_name = "knownMostDerivedAsKnownIntermediate";

const ::std::string __Test__TestIntf__knownMostDerivedAsKnownMostDerived_name = "knownMostDerivedAsKnownMostDerived";

const ::std::string __Test__TestIntf__unknownMostDerived1AsBase_name = "unknownMostDerived1AsBase";

const ::std::string __Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name = "unknownMostDerived1AsKnownIntermediate";

const ::std::string __Test__TestIntf__unknownMostDerived2AsBase_name = "unknownMostDerived2AsBase";

const ::std::string __Test__TestIntf__unknownMostDerived2AsBaseCompact_name = "unknownMostDerived2AsBaseCompact";

const ::std::string __Test__TestIntf__knownPreservedAsBase_name = "knownPreservedAsBase";

const ::std::string __Test__TestIntf__knownPreservedAsKnownPreserved_name = "knownPreservedAsKnownPreserved";

const ::std::string __Test__TestIntf__relayKnownPreservedAsBase_name = "relayKnownPreservedAsBase";

const ::std::string __Test__TestIntf__relayKnownPreservedAsKnownPreserved_name = "relayKnownPreservedAsKnownPreserved";

const ::std::string __Test__TestIntf__unknownPreservedAsBase_name = "unknownPreservedAsBase";

const ::std::string __Test__TestIntf__unknownPreservedAsKnownPreserved_name = "unknownPreservedAsKnownPreserved";

const ::std::string __Test__TestIntf__relayUnknownPreservedAsBase_name = "relayUnknownPreservedAsBase";

const ::std::string __Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name = "relayUnknownPreservedAsKnownPreserved";

const ::std::string __Test__TestIntf__shutdown_name = "shutdown";

}

namespace
{

const char* __Test__Base_name = "Test::Base";

struct __F__Test__Base : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::Base();
    }
};

class __F__Test__Base__Init
{
public:

    __F__Test__Base__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::Base", new __F__Test__Base);
    }

    ~__F__Test__Base__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::Base");
    }
};

const __F__Test__Base__Init __F__Test__Base__i;

}

Test::Base::Base(const ::std::string& __ice_b) :
    ::Ice::UserException(),
    b(__ice_b)
{
}

Test::Base::~Base() throw()
{
}

::std::string
Test::Base::ice_name() const
{
    return __Test__Base_name;
}

Test::Base*
Test::Base::ice_clone() const
{
    return new Base(*this);
}

void
Test::Base::ice_throw() const
{
    throw *this;
}

void
Test::Base::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::Base", -1, true);
    __os->write(b);
    __os->endWriteSlice();
}

void
Test::Base::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(b);
    __is->endReadSlice();
}

namespace
{

const char* __Test__KnownDerived_name = "Test::KnownDerived";

struct __F__Test__KnownDerived : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::KnownDerived();
    }
};

class __F__Test__KnownDerived__Init
{
public:

    __F__Test__KnownDerived__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::KnownDerived", new __F__Test__KnownDerived);
    }

    ~__F__Test__KnownDerived__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::KnownDerived");
    }
};

const __F__Test__KnownDerived__Init __F__Test__KnownDerived__i;

}

Test::KnownDerived::KnownDerived(const ::std::string& __ice_b, const ::std::string& __ice_kd) :
    ::Test::Base(__ice_b),
    kd(__ice_kd)
{
}

Test::KnownDerived::~KnownDerived() throw()
{
}

::std::string
Test::KnownDerived::ice_name() const
{
    return __Test__KnownDerived_name;
}

Test::KnownDerived*
Test::KnownDerived::ice_clone() const
{
    return new KnownDerived(*this);
}

void
Test::KnownDerived::ice_throw() const
{
    throw *this;
}

void
Test::KnownDerived::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::KnownDerived", -1, false);
    __os->write(kd);
    __os->endWriteSlice();
    ::Test::Base::__writeImpl(__os);
}

void
Test::KnownDerived::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(kd);
    __is->endReadSlice();
    ::Test::Base::__readImpl(__is);
}

namespace
{

const char* __Test__KnownIntermediate_name = "Test::KnownIntermediate";

struct __F__Test__KnownIntermediate : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::KnownIntermediate();
    }
};

class __F__Test__KnownIntermediate__Init
{
public:

    __F__Test__KnownIntermediate__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::KnownIntermediate", new __F__Test__KnownIntermediate);
    }

    ~__F__Test__KnownIntermediate__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::KnownIntermediate");
    }
};

const __F__Test__KnownIntermediate__Init __F__Test__KnownIntermediate__i;

}

Test::KnownIntermediate::KnownIntermediate(const ::std::string& __ice_b, const ::std::string& __ice_ki) :
    ::Test::Base(__ice_b),
    ki(__ice_ki)
{
}

Test::KnownIntermediate::~KnownIntermediate() throw()
{
}

::std::string
Test::KnownIntermediate::ice_name() const
{
    return __Test__KnownIntermediate_name;
}

Test::KnownIntermediate*
Test::KnownIntermediate::ice_clone() const
{
    return new KnownIntermediate(*this);
}

void
Test::KnownIntermediate::ice_throw() const
{
    throw *this;
}

void
Test::KnownIntermediate::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::KnownIntermediate", -1, false);
    __os->write(ki);
    __os->endWriteSlice();
    ::Test::Base::__writeImpl(__os);
}

void
Test::KnownIntermediate::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(ki);
    __is->endReadSlice();
    ::Test::Base::__readImpl(__is);
}

namespace
{

const char* __Test__KnownMostDerived_name = "Test::KnownMostDerived";

struct __F__Test__KnownMostDerived : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::KnownMostDerived();
    }
};

class __F__Test__KnownMostDerived__Init
{
public:

    __F__Test__KnownMostDerived__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::KnownMostDerived", new __F__Test__KnownMostDerived);
    }

    ~__F__Test__KnownMostDerived__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::KnownMostDerived");
    }
};

const __F__Test__KnownMostDerived__Init __F__Test__KnownMostDerived__i;

}

Test::KnownMostDerived::KnownMostDerived(const ::std::string& __ice_b, const ::std::string& __ice_ki, const ::std::string& __ice_kmd) :
    ::Test::KnownIntermediate(__ice_b, __ice_ki),
    kmd(__ice_kmd)
{
}

Test::KnownMostDerived::~KnownMostDerived() throw()
{
}

::std::string
Test::KnownMostDerived::ice_name() const
{
    return __Test__KnownMostDerived_name;
}

Test::KnownMostDerived*
Test::KnownMostDerived::ice_clone() const
{
    return new KnownMostDerived(*this);
}

void
Test::KnownMostDerived::ice_throw() const
{
    throw *this;
}

void
Test::KnownMostDerived::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::KnownMostDerived", -1, false);
    __os->write(kmd);
    __os->endWriteSlice();
    ::Test::KnownIntermediate::__writeImpl(__os);
}

void
Test::KnownMostDerived::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(kmd);
    __is->endReadSlice();
    ::Test::KnownIntermediate::__readImpl(__is);
}

namespace
{

const char* __Test__KnownPreserved_name = "Test::KnownPreserved";

struct __F__Test__KnownPreserved : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::KnownPreserved();
    }
};

class __F__Test__KnownPreserved__Init
{
public:

    __F__Test__KnownPreserved__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::KnownPreserved", new __F__Test__KnownPreserved);
    }

    ~__F__Test__KnownPreserved__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::KnownPreserved");
    }
};

const __F__Test__KnownPreserved__Init __F__Test__KnownPreserved__i;

}

Test::KnownPreserved::KnownPreserved(const ::std::string& __ice_b, const ::std::string& __ice_kp) :
    ::Test::Base(__ice_b),
    kp(__ice_kp)
{
}

Test::KnownPreserved::~KnownPreserved() throw()
{
}

::std::string
Test::KnownPreserved::ice_name() const
{
    return __Test__KnownPreserved_name;
}

Test::KnownPreserved*
Test::KnownPreserved::ice_clone() const
{
    return new KnownPreserved(*this);
}

void
Test::KnownPreserved::ice_throw() const
{
    throw *this;
}

void
Test::KnownPreserved::__write(::IceInternal::BasicStream* __os) const
{
    __os->startWriteException(__slicedData);
    __writeImpl(__os);
    __os->endWriteException();
}

void
Test::KnownPreserved::__read(::IceInternal::BasicStream* __is)
{
    __is->startReadException();
    __readImpl(__is);
    __slicedData = __is->endReadException(true);
}

void
Test::KnownPreserved::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::KnownPreserved", -1, false);
    __os->write(kp);
    __os->endWriteSlice();
    ::Test::Base::__writeImpl(__os);
}

void
Test::KnownPreserved::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(kp);
    __is->endReadSlice();
    ::Test::Base::__readImpl(__is);
}

namespace
{

const char* __Test__KnownPreservedDerived_name = "Test::KnownPreservedDerived";

struct __F__Test__KnownPreservedDerived : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Test::KnownPreservedDerived();
    }
};

class __F__Test__KnownPreservedDerived__Init
{
public:

    __F__Test__KnownPreservedDerived__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Test::KnownPreservedDerived", new __F__Test__KnownPreservedDerived);
    }

    ~__F__Test__KnownPreservedDerived__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Test::KnownPreservedDerived");
    }
};

const __F__Test__KnownPreservedDerived__Init __F__Test__KnownPreservedDerived__i;

}

Test::KnownPreservedDerived::KnownPreservedDerived(const ::std::string& __ice_b, const ::std::string& __ice_kp, const ::std::string& __ice_kpd) :
    ::Test::KnownPreserved(__ice_b, __ice_kp),
    kpd(__ice_kpd)
{
}

Test::KnownPreservedDerived::~KnownPreservedDerived() throw()
{
}

::std::string
Test::KnownPreservedDerived::ice_name() const
{
    return __Test__KnownPreservedDerived_name;
}

Test::KnownPreservedDerived*
Test::KnownPreservedDerived::ice_clone() const
{
    return new KnownPreservedDerived(*this);
}

void
Test::KnownPreservedDerived::ice_throw() const
{
    throw *this;
}

void
Test::KnownPreservedDerived::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Test::KnownPreservedDerived", -1, false);
    __os->write(kpd);
    __os->endWriteSlice();
    ::Test::KnownPreserved::__writeImpl(__os);
}

void
Test::KnownPreservedDerived::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(kpd);
    __is->endReadSlice();
    ::Test::KnownPreserved::__readImpl(__is);
}

namespace Ice
{
}

IceAsync::Test::AMD_TestIntf_baseAsBase::AMD_TestIntf_baseAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_baseAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_baseAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownDerivedAsBase::AMD_TestIntf_unknownDerivedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownDerivedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownDerivedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownDerivedAsBase::AMD_TestIntf_knownDerivedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownDerivedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownDerivedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownDerivedAsKnownDerived::AMD_TestIntf_knownDerivedAsKnownDerived(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownDerivedAsKnownDerived::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownDerivedAsKnownDerived::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownDerived* __ex = dynamic_cast<const ::Test::KnownDerived*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownIntermediateAsBase::AMD_TestIntf_unknownIntermediateAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownIntermediateAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownIntermediateAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownIntermediateAsBase::AMD_TestIntf_knownIntermediateAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownIntermediateAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownIntermediateAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownMostDerivedAsBase::AMD_TestIntf_knownMostDerivedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownMostDerivedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownMostDerivedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediate::AMD_TestIntf_knownIntermediateAsKnownIntermediate(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediate::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediate::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownIntermediate* __ex = dynamic_cast<const ::Test::KnownIntermediate*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediate::AMD_TestIntf_knownMostDerivedAsKnownIntermediate(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediate::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediate::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownIntermediate* __ex = dynamic_cast<const ::Test::KnownIntermediate*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerived::AMD_TestIntf_knownMostDerivedAsKnownMostDerived(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerived::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerived::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownMostDerived* __ex = dynamic_cast<const ::Test::KnownMostDerived*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsBase::AMD_TestIntf_unknownMostDerived1AsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediate::AMD_TestIntf_unknownMostDerived1AsKnownIntermediate(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediate::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediate::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownIntermediate* __ex = dynamic_cast<const ::Test::KnownIntermediate*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBase::AMD_TestIntf_unknownMostDerived2AsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompact::AMD_TestIntf_unknownMostDerived2AsBaseCompact(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompact::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompact::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::CompactFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownPreservedAsBase::AMD_TestIntf_knownPreservedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownPreservedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownPreservedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_knownPreservedAsKnownPreserved::AMD_TestIntf_knownPreservedAsKnownPreserved(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_knownPreservedAsKnownPreserved::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_knownPreservedAsKnownPreserved::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownPreserved* __ex = dynamic_cast<const ::Test::KnownPreserved*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsBase::AMD_TestIntf_relayKnownPreservedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreserved::AMD_TestIntf_relayKnownPreservedAsKnownPreserved(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreserved::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreserved::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownPreserved* __ex = dynamic_cast<const ::Test::KnownPreserved*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownPreservedAsBase::AMD_TestIntf_unknownPreservedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownPreservedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownPreservedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_unknownPreservedAsKnownPreserved::AMD_TestIntf_unknownPreservedAsKnownPreserved(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_unknownPreservedAsKnownPreserved::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_unknownPreservedAsKnownPreserved::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownPreserved* __ex = dynamic_cast<const ::Test::KnownPreserved*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsBase::AMD_TestIntf_relayUnknownPreservedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsBase::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsBase::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::Base* __ex = dynamic_cast<const ::Test::Base*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreserved::AMD_TestIntf_relayUnknownPreservedAsKnownPreserved(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreserved::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreserved::ice_exception(const ::std::exception& ex)
{
    if(const ::Test::KnownPreserved* __ex = dynamic_cast<const ::Test::KnownPreserved*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::SlicedFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Test::AMD_TestIntf_shutdown::AMD_TestIntf_shutdown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_shutdown::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::BaseClass* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseClass>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::BaseClass;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Test::BaseClass::ice_staticId()
{
    return ::Test::BaseClass::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::BaseClass::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::BaseClass);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::BaseClass::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::BaseClass);
}

::IceProxy::Ice::Object*
IceProxy::Test::BaseClass::__newInstance() const
{
    return new BaseClass;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::Relay* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::Relay>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::Relay;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::Relay::knownPreservedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Relay__knownPreservedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Relay__knownPreservedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Relay* __del = dynamic_cast< ::IceDelegate::Test::Relay*>(__delBase.get());
            __del->knownPreservedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Relay::begin_knownPreservedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Relay__knownPreservedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Relay__knownPreservedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Relay__knownPreservedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Relay::end_knownPreservedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Relay__knownPreservedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::Relay::knownPreservedAsKnownPreserved(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Relay__knownPreservedAsKnownPreserved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Relay__knownPreservedAsKnownPreserved_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Relay* __del = dynamic_cast< ::IceDelegate::Test::Relay*>(__delBase.get());
            __del->knownPreservedAsKnownPreserved(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Relay__knownPreservedAsKnownPreserved_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Relay__knownPreservedAsKnownPreserved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Relay__knownPreservedAsKnownPreserved_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Relay::end_knownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Relay__knownPreservedAsKnownPreserved_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::Relay::unknownPreservedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Relay__unknownPreservedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Relay__unknownPreservedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Relay* __del = dynamic_cast< ::IceDelegate::Test::Relay*>(__delBase.get());
            __del->unknownPreservedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Relay::begin_unknownPreservedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Relay__unknownPreservedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Relay__unknownPreservedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Relay__unknownPreservedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Relay::end_unknownPreservedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Relay__unknownPreservedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::Relay::unknownPreservedAsKnownPreserved(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__Relay__unknownPreservedAsKnownPreserved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__Relay__unknownPreservedAsKnownPreserved_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::Relay* __del = dynamic_cast< ::IceDelegate::Test::Relay*>(__delBase.get());
            __del->unknownPreservedAsKnownPreserved(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__Relay__unknownPreservedAsKnownPreserved_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__Relay__unknownPreservedAsKnownPreserved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__Relay__unknownPreservedAsKnownPreserved_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::Relay::end_unknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__Relay__unknownPreservedAsKnownPreserved_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Test::Relay::ice_staticId()
{
    return ::Test::Relay::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::Relay::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::Relay);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::Relay::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::Relay);
}

::IceProxy::Ice::Object*
IceProxy::Test::Relay::__newInstance() const
{
    return new Relay;
}
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(::IceProxy::Test::TestIntf* p) { return p; }

void
::IceProxy::Test::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Test::TestIntf;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Test::TestIntf::baseAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__baseAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__baseAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->baseAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_baseAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__baseAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__baseAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__baseAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_baseAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__baseAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownDerivedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownDerivedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownDerivedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownDerivedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownDerivedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownDerivedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownDerivedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownDerivedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownDerivedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownDerivedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownDerivedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownDerivedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownDerivedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownDerivedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownDerivedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownDerivedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownDerivedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownDerivedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownDerivedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownDerivedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownDerivedAsKnownDerived(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownDerivedAsKnownDerived_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownDerivedAsKnownDerived_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownDerivedAsKnownDerived(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownDerivedAsKnownDerived_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownDerivedAsKnownDerived_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownDerivedAsKnownDerived_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownDerivedAsKnownDerived(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownDerivedAsKnownDerived_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownDerived&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownIntermediateAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownIntermediateAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownIntermediateAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownIntermediateAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownIntermediateAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownIntermediateAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownIntermediateAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownIntermediateAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownIntermediateAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownIntermediateAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownIntermediateAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownIntermediateAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownIntermediateAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownIntermediateAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownIntermediateAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownIntermediateAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownIntermediateAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownIntermediateAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownIntermediateAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownMostDerivedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownMostDerivedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownMostDerivedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownMostDerivedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownMostDerivedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownMostDerivedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownMostDerivedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownMostDerivedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownMostDerivedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownIntermediateAsKnownIntermediate(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownIntermediateAsKnownIntermediate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownIntermediateAsKnownIntermediate_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownIntermediateAsKnownIntermediate(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownIntermediateAsKnownIntermediate_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownIntermediateAsKnownIntermediate_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownIntermediateAsKnownIntermediate_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownIntermediateAsKnownIntermediate(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownIntermediateAsKnownIntermediate_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownMostDerivedAsKnownIntermediate(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownMostDerivedAsKnownIntermediate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownMostDerivedAsKnownIntermediate_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownMostDerivedAsKnownIntermediate(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownMostDerivedAsKnownIntermediate_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownMostDerivedAsKnownIntermediate_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownMostDerivedAsKnownIntermediate_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownMostDerivedAsKnownIntermediate(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownMostDerivedAsKnownIntermediate_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownMostDerivedAsKnownMostDerived(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownMostDerivedAsKnownMostDerived_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownMostDerivedAsKnownMostDerived_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownMostDerivedAsKnownMostDerived(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownMostDerivedAsKnownMostDerived_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownMostDerivedAsKnownMostDerived_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownMostDerivedAsKnownMostDerived_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownMostDerivedAsKnownMostDerived(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownMostDerivedAsKnownMostDerived_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownMostDerived&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownMostDerived1AsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownMostDerived1AsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownMostDerived1AsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownMostDerived1AsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownMostDerived1AsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownMostDerived1AsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownMostDerived1AsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived1AsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownMostDerived1AsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownMostDerived1AsKnownIntermediate(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownMostDerived1AsKnownIntermediate(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived1AsKnownIntermediate(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownMostDerived2AsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownMostDerived2AsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownMostDerived2AsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownMostDerived2AsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownMostDerived2AsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownMostDerived2AsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownMostDerived2AsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived2AsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownMostDerived2AsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownMostDerived2AsBaseCompact(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownMostDerived2AsBaseCompact_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownMostDerived2AsBaseCompact_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownMostDerived2AsBaseCompact(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownMostDerived2AsBaseCompact_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownMostDerived2AsBaseCompact_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownMostDerived2AsBaseCompact_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived2AsBaseCompact(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownMostDerived2AsBaseCompact_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownPreservedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownPreservedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownPreservedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownPreservedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownPreservedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownPreservedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownPreservedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownPreservedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownPreservedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownPreservedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::knownPreservedAsKnownPreserved(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__knownPreservedAsKnownPreserved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__knownPreservedAsKnownPreserved_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->knownPreservedAsKnownPreserved(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__knownPreservedAsKnownPreserved_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__knownPreservedAsKnownPreserved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__knownPreservedAsKnownPreserved_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_knownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__knownPreservedAsKnownPreserved_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__relayKnownPreservedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__relayKnownPreservedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->relayKnownPreservedAsBase(r, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__relayKnownPreservedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__relayKnownPreservedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__relayKnownPreservedAsBase_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_relayKnownPreservedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__relayKnownPreservedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__relayKnownPreservedAsKnownPreserved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__relayKnownPreservedAsKnownPreserved_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->relayKnownPreservedAsKnownPreserved(r, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__relayKnownPreservedAsKnownPreserved_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__relayKnownPreservedAsKnownPreserved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__relayKnownPreservedAsKnownPreserved_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_relayKnownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__relayKnownPreservedAsKnownPreserved_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownPreservedAsBase(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownPreservedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownPreservedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownPreservedAsBase(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownPreservedAsBase(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownPreservedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownPreservedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownPreservedAsBase_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownPreservedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownPreservedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::unknownPreservedAsKnownPreserved(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__unknownPreservedAsKnownPreserved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__unknownPreservedAsKnownPreserved_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->unknownPreservedAsKnownPreserved(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__unknownPreservedAsKnownPreserved_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__unknownPreservedAsKnownPreserved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__unknownPreservedAsKnownPreserved_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_unknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__unknownPreservedAsKnownPreserved_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__relayUnknownPreservedAsBase_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__relayUnknownPreservedAsBase_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->relayUnknownPreservedAsBase(r, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__relayUnknownPreservedAsBase_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__relayUnknownPreservedAsBase_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__relayUnknownPreservedAsBase_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_relayUnknownPreservedAsBase(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__relayUnknownPreservedAsBase_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->relayUnknownPreservedAsKnownPreserved(r, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_relayUnknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Test::TestIntf::shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Test__TestIntf__shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Test::TestIntf* __del = dynamic_cast< ::IceDelegate::Test::TestIntf*>(__delBase.get());
            __del->shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::begin_shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Test__TestIntf__shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__Test__TestIntf__shutdown_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Test__TestIntf__shutdown_name);
}

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Test::TestIntf);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Test::TestIntf::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Test::TestIntf);
}

::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::__newInstance() const
{
    return new TestIntf;
}

void
IceDelegateM::Test::Relay::knownPreservedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Relay__knownPreservedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Relay::knownPreservedAsKnownPreserved(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Relay__knownPreservedAsKnownPreserved_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Relay::unknownPreservedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Relay__unknownPreservedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::Relay::unknownPreservedAsKnownPreserved(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__Relay__unknownPreservedAsKnownPreserved_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::baseAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__baseAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownDerivedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownDerivedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownDerivedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownDerivedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownDerivedAsKnownDerived(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownDerivedAsKnownDerived_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownDerived&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownIntermediateAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownIntermediateAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownIntermediateAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownIntermediateAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownMostDerivedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownMostDerivedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownIntermediateAsKnownIntermediate(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownIntermediateAsKnownIntermediate_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownMostDerivedAsKnownIntermediate(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownMostDerivedAsKnownIntermediate_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownMostDerivedAsKnownMostDerived(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownMostDerivedAsKnownMostDerived_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownMostDerived&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownMostDerived1AsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownMostDerived1AsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownMostDerived1AsKnownIntermediate(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownMostDerived1AsKnownIntermediate_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownMostDerived2AsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownMostDerived2AsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownMostDerived2AsBaseCompact(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownMostDerived2AsBaseCompact_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownPreservedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownPreservedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::knownPreservedAsKnownPreserved(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__knownPreservedAsKnownPreserved_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__relayKnownPreservedAsBase_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__relayKnownPreservedAsKnownPreserved_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownPreservedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownPreservedAsBase_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::unknownPreservedAsKnownPreserved(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__unknownPreservedAsKnownPreserved_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__relayUnknownPreservedAsBase_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__relayUnknownPreservedAsKnownPreserved_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(r);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Test::KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Test::TestIntf::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Test__TestIntf__shutdown_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateD::Test::Relay::knownPreservedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Relay* servant = dynamic_cast< ::Test::Relay*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->knownPreservedAsBase(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Relay__knownPreservedAsBase_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Base&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Relay::knownPreservedAsKnownPreserved(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Relay* servant = dynamic_cast< ::Test::Relay*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->knownPreservedAsKnownPreserved(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Relay__knownPreservedAsKnownPreserved_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::KnownPreserved&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Relay::unknownPreservedAsBase(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Relay* servant = dynamic_cast< ::Test::Relay*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->unknownPreservedAsBase(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Relay__unknownPreservedAsBase_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::Base&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::Relay::unknownPreservedAsKnownPreserved(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Test::Relay* servant = dynamic_cast< ::Test::Relay*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->unknownPreservedAsKnownPreserved(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Test__Relay__unknownPreservedAsKnownPreserved_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Test::KnownPreserved&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Test::TestIntf::baseAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownDerivedAsKnownDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownIntermediateAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownIntermediateAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownMostDerivedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownIntermediateAsKnownIntermediate(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownMostDerivedAsKnownIntermediate(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownMostDerivedAsKnownMostDerived(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownMostDerived1AsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownMostDerived1AsKnownIntermediate(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownMostDerived2AsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownMostDerived2AsBaseCompact(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownPreservedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::knownPreservedAsKnownPreserved(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::relayKnownPreservedAsBase(const ::Test::RelayPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownPreservedAsBase(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::unknownPreservedAsKnownPreserved(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::relayUnknownPreservedAsBase(const ::Test::RelayPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Test::TestIntf::shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Object* Test::upCast(::Test::BaseClass* p) { return p; }
::Ice::ObjectPtr
Test::BaseClass::ice_clone() const
{
    ::Ice::Object* __p = new BaseClass(*this);
    return __p;
}

namespace
{
const ::std::string __Test__BaseClass_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseClass"
};

}

bool
Test::BaseClass::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__BaseClass_ids, __Test__BaseClass_ids + 2, _s);
}

::std::vector< ::std::string>
Test::BaseClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__BaseClass_ids[0], &__Test__BaseClass_ids[2]);
}

const ::std::string&
Test::BaseClass::ice_id(const ::Ice::Current&) const
{
    return __Test__BaseClass_ids[1];
}

const ::std::string&
Test::BaseClass::ice_staticId()
{
    return __Test__BaseClass_ids[1];
}

void
Test::BaseClass::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Test::BaseClass::__usesGC()
{
    return true;
}

void
Test::BaseClass::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(__slicedData)
    {
        __slicedData->__addObject(_c);
    }
}

void
Test::BaseClass::__gcClear()
{
    if(__slicedData)
    {
        __slicedData->__decRefUnsafe();
        __slicedData.__clearHandleUnsafe();
    }
}

void
Test::BaseClass::__write(::IceInternal::BasicStream* __os) const
{
    __os->startWriteObject(__slicedData);
    __writeImpl(__os);
    __os->endWriteObject();
}

void
Test::BaseClass::__read(::IceInternal::BasicStream* __is)
{
    __is->startReadObject();
    __readImpl(__is);
    __slicedData = __is->endReadObject(true);
}

void
Test::BaseClass::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(bc);
    __os->endWriteSlice();
}

void
Test::BaseClass::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(bc);
    __is->endReadSlice();
}

namespace
{

class __F__Test__BaseClass : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Test::BaseClass::ice_staticId());
        return new ::Test::BaseClass;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Test__BaseClass_Ptr = new __F__Test__BaseClass;

class __F__Test__BaseClass__Init
{
public:

    __F__Test__BaseClass__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Test::BaseClass::ice_staticId(), __F__Test__BaseClass_Ptr);
    }

    ~__F__Test__BaseClass__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Test::BaseClass::ice_staticId());
    }
};

const __F__Test__BaseClass__Init __F__Test__BaseClass__i;

}

const ::Ice::ObjectFactoryPtr&
Test::BaseClass::ice_factory()
{
    return __F__Test__BaseClass_Ptr;
}

void 
Test::__patch(BaseClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::BaseClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::BaseClass::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::Relay* p) { return p; }

namespace
{
const ::std::string __Test__Relay_ids[2] =
{
    "::Ice::Object",
    "::Test::Relay"
};

}

bool
Test::Relay::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__Relay_ids, __Test__Relay_ids + 2, _s);
}

::std::vector< ::std::string>
Test::Relay::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__Relay_ids[0], &__Test__Relay_ids[2]);
}

const ::std::string&
Test::Relay::ice_id(const ::Ice::Current&) const
{
    return __Test__Relay_ids[1];
}

const ::std::string&
Test::Relay::ice_staticId()
{
    return __Test__Relay_ids[1];
}

::Ice::DispatchStatus
Test::Relay::___knownPreservedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        knownPreservedAsBase(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Base& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Test::Relay::___knownPreservedAsKnownPreserved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        knownPreservedAsKnownPreserved(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::KnownPreserved& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Test::Relay::___unknownPreservedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        unknownPreservedAsBase(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::Base& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Test::Relay::___unknownPreservedAsKnownPreserved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        unknownPreservedAsKnownPreserved(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Test::KnownPreserved& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Test__Relay_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "knownPreservedAsBase",
    "knownPreservedAsKnownPreserved",
    "unknownPreservedAsBase",
    "unknownPreservedAsKnownPreserved"
};

}

::Ice::DispatchStatus
Test::Relay::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__Relay_all, __Test__Relay_all + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__Relay_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___knownPreservedAsBase(in, current);
        }
        case 5:
        {
            return ___knownPreservedAsKnownPreserved(in, current);
        }
        case 6:
        {
            return ___unknownPreservedAsBase(in, current);
        }
        case 7:
        {
            return ___unknownPreservedAsKnownPreserved(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::Relay::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::Relay::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(RelayPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::RelayPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::Relay::ice_staticId(), v);
    }
}

::Ice::Object* Test::upCast(::Test::TestIntf* p) { return p; }

namespace
{
const ::std::string __Test__TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Test__TestIntf_ids, __Test__TestIntf_ids + 2, _s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Test__TestIntf_ids[0], &__Test__TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return __Test__TestIntf_ids[1];
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    return __Test__TestIntf_ids[1];
}

::Ice::DispatchStatus
Test::TestIntf::___baseAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_baseAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_baseAsBase(__inS);
    try
    {
        baseAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownDerivedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownDerivedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_unknownDerivedAsBase(__inS);
    try
    {
        unknownDerivedAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownDerivedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownDerivedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_knownDerivedAsBase(__inS);
    try
    {
        knownDerivedAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownDerivedAsKnownDerived(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownDerivedAsKnownDerivedPtr __cb = new IceAsync::Test::AMD_TestIntf_knownDerivedAsKnownDerived(__inS);
    try
    {
        knownDerivedAsKnownDerived_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownIntermediateAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownIntermediateAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_unknownIntermediateAsBase(__inS);
    try
    {
        unknownIntermediateAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownIntermediateAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownIntermediateAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_knownIntermediateAsBase(__inS);
    try
    {
        knownIntermediateAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownMostDerivedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownMostDerivedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_knownMostDerivedAsBase(__inS);
    try
    {
        knownMostDerivedAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownIntermediateAsKnownIntermediate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediatePtr __cb = new IceAsync::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediate(__inS);
    try
    {
        knownIntermediateAsKnownIntermediate_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownMostDerivedAsKnownIntermediate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediatePtr __cb = new IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediate(__inS);
    try
    {
        knownMostDerivedAsKnownIntermediate_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownMostDerivedAsKnownMostDerived(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerivedPtr __cb = new IceAsync::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerived(__inS);
    try
    {
        knownMostDerivedAsKnownMostDerived_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownMostDerived1AsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownMostDerived1AsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsBase(__inS);
    try
    {
        unknownMostDerived1AsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownMostDerived1AsKnownIntermediate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediatePtr __cb = new IceAsync::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediate(__inS);
    try
    {
        unknownMostDerived1AsKnownIntermediate_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownMostDerived2AsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownMostDerived2AsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBase(__inS);
    try
    {
        unknownMostDerived2AsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownMostDerived2AsBaseCompact(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompactPtr __cb = new IceAsync::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompact(__inS);
    try
    {
        unknownMostDerived2AsBaseCompact_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownPreservedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownPreservedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_knownPreservedAsBase(__inS);
    try
    {
        knownPreservedAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___knownPreservedAsKnownPreserved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_knownPreservedAsKnownPreservedPtr __cb = new IceAsync::Test::AMD_TestIntf_knownPreservedAsKnownPreserved(__inS);
    try
    {
        knownPreservedAsKnownPreserved_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___relayKnownPreservedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::RelayPrx r;
    __is->read(r);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_relayKnownPreservedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsBase(__inS);
    try
    {
        relayKnownPreservedAsBase_async(__cb, r, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___relayKnownPreservedAsKnownPreserved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::RelayPrx r;
    __is->read(r);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreservedPtr __cb = new IceAsync::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreserved(__inS);
    try
    {
        relayKnownPreservedAsKnownPreserved_async(__cb, r, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownPreservedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownPreservedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_unknownPreservedAsBase(__inS);
    try
    {
        unknownPreservedAsBase_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___unknownPreservedAsKnownPreserved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_unknownPreservedAsKnownPreservedPtr __cb = new IceAsync::Test::AMD_TestIntf_unknownPreservedAsKnownPreserved(__inS);
    try
    {
        unknownPreservedAsKnownPreserved_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___relayUnknownPreservedAsBase(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::RelayPrx r;
    __is->read(r);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_relayUnknownPreservedAsBasePtr __cb = new IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsBase(__inS);
    try
    {
        relayUnknownPreservedAsBase_async(__cb, r, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___relayUnknownPreservedAsKnownPreserved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Test::RelayPrx r;
    __is->read(r);
    __inS.endReadParams();
    ::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreservedPtr __cb = new IceAsync::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreserved(__inS);
    try
    {
        relayUnknownPreservedAsKnownPreserved_async(__cb, r, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Test::TestIntf::___shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Test::AMD_TestIntf_shutdownPtr __cb = new IceAsync::Test::AMD_TestIntf_shutdown(__inS);
    try
    {
        shutdown_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __Test__TestIntf_all[] =
{
    "baseAsBase",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "knownDerivedAsBase",
    "knownDerivedAsKnownDerived",
    "knownIntermediateAsBase",
    "knownIntermediateAsKnownIntermediate",
    "knownMostDerivedAsBase",
    "knownMostDerivedAsKnownIntermediate",
    "knownMostDerivedAsKnownMostDerived",
    "knownPreservedAsBase",
    "knownPreservedAsKnownPreserved",
    "relayKnownPreservedAsBase",
    "relayKnownPreservedAsKnownPreserved",
    "relayUnknownPreservedAsBase",
    "relayUnknownPreservedAsKnownPreserved",
    "shutdown",
    "unknownDerivedAsBase",
    "unknownIntermediateAsBase",
    "unknownMostDerived1AsBase",
    "unknownMostDerived1AsKnownIntermediate",
    "unknownMostDerived2AsBase",
    "unknownMostDerived2AsBaseCompact",
    "unknownPreservedAsBase",
    "unknownPreservedAsKnownPreserved"
};

}

::Ice::DispatchStatus
Test::TestIntf::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Test__TestIntf_all, __Test__TestIntf_all + 27, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Test__TestIntf_all)
    {
        case 0:
        {
            return ___baseAsBase(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___knownDerivedAsBase(in, current);
        }
        case 6:
        {
            return ___knownDerivedAsKnownDerived(in, current);
        }
        case 7:
        {
            return ___knownIntermediateAsBase(in, current);
        }
        case 8:
        {
            return ___knownIntermediateAsKnownIntermediate(in, current);
        }
        case 9:
        {
            return ___knownMostDerivedAsBase(in, current);
        }
        case 10:
        {
            return ___knownMostDerivedAsKnownIntermediate(in, current);
        }
        case 11:
        {
            return ___knownMostDerivedAsKnownMostDerived(in, current);
        }
        case 12:
        {
            return ___knownPreservedAsBase(in, current);
        }
        case 13:
        {
            return ___knownPreservedAsKnownPreserved(in, current);
        }
        case 14:
        {
            return ___relayKnownPreservedAsBase(in, current);
        }
        case 15:
        {
            return ___relayKnownPreservedAsKnownPreserved(in, current);
        }
        case 16:
        {
            return ___relayUnknownPreservedAsBase(in, current);
        }
        case 17:
        {
            return ___relayUnknownPreservedAsKnownPreserved(in, current);
        }
        case 18:
        {
            return ___shutdown(in, current);
        }
        case 19:
        {
            return ___unknownDerivedAsBase(in, current);
        }
        case 20:
        {
            return ___unknownIntermediateAsBase(in, current);
        }
        case 21:
        {
            return ___unknownMostDerived1AsBase(in, current);
        }
        case 22:
        {
            return ___unknownMostDerived1AsKnownIntermediate(in, current);
        }
        case 23:
        {
            return ___unknownMostDerived2AsBase(in, current);
        }
        case 24:
        {
            return ___unknownMostDerived2AsBaseCompact(in, current);
        }
        case 25:
        {
            return ___unknownPreservedAsBase(in, current);
        }
        case 26:
        {
            return ___unknownPreservedAsKnownPreserved(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Test::TestIntf::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Test::TestIntf::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Test::__patch(TestIntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Test::TestIntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Test::TestIntf::ice_staticId(), v);
    }
}
