// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

namespace MA
{

class IA;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::IA>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MA::IA*);

class CA;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::CA>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MA::CA*);

}

namespace MB
{

class IB1;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MB::IB1>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MB::IB1*);

class IB2;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MB::IB2>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MB::IB2*);

class CB;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MB::CB>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MB::CB*);

}

namespace MA
{

class IC;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::IC>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MA::IC*);

class CC;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::CC>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MA::CC*);

class CD;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::CD>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MA::CD*);

}

class Initial;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Initial>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Initial*);

namespace MC
{

class A;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::A>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MC::A*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MC::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MC::C*);

class D;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::D>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MC::D*);

}

namespace MD
{

class A;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::A>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MD::A*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MD::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MD::C*);

class D;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::D>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MD::D*);

}

namespace ME
{

class A;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::A>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::ME::A*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::ME::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::ME::C*);

class D;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::D>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::ME::D*);

}

namespace MF
{

class A;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::A>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MF::A*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MF::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MF::C*);

class D;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::D>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MF::D*);

}

namespace MG
{

class A;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::A>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MG::A*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MG::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MG::C*);

class D;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::D>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MG::D*);

}

namespace MH
{

class A;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::A>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MH::A*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MH::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MH::C*);

class D;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::D>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MH::D*);

}

}

}

namespace Test
{

namespace MA
{

class IA;
bool operator==(const IA&, const IA&);
bool operator<(const IA&, const IA&);
::Ice::Object* upCast(::Test::MA::IA*);
typedef ::IceInternal::Handle< ::Test::MA::IA> IAPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::IA> IAPrx;
void __patch(IAPtr&, const ::Ice::ObjectPtr&);

class CA;
bool operator==(const CA&, const CA&);
bool operator<(const CA&, const CA&);
::Ice::Object* upCast(::Test::MA::CA*);
typedef ::IceInternal::Handle< ::Test::MA::CA> CAPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::CA> CAPrx;
void __patch(CAPtr&, const ::Ice::ObjectPtr&);

}

namespace MB
{

class IB1;
bool operator==(const IB1&, const IB1&);
bool operator<(const IB1&, const IB1&);
::Ice::Object* upCast(::Test::MB::IB1*);
typedef ::IceInternal::Handle< ::Test::MB::IB1> IB1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MB::IB1> IB1Prx;
void __patch(IB1Ptr&, const ::Ice::ObjectPtr&);

class IB2;
bool operator==(const IB2&, const IB2&);
bool operator<(const IB2&, const IB2&);
::Ice::Object* upCast(::Test::MB::IB2*);
typedef ::IceInternal::Handle< ::Test::MB::IB2> IB2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MB::IB2> IB2Prx;
void __patch(IB2Ptr&, const ::Ice::ObjectPtr&);

class CB;
bool operator==(const CB&, const CB&);
bool operator<(const CB&, const CB&);
::Ice::Object* upCast(::Test::MB::CB*);
typedef ::IceInternal::Handle< ::Test::MB::CB> CBPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MB::CB> CBPrx;
void __patch(CBPtr&, const ::Ice::ObjectPtr&);

}

namespace MA
{

class IC;
bool operator==(const IC&, const IC&);
bool operator<(const IC&, const IC&);
::Ice::Object* upCast(::Test::MA::IC*);
typedef ::IceInternal::Handle< ::Test::MA::IC> ICPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::IC> ICPrx;
void __patch(ICPtr&, const ::Ice::ObjectPtr&);

class CC;
bool operator==(const CC&, const CC&);
bool operator<(const CC&, const CC&);
::Ice::Object* upCast(::Test::MA::CC*);
typedef ::IceInternal::Handle< ::Test::MA::CC> CCPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::CC> CCPrx;
void __patch(CCPtr&, const ::Ice::ObjectPtr&);

class CD;
bool operator==(const CD&, const CD&);
bool operator<(const CD&, const CD&);
::Ice::Object* upCast(::Test::MA::CD*);
typedef ::IceInternal::Handle< ::Test::MA::CD> CDPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MA::CD> CDPrx;
void __patch(CDPtr&, const ::Ice::ObjectPtr&);

}

class Initial;
bool operator==(const Initial&, const Initial&);
bool operator<(const Initial&, const Initial&);
::Ice::Object* upCast(::Test::Initial*);
typedef ::IceInternal::Handle< ::Test::Initial> InitialPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Initial> InitialPrx;
void __patch(InitialPtr&, const ::Ice::ObjectPtr&);

namespace MC
{

class A;
bool operator==(const A&, const A&);
bool operator<(const A&, const A&);
::Ice::Object* upCast(::Test::MC::A*);
typedef ::IceInternal::Handle< ::Test::MC::A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::A> APrx;
void __patch(APtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::MC::B*);
typedef ::IceInternal::Handle< ::Test::MC::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::MC::C*);
typedef ::IceInternal::Handle< ::Test::MC::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class D;
bool operator==(const D&, const D&);
bool operator<(const D&, const D&);
::Ice::Object* upCast(::Test::MC::D*);
typedef ::IceInternal::Handle< ::Test::MC::D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MC::D> DPrx;
void __patch(DPtr&, const ::Ice::ObjectPtr&);

}

namespace MD
{

class A;
bool operator==(const A&, const A&);
bool operator<(const A&, const A&);
::Ice::Object* upCast(::Test::MD::A*);
typedef ::IceInternal::Handle< ::Test::MD::A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::A> APrx;
void __patch(APtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::MD::B*);
typedef ::IceInternal::Handle< ::Test::MD::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::MD::C*);
typedef ::IceInternal::Handle< ::Test::MD::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class D;
bool operator==(const D&, const D&);
bool operator<(const D&, const D&);
::Ice::Object* upCast(::Test::MD::D*);
typedef ::IceInternal::Handle< ::Test::MD::D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MD::D> DPrx;
void __patch(DPtr&, const ::Ice::ObjectPtr&);

}

namespace ME
{

class A;
bool operator==(const A&, const A&);
bool operator<(const A&, const A&);
::Ice::Object* upCast(::Test::ME::A*);
typedef ::IceInternal::Handle< ::Test::ME::A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::A> APrx;
void __patch(APtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::ME::B*);
typedef ::IceInternal::Handle< ::Test::ME::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::ME::C*);
typedef ::IceInternal::Handle< ::Test::ME::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class D;
bool operator==(const D&, const D&);
bool operator<(const D&, const D&);
::Ice::Object* upCast(::Test::ME::D*);
typedef ::IceInternal::Handle< ::Test::ME::D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::ME::D> DPrx;
void __patch(DPtr&, const ::Ice::ObjectPtr&);

}

namespace MF
{

class A;
bool operator==(const A&, const A&);
bool operator<(const A&, const A&);
::Ice::Object* upCast(::Test::MF::A*);
typedef ::IceInternal::Handle< ::Test::MF::A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::A> APrx;
void __patch(APtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::MF::B*);
typedef ::IceInternal::Handle< ::Test::MF::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::MF::C*);
typedef ::IceInternal::Handle< ::Test::MF::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class D;
bool operator==(const D&, const D&);
bool operator<(const D&, const D&);
::Ice::Object* upCast(::Test::MF::D*);
typedef ::IceInternal::Handle< ::Test::MF::D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MF::D> DPrx;
void __patch(DPtr&, const ::Ice::ObjectPtr&);

}

namespace MG
{

class A;
bool operator==(const A&, const A&);
bool operator<(const A&, const A&);
::Ice::Object* upCast(::Test::MG::A*);
typedef ::IceInternal::Handle< ::Test::MG::A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::A> APrx;
void __patch(APtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::MG::B*);
typedef ::IceInternal::Handle< ::Test::MG::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::MG::C*);
typedef ::IceInternal::Handle< ::Test::MG::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class D;
bool operator==(const D&, const D&);
bool operator<(const D&, const D&);
::Ice::Object* upCast(::Test::MG::D*);
typedef ::IceInternal::Handle< ::Test::MG::D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MG::D> DPrx;
void __patch(DPtr&, const ::Ice::ObjectPtr&);

}

namespace MH
{

class A;
bool operator==(const A&, const A&);
bool operator<(const A&, const A&);
::Ice::Object* upCast(::Test::MH::A*);
typedef ::IceInternal::Handle< ::Test::MH::A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::A> APrx;
void __patch(APtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::MH::B*);
typedef ::IceInternal::Handle< ::Test::MH::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::MH::C*);
typedef ::IceInternal::Handle< ::Test::MH::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class D;
bool operator==(const D&, const D&);
bool operator<(const D&, const D&);
::Ice::Object* upCast(::Test::MH::D*);
typedef ::IceInternal::Handle< ::Test::MH::D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MH::D> DPrx;
void __patch(DPtr&, const ::Ice::ObjectPtr&);

}

}

namespace Test
{

namespace MA
{

class Callback_IA_iaop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IA_iaop_Base> Callback_IA_iaopPtr;

class Callback_CA_caop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CA_caop_Base> Callback_CA_caopPtr;

}

namespace MB
{

class Callback_IB1_ib1op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IB1_ib1op_Base> Callback_IB1_ib1opPtr;

class Callback_IB2_ib2op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IB2_ib2op_Base> Callback_IB2_ib2opPtr;

class Callback_CB_cbop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CB_cbop_Base> Callback_CB_cbopPtr;

}

namespace MA
{

class Callback_IC_icop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IC_icop_Base> Callback_IC_icopPtr;

class Callback_CC_ccop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CC_ccop_Base> Callback_CC_ccopPtr;

class Callback_CD_cdop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CD_cdop_Base> Callback_CD_cdopPtr;

}

class Callback_Initial_shutdown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_shutdown_Base> Callback_Initial_shutdownPtr;

class Callback_Initial_caop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_caop_Base> Callback_Initial_caopPtr;

class Callback_Initial_cbop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_cbop_Base> Callback_Initial_cbopPtr;

class Callback_Initial_ccop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_ccop_Base> Callback_Initial_ccopPtr;

class Callback_Initial_cdop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_cdop_Base> Callback_Initial_cdopPtr;

class Callback_Initial_iaop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_iaop_Base> Callback_Initial_iaopPtr;

class Callback_Initial_ib1op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_ib1op_Base> Callback_Initial_ib1opPtr;

class Callback_Initial_ib2op_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_ib2op_Base> Callback_Initial_ib2opPtr;

class Callback_Initial_icop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_icop_Base> Callback_Initial_icopPtr;

namespace MC
{

}

namespace MD
{

}

namespace ME
{

}

namespace MF
{

}

namespace MG
{

}

namespace MH
{

}

}

namespace IceProxy
{

namespace Test
{

namespace MA
{

class IA : virtual public ::IceProxy::Ice::Object
{
public:

    ::Test::MA::IAPrx iaop(const ::Test::MA::IAPrx& p)
    {
        return iaop(p, 0);
    }
    ::Test::MA::IAPrx iaop(const ::Test::MA::IAPrx& p, const ::Ice::Context& __ctx)
    {
        return iaop(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_iaop(const ::Test::MA::IAPrx& p, const ::IceInternal::Function<void (const ::Test::MA::IAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_iaop(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_iaop(const ::Test::MA::IAPrx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_iaop(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_iaop(const ::Test::MA::IAPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::IAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_iaop(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_iaop(const ::Test::MA::IAPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_iaop(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_iaop(const ::Test::MA::IAPrx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::IAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::IAPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MA::IAPrx __proxy = ::Test::MA::IAPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::IAPrx __ret;
                try
                {
                    __ret = __proxy->end_iaop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::IAPrx&)> _response;
        };
        return begin_iaop(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_iaop(const ::Test::MA::IAPrx& p)
    {
        return begin_iaop(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Test::MA::IAPrx& p, const ::Ice::Context& __ctx)
    {
        return begin_iaop(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Test::MA::IAPrx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Test::MA::IAPrx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Test::MA::IAPrx& p, const ::Test::MA::Callback_IA_iaopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Test::MA::IAPrx& p, const ::Ice::Context& __ctx, const ::Test::MA::Callback_IA_iaopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(p, &__ctx, __del, __cookie);
    }

    ::Test::MA::IAPrx end_iaop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::IAPrx iaop(const ::Test::MA::IAPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_iaop(const ::Test::MA::IAPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<IA> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_secure(bool __secure) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_twoway() const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_oneway() const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_batchOneway() const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_datagram() const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_batchDatagram() const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_compress(bool __compress) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_timeout(int __timeout) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IA> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<IA*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class CA : virtual public ::IceProxy::Ice::Object
{
public:

    ::Test::MA::CAPrx caop(const ::Test::MA::CAPrx& p)
    {
        return caop(p, 0);
    }
    ::Test::MA::CAPrx caop(const ::Test::MA::CAPrx& p, const ::Ice::Context& __ctx)
    {
        return caop(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_caop(const ::Test::MA::CAPrx& p, const ::IceInternal::Function<void (const ::Test::MA::CAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_caop(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_caop(const ::Test::MA::CAPrx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_caop(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_caop(const ::Test::MA::CAPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::CAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_caop(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_caop(const ::Test::MA::CAPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_caop(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_caop(const ::Test::MA::CAPrx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::CAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::CAPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MA::CAPrx __proxy = ::Test::MA::CAPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::CAPrx __ret;
                try
                {
                    __ret = __proxy->end_caop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::CAPrx&)> _response;
        };
        return begin_caop(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_caop(const ::Test::MA::CAPrx& p)
    {
        return begin_caop(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Test::MA::CAPrx& p, const ::Ice::Context& __ctx)
    {
        return begin_caop(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Test::MA::CAPrx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Test::MA::CAPrx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Test::MA::CAPrx& p, const ::Test::MA::Callback_CA_caopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Test::MA::CAPrx& p, const ::Ice::Context& __ctx, const ::Test::MA::Callback_CA_caopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(p, &__ctx, __del, __cookie);
    }

    ::Test::MA::CAPrx end_caop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::CAPrx caop(const ::Test::MA::CAPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_caop(const ::Test::MA::CAPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<CA> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_secure(bool __secure) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_twoway() const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_oneway() const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_batchOneway() const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_datagram() const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_batchDatagram() const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_compress(bool __compress) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_timeout(int __timeout) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CA> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<CA*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace MB
{

class IB1 : virtual public ::IceProxy::Test::MA::IA
{
public:

    ::Test::MB::IB1Prx ib1op(const ::Test::MB::IB1Prx& p)
    {
        return ib1op(p, 0);
    }
    ::Test::MB::IB1Prx ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::Context& __ctx)
    {
        return ib1op(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::Test::MB::IB1Prx& p, const ::IceInternal::Function<void (const ::Test::MB::IB1Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib1op(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::Test::MB::IB1Prx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib1op(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB1Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib1op(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib1op(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB1Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MB::IB1Prx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MB::IB1Prx __proxy = ::Test::MB::IB1Prx::uncheckedCast(__result->getProxy());
                ::Test::MB::IB1Prx __ret;
                try
                {
                    __ret = __proxy->end_ib1op(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MB::IB1Prx&)> _response;
        };
        return begin_ib1op(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::MB::IB1Prx& p)
    {
        return begin_ib1op(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::Context& __ctx)
    {
        return begin_ib1op(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Test::MB::Callback_IB1_ib1opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::MB::IB1Prx& p, const ::Ice::Context& __ctx, const ::Test::MB::Callback_IB1_ib1opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(p, &__ctx, __del, __cookie);
    }

    ::Test::MB::IB1Prx end_ib1op(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MB::IB1Prx ib1op(const ::Test::MB::IB1Prx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::MB::IB1Prx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<IB1> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_secure(bool __secure) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_twoway() const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_oneway() const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_batchOneway() const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_datagram() const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_batchDatagram() const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_compress(bool __compress) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_timeout(int __timeout) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IB1> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<IB1*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class IB2 : virtual public ::IceProxy::Test::MA::IA
{
public:

    ::Test::MB::IB2Prx ib2op(const ::Test::MB::IB2Prx& p)
    {
        return ib2op(p, 0);
    }
    ::Test::MB::IB2Prx ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::Context& __ctx)
    {
        return ib2op(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::Test::MB::IB2Prx& p, const ::IceInternal::Function<void (const ::Test::MB::IB2Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib2op(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::Test::MB::IB2Prx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib2op(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB2Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib2op(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib2op(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB2Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MB::IB2Prx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MB::IB2Prx __proxy = ::Test::MB::IB2Prx::uncheckedCast(__result->getProxy());
                ::Test::MB::IB2Prx __ret;
                try
                {
                    __ret = __proxy->end_ib2op(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MB::IB2Prx&)> _response;
        };
        return begin_ib2op(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::MB::IB2Prx& p)
    {
        return begin_ib2op(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::Context& __ctx)
    {
        return begin_ib2op(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Test::MB::Callback_IB2_ib2opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::MB::IB2Prx& p, const ::Ice::Context& __ctx, const ::Test::MB::Callback_IB2_ib2opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(p, &__ctx, __del, __cookie);
    }

    ::Test::MB::IB2Prx end_ib2op(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MB::IB2Prx ib2op(const ::Test::MB::IB2Prx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::MB::IB2Prx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<IB2> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_secure(bool __secure) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_twoway() const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_oneway() const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_batchOneway() const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_datagram() const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_batchDatagram() const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_compress(bool __compress) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_timeout(int __timeout) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IB2> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<IB2*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class CB : virtual public ::IceProxy::Test::MA::CA
{
public:

    ::Test::MB::CBPrx cbop(const ::Test::MB::CBPrx& p)
    {
        return cbop(p, 0);
    }
    ::Test::MB::CBPrx cbop(const ::Test::MB::CBPrx& p, const ::Ice::Context& __ctx)
    {
        return cbop(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_cbop(const ::Test::MB::CBPrx& p, const ::IceInternal::Function<void (const ::Test::MB::CBPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cbop(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cbop(const ::Test::MB::CBPrx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cbop(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_cbop(const ::Test::MB::CBPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MB::CBPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cbop(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cbop(const ::Test::MB::CBPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cbop(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_cbop(const ::Test::MB::CBPrx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MB::CBPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MB::CBPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MB::CBPrx __proxy = ::Test::MB::CBPrx::uncheckedCast(__result->getProxy());
                ::Test::MB::CBPrx __ret;
                try
                {
                    __ret = __proxy->end_cbop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MB::CBPrx&)> _response;
        };
        return begin_cbop(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_cbop(const ::Test::MB::CBPrx& p)
    {
        return begin_cbop(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Test::MB::CBPrx& p, const ::Ice::Context& __ctx)
    {
        return begin_cbop(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Test::MB::CBPrx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Test::MB::CBPrx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Test::MB::CBPrx& p, const ::Test::MB::Callback_CB_cbopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Test::MB::CBPrx& p, const ::Ice::Context& __ctx, const ::Test::MB::Callback_CB_cbopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(p, &__ctx, __del, __cookie);
    }

    ::Test::MB::CBPrx end_cbop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MB::CBPrx cbop(const ::Test::MB::CBPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_cbop(const ::Test::MB::CBPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<CB> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_secure(bool __secure) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_twoway() const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_oneway() const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_batchOneway() const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_datagram() const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_batchDatagram() const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_compress(bool __compress) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_timeout(int __timeout) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CB> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<CB*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace MA
{

class IC : virtual public ::IceProxy::Test::MB::IB1,
           virtual public ::IceProxy::Test::MB::IB2
{
public:

    ::Test::MA::ICPrx icop(const ::Test::MA::ICPrx& p)
    {
        return icop(p, 0);
    }
    ::Test::MA::ICPrx icop(const ::Test::MA::ICPrx& p, const ::Ice::Context& __ctx)
    {
        return icop(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_icop(const ::Test::MA::ICPrx& p, const ::IceInternal::Function<void (const ::Test::MA::ICPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_icop(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_icop(const ::Test::MA::ICPrx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_icop(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_icop(const ::Test::MA::ICPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::ICPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_icop(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_icop(const ::Test::MA::ICPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_icop(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_icop(const ::Test::MA::ICPrx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::ICPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::ICPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MA::ICPrx __proxy = ::Test::MA::ICPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::ICPrx __ret;
                try
                {
                    __ret = __proxy->end_icop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::ICPrx&)> _response;
        };
        return begin_icop(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_icop(const ::Test::MA::ICPrx& p)
    {
        return begin_icop(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Test::MA::ICPrx& p, const ::Ice::Context& __ctx)
    {
        return begin_icop(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Test::MA::ICPrx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Test::MA::ICPrx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Test::MA::ICPrx& p, const ::Test::MA::Callback_IC_icopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Test::MA::ICPrx& p, const ::Ice::Context& __ctx, const ::Test::MA::Callback_IC_icopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(p, &__ctx, __del, __cookie);
    }

    ::Test::MA::ICPrx end_icop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::ICPrx icop(const ::Test::MA::ICPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_icop(const ::Test::MA::ICPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<IC> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_secure(bool __secure) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_twoway() const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_oneway() const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_batchOneway() const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_datagram() const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_batchDatagram() const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_compress(bool __compress) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_timeout(int __timeout) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IC> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<IC*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class CC : virtual public ::IceProxy::Test::MB::CB
{
public:

    ::Test::MA::CCPrx ccop(const ::Test::MA::CCPrx& p)
    {
        return ccop(p, 0);
    }
    ::Test::MA::CCPrx ccop(const ::Test::MA::CCPrx& p, const ::Ice::Context& __ctx)
    {
        return ccop(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ccop(const ::Test::MA::CCPrx& p, const ::IceInternal::Function<void (const ::Test::MA::CCPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ccop(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ccop(const ::Test::MA::CCPrx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ccop(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ccop(const ::Test::MA::CCPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::CCPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ccop(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ccop(const ::Test::MA::CCPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ccop(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ccop(const ::Test::MA::CCPrx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::CCPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::CCPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MA::CCPrx __proxy = ::Test::MA::CCPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::CCPrx __ret;
                try
                {
                    __ret = __proxy->end_ccop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::CCPrx&)> _response;
        };
        return begin_ccop(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ccop(const ::Test::MA::CCPrx& p)
    {
        return begin_ccop(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Test::MA::CCPrx& p, const ::Ice::Context& __ctx)
    {
        return begin_ccop(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Test::MA::CCPrx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Test::MA::CCPrx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Test::MA::CCPrx& p, const ::Test::MA::Callback_CC_ccopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Test::MA::CCPrx& p, const ::Ice::Context& __ctx, const ::Test::MA::Callback_CC_ccopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(p, &__ctx, __del, __cookie);
    }

    ::Test::MA::CCPrx end_ccop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::CCPrx ccop(const ::Test::MA::CCPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ccop(const ::Test::MA::CCPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<CC> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_secure(bool __secure) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_twoway() const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_oneway() const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_batchOneway() const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_datagram() const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_batchDatagram() const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_compress(bool __compress) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_timeout(int __timeout) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CC> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<CC*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class CD : virtual public ::IceProxy::Test::MA::CC,
           virtual public ::IceProxy::Test::MB::IB1,
           virtual public ::IceProxy::Test::MB::IB2
{
public:

    ::Test::MA::CDPrx cdop(const ::Test::MA::CDPrx& p)
    {
        return cdop(p, 0);
    }
    ::Test::MA::CDPrx cdop(const ::Test::MA::CDPrx& p, const ::Ice::Context& __ctx)
    {
        return cdop(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_cdop(const ::Test::MA::CDPrx& p, const ::IceInternal::Function<void (const ::Test::MA::CDPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cdop(p, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cdop(const ::Test::MA::CDPrx& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cdop(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_cdop(const ::Test::MA::CDPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::CDPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cdop(p, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cdop(const ::Test::MA::CDPrx& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cdop(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_cdop(const ::Test::MA::CDPrx& p, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::CDPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::CDPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::MA::CDPrx __proxy = ::Test::MA::CDPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::CDPrx __ret;
                try
                {
                    __ret = __proxy->end_cdop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::CDPrx&)> _response;
        };
        return begin_cdop(p, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_cdop(const ::Test::MA::CDPrx& p)
    {
        return begin_cdop(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Test::MA::CDPrx& p, const ::Ice::Context& __ctx)
    {
        return begin_cdop(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Test::MA::CDPrx& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Test::MA::CDPrx& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Test::MA::CDPrx& p, const ::Test::MA::Callback_CD_cdopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Test::MA::CDPrx& p, const ::Ice::Context& __ctx, const ::Test::MA::Callback_CD_cdopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(p, &__ctx, __del, __cookie);
    }

    ::Test::MA::CDPrx end_cdop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::CDPrx cdop(const ::Test::MA::CDPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_cdop(const ::Test::MA::CDPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<CD> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_secure(bool __secure) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_twoway() const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_oneway() const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_batchOneway() const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_datagram() const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_batchDatagram() const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_compress(bool __compress) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_timeout(int __timeout) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CD> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<CD*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

class Initial : virtual public ::IceProxy::Ice::Object
{
public:

    void shutdown()
    {
        shutdown(0);
    }
    void shutdown(const ::Ice::Context& __ctx)
    {
        shutdown(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_shutdown()
    {
        return begin_shutdown(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx)
    {
        return begin_shutdown(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_Initial_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);
    
private:

    void shutdown(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MA::CAPrx caop()
    {
        return caop(0);
    }
    ::Test::MA::CAPrx caop(const ::Ice::Context& __ctx)
    {
        return caop(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_caop(const ::IceInternal::Function<void (const ::Test::MA::CAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_caop(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_caop(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_caop(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_caop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::CAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_caop(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_caop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_caop(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_caop(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::CAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::CAPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::CAPrx __ret;
                try
                {
                    __ret = __proxy->end_caop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::CAPrx&)> _response;
        };
        return begin_caop(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_caop()
    {
        return begin_caop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Ice::Context& __ctx)
    {
        return begin_caop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Test::Callback_Initial_caopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_caop(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_caopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_caop(&__ctx, __del, __cookie);
    }

    ::Test::MA::CAPrx end_caop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::CAPrx caop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_caop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MB::CBPrx cbop()
    {
        return cbop(0);
    }
    ::Test::MB::CBPrx cbop(const ::Ice::Context& __ctx)
    {
        return cbop(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_cbop(const ::IceInternal::Function<void (const ::Test::MB::CBPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cbop(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cbop(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cbop(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_cbop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MB::CBPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cbop(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cbop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cbop(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_cbop(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MB::CBPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MB::CBPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MB::CBPrx __ret;
                try
                {
                    __ret = __proxy->end_cbop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MB::CBPrx&)> _response;
        };
        return begin_cbop(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_cbop()
    {
        return begin_cbop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Ice::Context& __ctx)
    {
        return begin_cbop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Test::Callback_Initial_cbopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cbop(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_cbopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cbop(&__ctx, __del, __cookie);
    }

    ::Test::MB::CBPrx end_cbop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MB::CBPrx cbop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_cbop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MA::CCPrx ccop()
    {
        return ccop(0);
    }
    ::Test::MA::CCPrx ccop(const ::Ice::Context& __ctx)
    {
        return ccop(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ccop(const ::IceInternal::Function<void (const ::Test::MA::CCPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ccop(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ccop(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ccop(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ccop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::CCPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ccop(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ccop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ccop(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ccop(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::CCPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::CCPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::CCPrx __ret;
                try
                {
                    __ret = __proxy->end_ccop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::CCPrx&)> _response;
        };
        return begin_ccop(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ccop()
    {
        return begin_ccop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Ice::Context& __ctx)
    {
        return begin_ccop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Test::Callback_Initial_ccopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ccop(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_ccopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ccop(&__ctx, __del, __cookie);
    }

    ::Test::MA::CCPrx end_ccop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::CCPrx ccop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ccop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MA::CDPrx cdop()
    {
        return cdop(0);
    }
    ::Test::MA::CDPrx cdop(const ::Ice::Context& __ctx)
    {
        return cdop(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_cdop(const ::IceInternal::Function<void (const ::Test::MA::CDPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cdop(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cdop(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cdop(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_cdop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::CDPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cdop(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cdop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cdop(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_cdop(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::CDPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::CDPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::CDPrx __ret;
                try
                {
                    __ret = __proxy->end_cdop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::CDPrx&)> _response;
        };
        return begin_cdop(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_cdop()
    {
        return begin_cdop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Ice::Context& __ctx)
    {
        return begin_cdop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Test::Callback_Initial_cdopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cdop(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_cdopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cdop(&__ctx, __del, __cookie);
    }

    ::Test::MA::CDPrx end_cdop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::CDPrx cdop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_cdop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MA::IAPrx iaop()
    {
        return iaop(0);
    }
    ::Test::MA::IAPrx iaop(const ::Ice::Context& __ctx)
    {
        return iaop(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_iaop(const ::IceInternal::Function<void (const ::Test::MA::IAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_iaop(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_iaop(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_iaop(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_iaop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::IAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_iaop(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_iaop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_iaop(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_iaop(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::IAPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::IAPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::IAPrx __ret;
                try
                {
                    __ret = __proxy->end_iaop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::IAPrx&)> _response;
        };
        return begin_iaop(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_iaop()
    {
        return begin_iaop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Ice::Context& __ctx)
    {
        return begin_iaop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Test::Callback_Initial_iaopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_iaop(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_iaopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_iaop(&__ctx, __del, __cookie);
    }

    ::Test::MA::IAPrx end_iaop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::IAPrx iaop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_iaop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MB::IB1Prx ib1op()
    {
        return ib1op(0);
    }
    ::Test::MB::IB1Prx ib1op(const ::Ice::Context& __ctx)
    {
        return ib1op(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::IceInternal::Function<void (const ::Test::MB::IB1Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib1op(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib1op(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB1Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib1op(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib1op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib1op(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ib1op(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB1Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MB::IB1Prx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MB::IB1Prx __ret;
                try
                {
                    __ret = __proxy->end_ib1op(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MB::IB1Prx&)> _response;
        };
        return begin_ib1op(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ib1op()
    {
        return begin_ib1op(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Ice::Context& __ctx)
    {
        return begin_ib1op(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Test::Callback_Initial_ib1opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib1op(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_ib1opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib1op(&__ctx, __del, __cookie);
    }

    ::Test::MB::IB1Prx end_ib1op(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MB::IB1Prx ib1op(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ib1op(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MB::IB2Prx ib2op()
    {
        return ib2op(0);
    }
    ::Test::MB::IB2Prx ib2op(const ::Ice::Context& __ctx)
    {
        return ib2op(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::IceInternal::Function<void (const ::Test::MB::IB2Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib2op(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib2op(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB2Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ib2op(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ib2op(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ib2op(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ib2op(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MB::IB2Prx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MB::IB2Prx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MB::IB2Prx __ret;
                try
                {
                    __ret = __proxy->end_ib2op(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MB::IB2Prx&)> _response;
        };
        return begin_ib2op(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ib2op()
    {
        return begin_ib2op(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Ice::Context& __ctx)
    {
        return begin_ib2op(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Test::Callback_Initial_ib2opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ib2op(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_ib2opPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ib2op(&__ctx, __del, __cookie);
    }

    ::Test::MB::IB2Prx end_ib2op(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MB::IB2Prx ib2op(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ib2op(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Test::MA::ICPrx icop()
    {
        return icop(0);
    }
    ::Test::MA::ICPrx icop(const ::Ice::Context& __ctx)
    {
        return icop(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_icop(const ::IceInternal::Function<void (const ::Test::MA::ICPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_icop(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_icop(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_icop(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_icop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Test::MA::ICPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_icop(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_icop(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_icop(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_icop(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Test::MA::ICPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Test::MA::ICPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
                ::Test::MA::ICPrx __ret;
                try
                {
                    __ret = __proxy->end_icop(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Test::MA::ICPrx&)> _response;
        };
        return begin_icop(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_icop()
    {
        return begin_icop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Ice::Context& __ctx)
    {
        return begin_icop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Test::Callback_Initial_icopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_icop(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_icopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_icop(&__ctx, __del, __cookie);
    }

    ::Test::MA::ICPrx end_icop(const ::Ice::AsyncResultPtr&);
    
private:

    ::Test::MA::ICPrx icop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_icop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Initial> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_secure(bool __secure) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_twoway() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_oneway() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_batchOneway() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_datagram() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_batchDatagram() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_compress(bool __compress) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

namespace MC
{

class A : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<A> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_secure(bool __secure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_twoway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_oneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchOneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_datagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchDatagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_compress(bool __compress) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_timeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Test::MC::A
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Test::MC::B
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D : virtual public ::IceProxy::Test::MC::C
{
public:
    
    ::IceInternal::ProxyHandle<D> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_secure(bool __secure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_twoway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_oneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchOneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_datagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchDatagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_compress(bool __compress) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace MD
{

class A : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<A> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_secure(bool __secure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_twoway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_oneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchOneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_datagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchDatagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_compress(bool __compress) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_timeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Test::MD::A
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Test::MD::B
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D : virtual public ::IceProxy::Test::MD::C
{
public:
    
    ::IceInternal::ProxyHandle<D> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_secure(bool __secure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_twoway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_oneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchOneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_datagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchDatagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_compress(bool __compress) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace ME
{

class A : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<A> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_secure(bool __secure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_twoway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_oneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchOneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_datagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchDatagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_compress(bool __compress) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_timeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Test::ME::A
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Test::ME::B
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D : virtual public ::IceProxy::Test::ME::C
{
public:
    
    ::IceInternal::ProxyHandle<D> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_secure(bool __secure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_twoway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_oneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchOneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_datagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchDatagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_compress(bool __compress) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace MF
{

class A : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<A> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_secure(bool __secure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_twoway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_oneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchOneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_datagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchDatagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_compress(bool __compress) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_timeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Test::MF::A
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Test::MF::B
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D : virtual public ::IceProxy::Test::MF::C
{
public:
    
    ::IceInternal::ProxyHandle<D> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_secure(bool __secure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_twoway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_oneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchOneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_datagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchDatagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_compress(bool __compress) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace MG
{

class A : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<A> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_secure(bool __secure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_twoway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_oneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchOneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_datagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchDatagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_compress(bool __compress) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_timeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Test::MG::A
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Test::MG::B
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D : virtual public ::IceProxy::Test::MG::C
{
public:
    
    ::IceInternal::ProxyHandle<D> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_secure(bool __secure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_twoway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_oneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchOneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_datagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchDatagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_compress(bool __compress) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace MH
{

class A : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<A> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_secure(bool __secure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_twoway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_oneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchOneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_datagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchDatagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_compress(bool __compress) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_timeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Test::MH::A
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Test::MH::B
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D : virtual public ::IceProxy::Test::MH::C
{
public:
    
    ::IceInternal::ProxyHandle<D> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_secure(bool __secure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_twoway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_oneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchOneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_datagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchDatagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_compress(bool __compress) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace Test
{

namespace MA
{

class IA : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Test::MA::IAPrx iaop(const ::Test::MA::IAPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class CA : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Test::MA::CAPrx caop(const ::Test::MA::CAPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

namespace MB
{

class IB1 : virtual public ::IceDelegate::Test::MA::IA
{
public:

    virtual ::Test::MB::IB1Prx ib1op(const ::Test::MB::IB1Prx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class IB2 : virtual public ::IceDelegate::Test::MA::IA
{
public:

    virtual ::Test::MB::IB2Prx ib2op(const ::Test::MB::IB2Prx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class CB : virtual public ::IceDelegate::Test::MA::CA
{
public:

    virtual ::Test::MB::CBPrx cbop(const ::Test::MB::CBPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

namespace MA
{

class IC : virtual public ::IceDelegate::Test::MB::IB1,
           virtual public ::IceDelegate::Test::MB::IB2
{
public:

    virtual ::Test::MA::ICPrx icop(const ::Test::MA::ICPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class CC : virtual public ::IceDelegate::Test::MB::CB
{
public:

    virtual ::Test::MA::CCPrx ccop(const ::Test::MA::CCPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class CD : virtual public ::IceDelegate::Test::MA::CC,
           virtual public ::IceDelegate::Test::MB::IB1,
           virtual public ::IceDelegate::Test::MB::IB2
{
public:

    virtual ::Test::MA::CDPrx cdop(const ::Test::MA::CDPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

class Initial : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MA::CAPrx caop(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MB::CBPrx cbop(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MA::CCPrx ccop(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MA::CDPrx cdop(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MA::IAPrx iaop(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MB::IB1Prx ib1op(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MB::IB2Prx ib2op(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Test::MA::ICPrx icop(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

namespace MC
{

class A : virtual public ::IceDelegate::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MC::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MC::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MC::C
{
public:
};

}

namespace MD
{

class A : virtual public ::IceDelegate::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MD::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MD::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MD::C
{
public:
};

}

namespace ME
{

class A : virtual public ::IceDelegate::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::ME::A
{
public:
};

class C : virtual public ::IceDelegate::Test::ME::B
{
public:
};

class D : virtual public ::IceDelegate::Test::ME::C
{
public:
};

}

namespace MF
{

class A : virtual public ::IceDelegate::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MF::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MF::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MF::C
{
public:
};

}

namespace MG
{

class A : virtual public ::IceDelegate::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MG::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MG::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MG::C
{
public:
};

}

namespace MH
{

class A : virtual public ::IceDelegate::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MH::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MH::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MH::C
{
public:
};

}

}

}

namespace IceDelegateM
{

namespace Test
{

namespace MA
{

class IA : virtual public ::IceDelegate::Test::MA::IA,
           virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Test::MA::IAPrx iaop(const ::Test::MA::IAPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CA : virtual public ::IceDelegate::Test::MA::CA,
           virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Test::MA::CAPrx caop(const ::Test::MA::CAPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

namespace MB
{

class IB1 : virtual public ::IceDelegate::Test::MB::IB1,
            virtual public ::IceDelegateM::Test::MA::IA
{
public:

    virtual ::Test::MB::IB1Prx ib1op(const ::Test::MB::IB1Prx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class IB2 : virtual public ::IceDelegate::Test::MB::IB2,
            virtual public ::IceDelegateM::Test::MA::IA
{
public:

    virtual ::Test::MB::IB2Prx ib2op(const ::Test::MB::IB2Prx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CB : virtual public ::IceDelegate::Test::MB::CB,
           virtual public ::IceDelegateM::Test::MA::CA
{
public:

    virtual ::Test::MB::CBPrx cbop(const ::Test::MB::CBPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

namespace MA
{

class IC : virtual public ::IceDelegate::Test::MA::IC,
           virtual public ::IceDelegateM::Test::MB::IB1,
           virtual public ::IceDelegateM::Test::MB::IB2
{
public:

    virtual ::Test::MA::ICPrx icop(const ::Test::MA::ICPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CC : virtual public ::IceDelegate::Test::MA::CC,
           virtual public ::IceDelegateM::Test::MB::CB
{
public:

    virtual ::Test::MA::CCPrx ccop(const ::Test::MA::CCPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CD : virtual public ::IceDelegate::Test::MA::CD,
           virtual public ::IceDelegateM::Test::MA::CC,
           virtual public ::IceDelegateM::Test::MB::IB1,
           virtual public ::IceDelegateM::Test::MB::IB2
{
public:

    virtual ::Test::MA::CDPrx cdop(const ::Test::MA::CDPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

class Initial : virtual public ::IceDelegate::Test::Initial,
                virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::CAPrx caop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MB::CBPrx cbop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::CCPrx ccop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::CDPrx cdop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::IAPrx iaop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MB::IB1Prx ib1op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MB::IB2Prx ib2op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::ICPrx icop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

namespace MC
{

class A : virtual public ::IceDelegate::Test::MC::A,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MC::B,
          virtual public ::IceDelegateM::Test::MC::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MC::C,
          virtual public ::IceDelegateM::Test::MC::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MC::D,
          virtual public ::IceDelegateM::Test::MC::C
{
public:
};

}

namespace MD
{

class A : virtual public ::IceDelegate::Test::MD::A,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MD::B,
          virtual public ::IceDelegateM::Test::MD::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MD::C,
          virtual public ::IceDelegateM::Test::MD::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MD::D,
          virtual public ::IceDelegateM::Test::MD::C
{
public:
};

}

namespace ME
{

class A : virtual public ::IceDelegate::Test::ME::A,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::ME::B,
          virtual public ::IceDelegateM::Test::ME::A
{
public:
};

class C : virtual public ::IceDelegate::Test::ME::C,
          virtual public ::IceDelegateM::Test::ME::B
{
public:
};

class D : virtual public ::IceDelegate::Test::ME::D,
          virtual public ::IceDelegateM::Test::ME::C
{
public:
};

}

namespace MF
{

class A : virtual public ::IceDelegate::Test::MF::A,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MF::B,
          virtual public ::IceDelegateM::Test::MF::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MF::C,
          virtual public ::IceDelegateM::Test::MF::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MF::D,
          virtual public ::IceDelegateM::Test::MF::C
{
public:
};

}

namespace MG
{

class A : virtual public ::IceDelegate::Test::MG::A,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MG::B,
          virtual public ::IceDelegateM::Test::MG::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MG::C,
          virtual public ::IceDelegateM::Test::MG::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MG::D,
          virtual public ::IceDelegateM::Test::MG::C
{
public:
};

}

namespace MH
{

class A : virtual public ::IceDelegate::Test::MH::A,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MH::B,
          virtual public ::IceDelegateM::Test::MH::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MH::C,
          virtual public ::IceDelegateM::Test::MH::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MH::D,
          virtual public ::IceDelegateM::Test::MH::C
{
public:
};

}

}

}

namespace IceDelegateD
{

namespace Test
{

namespace MA
{

class IA : virtual public ::IceDelegate::Test::MA::IA,
           virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Test::MA::IAPrx iaop(const ::Test::MA::IAPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CA : virtual public ::IceDelegate::Test::MA::CA,
           virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Test::MA::CAPrx caop(const ::Test::MA::CAPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

namespace MB
{

class IB1 : virtual public ::IceDelegate::Test::MB::IB1,
            virtual public ::IceDelegateD::Test::MA::IA
{
public:

    virtual ::Test::MB::IB1Prx ib1op(const ::Test::MB::IB1Prx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class IB2 : virtual public ::IceDelegate::Test::MB::IB2,
            virtual public ::IceDelegateD::Test::MA::IA
{
public:

    virtual ::Test::MB::IB2Prx ib2op(const ::Test::MB::IB2Prx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CB : virtual public ::IceDelegate::Test::MB::CB,
           virtual public ::IceDelegateD::Test::MA::CA
{
public:

    virtual ::Test::MB::CBPrx cbop(const ::Test::MB::CBPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

namespace MA
{

class IC : virtual public ::IceDelegate::Test::MA::IC,
           virtual public ::IceDelegateD::Test::MB::IB1,
           virtual public ::IceDelegateD::Test::MB::IB2
{
public:

    virtual ::Test::MA::ICPrx icop(const ::Test::MA::ICPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CC : virtual public ::IceDelegate::Test::MA::CC,
           virtual public ::IceDelegateD::Test::MB::CB
{
public:

    virtual ::Test::MA::CCPrx ccop(const ::Test::MA::CCPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class CD : virtual public ::IceDelegate::Test::MA::CD,
           virtual public ::IceDelegateD::Test::MA::CC,
           virtual public ::IceDelegateD::Test::MB::IB1,
           virtual public ::IceDelegateD::Test::MB::IB2
{
public:

    virtual ::Test::MA::CDPrx cdop(const ::Test::MA::CDPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

class Initial : virtual public ::IceDelegate::Test::Initial,
                virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void shutdown(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::CAPrx caop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MB::CBPrx cbop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::CCPrx ccop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::CDPrx cdop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::IAPrx iaop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MB::IB1Prx ib1op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MB::IB2Prx ib2op(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Test::MA::ICPrx icop(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

namespace MC
{

class A : virtual public ::IceDelegate::Test::MC::A,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MC::B,
          virtual public ::IceDelegateD::Test::MC::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MC::C,
          virtual public ::IceDelegateD::Test::MC::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MC::D,
          virtual public ::IceDelegateD::Test::MC::C
{
public:
};

}

namespace MD
{

class A : virtual public ::IceDelegate::Test::MD::A,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MD::B,
          virtual public ::IceDelegateD::Test::MD::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MD::C,
          virtual public ::IceDelegateD::Test::MD::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MD::D,
          virtual public ::IceDelegateD::Test::MD::C
{
public:
};

}

namespace ME
{

class A : virtual public ::IceDelegate::Test::ME::A,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::ME::B,
          virtual public ::IceDelegateD::Test::ME::A
{
public:
};

class C : virtual public ::IceDelegate::Test::ME::C,
          virtual public ::IceDelegateD::Test::ME::B
{
public:
};

class D : virtual public ::IceDelegate::Test::ME::D,
          virtual public ::IceDelegateD::Test::ME::C
{
public:
};

}

namespace MF
{

class A : virtual public ::IceDelegate::Test::MF::A,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MF::B,
          virtual public ::IceDelegateD::Test::MF::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MF::C,
          virtual public ::IceDelegateD::Test::MF::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MF::D,
          virtual public ::IceDelegateD::Test::MF::C
{
public:
};

}

namespace MG
{

class A : virtual public ::IceDelegate::Test::MG::A,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MG::B,
          virtual public ::IceDelegateD::Test::MG::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MG::C,
          virtual public ::IceDelegateD::Test::MG::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MG::D,
          virtual public ::IceDelegateD::Test::MG::C
{
public:
};

}

namespace MH
{

class A : virtual public ::IceDelegate::Test::MH::A,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class B : virtual public ::IceDelegate::Test::MH::B,
          virtual public ::IceDelegateD::Test::MH::A
{
public:
};

class C : virtual public ::IceDelegate::Test::MH::C,
          virtual public ::IceDelegateD::Test::MH::B
{
public:
};

class D : virtual public ::IceDelegate::Test::MH::D,
          virtual public ::IceDelegateD::Test::MH::C
{
public:
};

}

}

}

namespace Test
{

namespace MA
{

class IA : virtual public ::Ice::Object
{
public:

    typedef IAPrx ProxyType;
    typedef IAPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MA::IAPrx iaop(const ::Test::MA::IAPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___iaop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const IA& l, const IA& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const IA& l, const IA& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class CA : virtual public ::Ice::Object
{
public:

    typedef CAPrx ProxyType;
    typedef CAPtr PointerType;

    CA()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MA::CAPrx caop(const ::Test::MA::CAPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___caop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const CA& l, const CA& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CA& l, const CA& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace MB
{

class IB1 : virtual public ::Test::MA::IA
{
public:

    typedef IB1Prx ProxyType;
    typedef IB1Ptr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MB::IB1Prx ib1op(const ::Test::MB::IB1Prx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ib1op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const IB1& l, const IB1& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const IB1& l, const IB1& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class IB2 : virtual public ::Test::MA::IA
{
public:

    typedef IB2Prx ProxyType;
    typedef IB2Ptr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MB::IB2Prx ib2op(const ::Test::MB::IB2Prx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ib2op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const IB2& l, const IB2& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const IB2& l, const IB2& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class CB : virtual public ::Test::MA::CA
{
public:

    typedef CBPrx ProxyType;
    typedef CBPtr PointerType;

    CB()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MB::CBPrx cbop(const ::Test::MB::CBPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___cbop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MA::CA::__writeImpl;
    using ::Test::MA::CA::__readImpl;
    #endif
};

inline bool operator==(const CB& l, const CB& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CB& l, const CB& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace MA
{

class IC : virtual public ::Test::MB::IB1,
           virtual public ::Test::MB::IB2
{
public:

    typedef ICPrx ProxyType;
    typedef ICPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MA::ICPrx icop(const ::Test::MA::ICPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___icop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const IC& l, const IC& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const IC& l, const IC& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class CC : virtual public ::Test::MB::CB
{
public:

    typedef CCPrx ProxyType;
    typedef CCPtr PointerType;

    CC()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MA::CCPrx ccop(const ::Test::MA::CCPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ccop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MB::CB::__writeImpl;
    using ::Test::MB::CB::__readImpl;
    #endif
};

inline bool operator==(const CC& l, const CC& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CC& l, const CC& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class CD : virtual public ::Test::MA::CC,
           virtual public ::Test::MB::IB1,
           virtual public ::Test::MB::IB2
{
public:

    typedef CDPrx ProxyType;
    typedef CDPtr PointerType;

    CD()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Test::MA::CDPrx cdop(const ::Test::MA::CDPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___cdop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MA::CC::__writeImpl;
    using ::Test::MA::CC::__readImpl;
    #endif
};

inline bool operator==(const CD& l, const CD& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CD& l, const CD& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

class Initial : virtual public ::Ice::Object
{
public:

    typedef InitialPrx ProxyType;
    typedef InitialPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MA::CAPrx caop(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___caop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MB::CBPrx cbop(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___cbop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MA::CCPrx ccop(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ccop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MA::CDPrx cdop(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___cdop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MA::IAPrx iaop(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___iaop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MB::IB1Prx ib1op(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ib1op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MB::IB2Prx ib2op(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ib2op(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Test::MA::ICPrx icop(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___icop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Initial& l, const Initial& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Initial& l, const Initial& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

namespace MC
{

class A : virtual public ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    A()
    {
    }

    explicit A(::Ice::Int __ice_aA) :
        aA(__ice_aA)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int aA;

protected:

    virtual ~A() {}

    friend class A__staticInit;
};

class A__staticInit
{
public:

    ::Test::MC::A _init;
};

static A__staticInit _A_init;

inline bool operator==(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : public ::Test::MC::A
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(::Ice::Int __ice_aA, ::Ice::Int __ice_bB) :
        ::Test::MC::A(__ice_aA)
        ,
        bB(__ice_bB)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MC::A::__writeImpl;
    using ::Test::MC::A::__readImpl;
    #endif

public:

    ::Ice::Int bB;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : public ::Test::MC::B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC) :
        ::Test::MC::B(__ice_aA, __ice_bB)
        ,
        cC(__ice_cC)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MC::B::__writeImpl;
    using ::Test::MC::B::__readImpl;
    #endif

public:

    ::Ice::Int cC;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D : virtual public ::Test::MC::C
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    D()
    {
    }

    D(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC, ::Ice::Int __ice_dD) :
        ::Test::MC::C(__ice_aA, __ice_bB, __ice_cC)
        ,
        dD(__ice_dD)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MC::C::__writeImpl;
    using ::Test::MC::C::__readImpl;
    #endif

public:

    ::Ice::Int dD;

protected:

    virtual ~D() {}
};

inline bool operator==(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace MD
{

class A : virtual public ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    A()
    {
    }

    explicit A(::Ice::Int __ice_aA) :
        aA(__ice_aA)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int aA;

protected:

    virtual ~A() {}
};

inline bool operator==(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : virtual public ::Test::MD::A
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(::Ice::Int __ice_aA, ::Ice::Int __ice_bB) :
        ::Test::MD::A(__ice_aA)
        ,
        bB(__ice_bB)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MD::A::__writeImpl;
    using ::Test::MD::A::__readImpl;
    #endif

public:

    ::Ice::Int bB;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : virtual public ::Test::MD::B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC) :
        ::Test::MD::A(__ice_aA)
        ,
        ::Test::MD::B(__ice_aA, __ice_bB)
        ,
        cC(__ice_cC)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MD::B::__writeImpl;
    using ::Test::MD::B::__readImpl;
    #endif

public:

    ::Ice::Int cC;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D : virtual public ::Test::MD::C
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    D()
    {
    }

    D(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC, ::Ice::Int __ice_dD) :
        ::Test::MD::A(__ice_aA)
        ,
        ::Test::MD::B(__ice_aA, __ice_bB)
        ,
        ::Test::MD::C(__ice_aA, __ice_bB, __ice_cC)
        ,
        dD(__ice_dD)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MD::C::__writeImpl;
    using ::Test::MD::C::__readImpl;
    #endif

public:

    ::Ice::Int dD;

protected:

    virtual ~D() {}
};

inline bool operator==(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace ME
{

class A : virtual public ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    A()
    {
    }

    explicit A(::Ice::Int __ice_aA) :
        aA(__ice_aA)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int aA;

protected:

    virtual ~A() {}
};

inline bool operator==(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : public ::Test::ME::A
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(::Ice::Int __ice_aA, ::Ice::Int __ice_bB) :
        ::Test::ME::A(__ice_aA)
        ,
        bB(__ice_bB)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::ME::A::__writeImpl;
    using ::Test::ME::A::__readImpl;
    #endif

public:

    ::Ice::Int bB;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : virtual public ::Test::ME::B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC) :
        ::Test::ME::B(__ice_aA, __ice_bB)
        ,
        cC(__ice_cC)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::ME::B::__writeImpl;
    using ::Test::ME::B::__readImpl;
    #endif

public:

    ::Ice::Int cC;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D : virtual public ::Test::ME::C
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    D()
    {
    }

    D(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC, ::Ice::Int __ice_dD) :
        ::Test::ME::B(__ice_aA, __ice_bB)
        ,
        ::Test::ME::C(__ice_aA, __ice_bB, __ice_cC)
        ,
        dD(__ice_dD)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::ME::C::__writeImpl;
    using ::Test::ME::C::__readImpl;
    #endif

public:

    ::Ice::Int dD;

protected:

    virtual ~D() {}
};

inline bool operator==(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace MF
{

class A : virtual public ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    A()
    {
    }

    explicit A(::Ice::Int __ice_aA) :
        aA(__ice_aA)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int aA;

protected:

    virtual ~A() {}
};

inline bool operator==(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : virtual public ::Test::MF::A
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(::Ice::Int __ice_aA, ::Ice::Int __ice_bB) :
        ::Test::MF::A(__ice_aA)
        ,
        bB(__ice_bB)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MF::A::__writeImpl;
    using ::Test::MF::A::__readImpl;
    #endif

public:

    ::Ice::Int bB;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : public ::Test::MF::B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC) :
        ::Test::MF::A(__ice_aA)
        ,
        ::Test::MF::B(__ice_aA, __ice_bB)
        ,
        cC(__ice_cC)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MF::B::__writeImpl;
    using ::Test::MF::B::__readImpl;
    #endif

public:

    ::Ice::Int cC;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D : virtual public ::Test::MF::C
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    D()
    {
    }

    D(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC, ::Ice::Int __ice_dD) :
        ::Test::MF::A(__ice_aA)
        ,
        ::Test::MF::C(__ice_aA, __ice_bB, __ice_cC)
        ,
        dD(__ice_dD)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MF::C::__writeImpl;
    using ::Test::MF::C::__readImpl;
    #endif

public:

    ::Ice::Int dD;

protected:

    virtual ~D() {}
};

inline bool operator==(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace MG
{

class A : virtual public ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    A()
    {
    }

    explicit A(::Ice::Int __ice_aA) :
        aA(__ice_aA)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int aA;

protected:

    virtual ~A() {}
};

inline bool operator==(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : virtual public ::Test::MG::A
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(::Ice::Int __ice_aA, ::Ice::Int __ice_bB) :
        ::Test::MG::A(__ice_aA)
        ,
        bB(__ice_bB)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MG::A::__writeImpl;
    using ::Test::MG::A::__readImpl;
    #endif

public:

    ::Ice::Int bB;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : virtual public ::Test::MG::B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC) :
        ::Test::MG::A(__ice_aA)
        ,
        ::Test::MG::B(__ice_aA, __ice_bB)
        ,
        cC(__ice_cC)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MG::B::__writeImpl;
    using ::Test::MG::B::__readImpl;
    #endif

public:

    ::Ice::Int cC;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D : public ::Test::MG::C
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    D()
    {
    }

    D(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC, ::Ice::Int __ice_dD) :
        ::Test::MG::A(__ice_aA)
        ,
        ::Test::MG::B(__ice_aA, __ice_bB)
        ,
        ::Test::MG::C(__ice_aA, __ice_bB, __ice_cC)
        ,
        dD(__ice_dD)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MG::C::__writeImpl;
    using ::Test::MG::C::__readImpl;
    #endif

public:

    ::Ice::Int dD;

protected:

    virtual ~D() {}
};

inline bool operator==(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace MH
{

class A : virtual public ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    A()
    {
    }

    explicit A(::Ice::Int __ice_aA) :
        aA(__ice_aA)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int aA;

protected:

    virtual ~A() {}
};

inline bool operator==(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : public ::Test::MH::A
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B()
    {
    }

    B(::Ice::Int __ice_aA, ::Ice::Int __ice_bB) :
        ::Test::MH::A(__ice_aA)
        ,
        bB(__ice_bB)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MH::A::__writeImpl;
    using ::Test::MH::A::__readImpl;
    #endif

public:

    ::Ice::Int bB;

protected:

    virtual ~B() {}
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : public ::Test::MH::B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC) :
        ::Test::MH::B(__ice_aA, __ice_bB)
        ,
        cC(__ice_cC)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MH::B::__writeImpl;
    using ::Test::MH::B::__readImpl;
    #endif

public:

    ::Ice::Int cC;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D : public ::Test::MH::C
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    D()
    {
    }

    D(::Ice::Int __ice_aA, ::Ice::Int __ice_bB, ::Ice::Int __ice_cC, ::Ice::Int __ice_dD) :
        ::Test::MH::C(__ice_aA, __ice_bB, __ice_cC)
        ,
        dD(__ice_dD)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::MH::C::__writeImpl;
    using ::Test::MH::C::__readImpl;
    #endif

public:

    ::Ice::Int dD;

protected:

    virtual ~D() {}
};

inline bool operator==(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace Test
{

namespace MA
{

template<class T>
class CallbackNC_IA_iaop : public Callback_IA_iaop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::IAPrx&);

    CallbackNC_IA_iaop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::IAPrx __proxy = ::Test::MA::IAPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::IAPrx __ret;
        try
        {
            __ret = __proxy->end_iaop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_IA_iaopPtr
newCallback_IA_iaop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::IAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IA_iaop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_IA_iaopPtr
newCallback_IA_iaop(T* instance, void (T::*cb)(const ::Test::MA::IAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IA_iaop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_IA_iaop : public Callback_IA_iaop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::IAPrx&, const CT&);

    Callback_IA_iaop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::IAPrx __proxy = ::Test::MA::IAPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::IAPrx __ret;
        try
        {
            __ret = __proxy->end_iaop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_IA_iaopPtr
newCallback_IA_iaop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::IAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IA_iaop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_IA_iaopPtr
newCallback_IA_iaop(T* instance, void (T::*cb)(const ::Test::MA::IAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IA_iaop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_CA_caop : public Callback_CA_caop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::CAPrx&);

    CallbackNC_CA_caop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::CAPrx __proxy = ::Test::MA::CAPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CAPrx __ret;
        try
        {
            __ret = __proxy->end_caop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_CA_caopPtr
newCallback_CA_caop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CA_caop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CA_caopPtr
newCallback_CA_caop(T* instance, void (T::*cb)(const ::Test::MA::CAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CA_caop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_CA_caop : public Callback_CA_caop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::CAPrx&, const CT&);

    Callback_CA_caop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::CAPrx __proxy = ::Test::MA::CAPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CAPrx __ret;
        try
        {
            __ret = __proxy->end_caop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_CA_caopPtr
newCallback_CA_caop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CA_caop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CA_caopPtr
newCallback_CA_caop(T* instance, void (T::*cb)(const ::Test::MA::CAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CA_caop<T, CT>(instance, cb, excb, sentcb);
}

}

namespace MB
{

template<class T>
class CallbackNC_IB1_ib1op : public Callback_IB1_ib1op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MB::IB1Prx&);

    CallbackNC_IB1_ib1op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MB::IB1Prx __proxy = ::Test::MB::IB1Prx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB1Prx __ret;
        try
        {
            __ret = __proxy->end_ib1op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_IB1_ib1opPtr
newCallback_IB1_ib1op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB1Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IB1_ib1op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_IB1_ib1opPtr
newCallback_IB1_ib1op(T* instance, void (T::*cb)(const ::Test::MB::IB1Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IB1_ib1op<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_IB1_ib1op : public Callback_IB1_ib1op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MB::IB1Prx&, const CT&);

    Callback_IB1_ib1op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MB::IB1Prx __proxy = ::Test::MB::IB1Prx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB1Prx __ret;
        try
        {
            __ret = __proxy->end_ib1op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_IB1_ib1opPtr
newCallback_IB1_ib1op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB1Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IB1_ib1op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_IB1_ib1opPtr
newCallback_IB1_ib1op(T* instance, void (T::*cb)(const ::Test::MB::IB1Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IB1_ib1op<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_IB2_ib2op : public Callback_IB2_ib2op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MB::IB2Prx&);

    CallbackNC_IB2_ib2op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MB::IB2Prx __proxy = ::Test::MB::IB2Prx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB2Prx __ret;
        try
        {
            __ret = __proxy->end_ib2op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_IB2_ib2opPtr
newCallback_IB2_ib2op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB2Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IB2_ib2op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_IB2_ib2opPtr
newCallback_IB2_ib2op(T* instance, void (T::*cb)(const ::Test::MB::IB2Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IB2_ib2op<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_IB2_ib2op : public Callback_IB2_ib2op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MB::IB2Prx&, const CT&);

    Callback_IB2_ib2op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MB::IB2Prx __proxy = ::Test::MB::IB2Prx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB2Prx __ret;
        try
        {
            __ret = __proxy->end_ib2op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_IB2_ib2opPtr
newCallback_IB2_ib2op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB2Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IB2_ib2op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_IB2_ib2opPtr
newCallback_IB2_ib2op(T* instance, void (T::*cb)(const ::Test::MB::IB2Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IB2_ib2op<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_CB_cbop : public Callback_CB_cbop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MB::CBPrx&);

    CallbackNC_CB_cbop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MB::CBPrx __proxy = ::Test::MB::CBPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::CBPrx __ret;
        try
        {
            __ret = __proxy->end_cbop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_CB_cbopPtr
newCallback_CB_cbop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::CBPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CB_cbop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CB_cbopPtr
newCallback_CB_cbop(T* instance, void (T::*cb)(const ::Test::MB::CBPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CB_cbop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_CB_cbop : public Callback_CB_cbop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MB::CBPrx&, const CT&);

    Callback_CB_cbop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MB::CBPrx __proxy = ::Test::MB::CBPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::CBPrx __ret;
        try
        {
            __ret = __proxy->end_cbop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_CB_cbopPtr
newCallback_CB_cbop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::CBPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CB_cbop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CB_cbopPtr
newCallback_CB_cbop(T* instance, void (T::*cb)(const ::Test::MB::CBPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CB_cbop<T, CT>(instance, cb, excb, sentcb);
}

}

namespace MA
{

template<class T>
class CallbackNC_IC_icop : public Callback_IC_icop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::ICPrx&);

    CallbackNC_IC_icop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::ICPrx __proxy = ::Test::MA::ICPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::ICPrx __ret;
        try
        {
            __ret = __proxy->end_icop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_IC_icopPtr
newCallback_IC_icop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::ICPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IC_icop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_IC_icopPtr
newCallback_IC_icop(T* instance, void (T::*cb)(const ::Test::MA::ICPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IC_icop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_IC_icop : public Callback_IC_icop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::ICPrx&, const CT&);

    Callback_IC_icop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::ICPrx __proxy = ::Test::MA::ICPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::ICPrx __ret;
        try
        {
            __ret = __proxy->end_icop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_IC_icopPtr
newCallback_IC_icop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::ICPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IC_icop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_IC_icopPtr
newCallback_IC_icop(T* instance, void (T::*cb)(const ::Test::MA::ICPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IC_icop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_CC_ccop : public Callback_CC_ccop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::CCPrx&);

    CallbackNC_CC_ccop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::CCPrx __proxy = ::Test::MA::CCPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CCPrx __ret;
        try
        {
            __ret = __proxy->end_ccop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_CC_ccopPtr
newCallback_CC_ccop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CCPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CC_ccop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CC_ccopPtr
newCallback_CC_ccop(T* instance, void (T::*cb)(const ::Test::MA::CCPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CC_ccop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_CC_ccop : public Callback_CC_ccop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::CCPrx&, const CT&);

    Callback_CC_ccop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::CCPrx __proxy = ::Test::MA::CCPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CCPrx __ret;
        try
        {
            __ret = __proxy->end_ccop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_CC_ccopPtr
newCallback_CC_ccop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CCPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CC_ccop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CC_ccopPtr
newCallback_CC_ccop(T* instance, void (T::*cb)(const ::Test::MA::CCPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CC_ccop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_CD_cdop : public Callback_CD_cdop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::CDPrx&);

    CallbackNC_CD_cdop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::CDPrx __proxy = ::Test::MA::CDPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CDPrx __ret;
        try
        {
            __ret = __proxy->end_cdop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_CD_cdopPtr
newCallback_CD_cdop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CDPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CD_cdop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CD_cdopPtr
newCallback_CD_cdop(T* instance, void (T::*cb)(const ::Test::MA::CDPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CD_cdop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_CD_cdop : public Callback_CD_cdop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::CDPrx&, const CT&);

    Callback_CD_cdop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::MA::CDPrx __proxy = ::Test::MA::CDPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CDPrx __ret;
        try
        {
            __ret = __proxy->end_cdop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_CD_cdopPtr
newCallback_CD_cdop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CDPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CD_cdop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CD_cdopPtr
newCallback_CD_cdop(T* instance, void (T::*cb)(const ::Test::MA::CDPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CD_cdop<T, CT>(instance, cb, excb, sentcb);
}

}

template<class T>
class CallbackNC_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_caop : public Callback_Initial_caop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::CAPrx&);

    CallbackNC_Initial_caop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CAPrx __ret;
        try
        {
            __ret = __proxy->end_caop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_caopPtr
newCallback_Initial_caop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_caop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_caopPtr
newCallback_Initial_caop(T* instance, void (T::*cb)(const ::Test::MA::CAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_caop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_caop : public Callback_Initial_caop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::CAPrx&, const CT&);

    Callback_Initial_caop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CAPrx __ret;
        try
        {
            __ret = __proxy->end_caop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_caopPtr
newCallback_Initial_caop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_caop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_caopPtr
newCallback_Initial_caop(T* instance, void (T::*cb)(const ::Test::MA::CAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_caop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_cbop : public Callback_Initial_cbop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MB::CBPrx&);

    CallbackNC_Initial_cbop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::CBPrx __ret;
        try
        {
            __ret = __proxy->end_cbop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_cbopPtr
newCallback_Initial_cbop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::CBPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_cbop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_cbopPtr
newCallback_Initial_cbop(T* instance, void (T::*cb)(const ::Test::MB::CBPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_cbop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_cbop : public Callback_Initial_cbop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MB::CBPrx&, const CT&);

    Callback_Initial_cbop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::CBPrx __ret;
        try
        {
            __ret = __proxy->end_cbop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_cbopPtr
newCallback_Initial_cbop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::CBPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_cbop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_cbopPtr
newCallback_Initial_cbop(T* instance, void (T::*cb)(const ::Test::MB::CBPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_cbop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_ccop : public Callback_Initial_ccop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::CCPrx&);

    CallbackNC_Initial_ccop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CCPrx __ret;
        try
        {
            __ret = __proxy->end_ccop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_ccopPtr
newCallback_Initial_ccop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CCPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_ccop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_ccopPtr
newCallback_Initial_ccop(T* instance, void (T::*cb)(const ::Test::MA::CCPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_ccop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_ccop : public Callback_Initial_ccop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::CCPrx&, const CT&);

    Callback_Initial_ccop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CCPrx __ret;
        try
        {
            __ret = __proxy->end_ccop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_ccopPtr
newCallback_Initial_ccop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CCPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_ccop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_ccopPtr
newCallback_Initial_ccop(T* instance, void (T::*cb)(const ::Test::MA::CCPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_ccop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_cdop : public Callback_Initial_cdop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::CDPrx&);

    CallbackNC_Initial_cdop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CDPrx __ret;
        try
        {
            __ret = __proxy->end_cdop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_cdopPtr
newCallback_Initial_cdop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CDPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_cdop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_cdopPtr
newCallback_Initial_cdop(T* instance, void (T::*cb)(const ::Test::MA::CDPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_cdop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_cdop : public Callback_Initial_cdop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::CDPrx&, const CT&);

    Callback_Initial_cdop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::CDPrx __ret;
        try
        {
            __ret = __proxy->end_cdop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_cdopPtr
newCallback_Initial_cdop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::CDPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_cdop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_cdopPtr
newCallback_Initial_cdop(T* instance, void (T::*cb)(const ::Test::MA::CDPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_cdop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_iaop : public Callback_Initial_iaop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::IAPrx&);

    CallbackNC_Initial_iaop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::IAPrx __ret;
        try
        {
            __ret = __proxy->end_iaop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_iaopPtr
newCallback_Initial_iaop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::IAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_iaop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_iaopPtr
newCallback_Initial_iaop(T* instance, void (T::*cb)(const ::Test::MA::IAPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_iaop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_iaop : public Callback_Initial_iaop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::IAPrx&, const CT&);

    Callback_Initial_iaop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::IAPrx __ret;
        try
        {
            __ret = __proxy->end_iaop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_iaopPtr
newCallback_Initial_iaop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::IAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_iaop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_iaopPtr
newCallback_Initial_iaop(T* instance, void (T::*cb)(const ::Test::MA::IAPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_iaop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_ib1op : public Callback_Initial_ib1op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MB::IB1Prx&);

    CallbackNC_Initial_ib1op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB1Prx __ret;
        try
        {
            __ret = __proxy->end_ib1op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_ib1opPtr
newCallback_Initial_ib1op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB1Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_ib1op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_ib1opPtr
newCallback_Initial_ib1op(T* instance, void (T::*cb)(const ::Test::MB::IB1Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_ib1op<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_ib1op : public Callback_Initial_ib1op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MB::IB1Prx&, const CT&);

    Callback_Initial_ib1op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB1Prx __ret;
        try
        {
            __ret = __proxy->end_ib1op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_ib1opPtr
newCallback_Initial_ib1op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB1Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_ib1op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_ib1opPtr
newCallback_Initial_ib1op(T* instance, void (T::*cb)(const ::Test::MB::IB1Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_ib1op<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_ib2op : public Callback_Initial_ib2op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MB::IB2Prx&);

    CallbackNC_Initial_ib2op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB2Prx __ret;
        try
        {
            __ret = __proxy->end_ib2op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_ib2opPtr
newCallback_Initial_ib2op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB2Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_ib2op<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_ib2opPtr
newCallback_Initial_ib2op(T* instance, void (T::*cb)(const ::Test::MB::IB2Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_ib2op<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_ib2op : public Callback_Initial_ib2op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MB::IB2Prx&, const CT&);

    Callback_Initial_ib2op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MB::IB2Prx __ret;
        try
        {
            __ret = __proxy->end_ib2op(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_ib2opPtr
newCallback_Initial_ib2op(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MB::IB2Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_ib2op<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_ib2opPtr
newCallback_Initial_ib2op(T* instance, void (T::*cb)(const ::Test::MB::IB2Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_ib2op<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_icop : public Callback_Initial_icop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::MA::ICPrx&);

    CallbackNC_Initial_icop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::ICPrx __ret;
        try
        {
            __ret = __proxy->end_icop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Initial_icopPtr
newCallback_Initial_icop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::ICPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_icop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_icopPtr
newCallback_Initial_icop(T* instance, void (T::*cb)(const ::Test::MA::ICPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_icop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_icop : public Callback_Initial_icop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::MA::ICPrx&, const CT&);

    Callback_Initial_icop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Test::MA::ICPrx __ret;
        try
        {
            __ret = __proxy->end_icop(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Initial_icopPtr
newCallback_Initial_icop(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::MA::ICPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_icop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_icopPtr
newCallback_Initial_icop(T* instance, void (T::*cb)(const ::Test::MA::ICPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_icop<T, CT>(instance, cb, excb, sentcb);
}

namespace MC
{

}

namespace MD
{

}

namespace ME
{

}

namespace MF
{

}

namespace MG
{

}

namespace MH
{

}

}

#endif
