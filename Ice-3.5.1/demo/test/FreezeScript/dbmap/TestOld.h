// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `TestOld.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TestOld_h__
#define __TestOld_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::C*);

class D;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::D>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::D*);

class F;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::F>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::F*);

}

}

namespace Test
{

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::C*);
typedef ::IceInternal::Handle< ::Test::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class D;
bool operator==(const D&, const D&);
bool operator<(const D&, const D&);
::Ice::Object* upCast(::Test::D*);
typedef ::IceInternal::Handle< ::Test::D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D> DPrx;
void __patch(DPtr&, const ::Ice::ObjectPtr&);

class F;
bool operator==(const F&, const F&);
bool operator<(const F&, const F&);
::Ice::Object* upCast(::Test::F*);
typedef ::IceInternal::Handle< ::Test::F> FPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::F> FPrx;
void __patch(FPtr&, const ::Ice::ObjectPtr&);

}

namespace Test
{

enum E
{
    E1,
    E2,
    E3
};

typedef ::std::vector<bool> BoolStringSeq;

typedef ::std::vector< ::Ice::Byte> ByteByteSeq;

typedef ::std::vector< ::Ice::Byte> ByteShortSeq;

typedef ::std::vector< ::Ice::Byte> ByteIntSeq;

typedef ::std::vector< ::Ice::Byte> ByteLongSeq;

typedef ::std::vector< ::Ice::Byte> ByteStringSeq;

typedef ::std::vector< ::Ice::Short> ShortByteSeq;

typedef ::std::vector< ::Ice::Short> ShortShortSeq;

typedef ::std::vector< ::Ice::Short> ShortIntSeq;

typedef ::std::vector< ::Ice::Short> ShortLongSeq;

typedef ::std::vector< ::Ice::Short> ShortStringSeq;

typedef ::std::vector< ::Ice::Int> IntByteSeq;

typedef ::std::vector< ::Ice::Int> IntShortSeq;

typedef ::std::vector< ::Ice::Int> IntIntSeq;

typedef ::std::vector< ::Ice::Int> IntLongSeq;

typedef ::std::vector< ::Ice::Int> IntStringSeq;

typedef ::std::vector< ::Ice::Long> LongByteSeq;

typedef ::std::vector< ::Ice::Long> LongShortSeq;

typedef ::std::vector< ::Ice::Long> LongIntSeq;

typedef ::std::vector< ::Ice::Long> LongLongSeq;

typedef ::std::vector< ::Ice::Long> LongStringSeq;

typedef ::std::vector< ::Ice::Float> FloatFloatSeq;

typedef ::std::vector< ::Ice::Float> FloatDoubleSeq;

typedef ::std::vector< ::Ice::Float> FloatStringSeq;

typedef ::std::vector< ::Ice::Double> DoubleFloatSeq;

typedef ::std::vector< ::Ice::Double> DoubleDoubleSeq;

typedef ::std::vector< ::Ice::Double> DoubleStringSeq;

typedef ::std::vector< ::std::string> StringBoolSeq;

typedef ::std::vector< ::std::string> StringByteSeq;

typedef ::std::vector< ::std::string> StringShortSeq;

typedef ::std::vector< ::std::string> StringIntSeq;

typedef ::std::vector< ::std::string> StringLongSeq;

typedef ::std::vector< ::std::string> StringFloatSeq;

typedef ::std::vector< ::std::string> StringDoubleSeq;

typedef ::std::vector< ::std::string> StringStringSeq;

typedef ::std::vector< ::std::string> StringEnumSeq;

typedef ::std::vector< ::std::string> StringProxySeq;

typedef ::std::map< ::Ice::Int, bool> BoolStringDict;

typedef ::std::map< ::Ice::Int, ::Ice::Long> LongByteDict;

typedef ::std::map< ::Ice::Int, ::Ice::Long> LongShortDict;

typedef ::std::map< ::Ice::Int, ::Ice::Long> LongIntDict;

typedef ::std::map< ::Ice::Int, ::Ice::Long> LongStringDict;

typedef ::std::map< ::Ice::Int, ::Ice::Double> DoubleFloatDict;

typedef ::std::map< ::Ice::Int, ::Ice::Double> DoubleStringDict;

typedef ::std::map< ::Ice::Int, ::std::string> StringBoolDict;

typedef ::std::map< ::Ice::Int, ::std::string> StringLongDict;

typedef ::std::map< ::Ice::Int, ::std::string> StringDoubleDict;

typedef ::std::map< ::Ice::Int, ::std::string> StringEnumDict;

struct S
{
    bool boolToString;
    ::Ice::Byte byteToByte;
    ::Ice::Byte byteToShort;
    ::Ice::Byte byteToInt;
    ::Ice::Byte byteToLong;
    ::Ice::Byte byteToString;
    ::Ice::Short shortToByte;
    ::Ice::Short shortToShort;
    ::Ice::Short shortToInt;
    ::Ice::Short shortToLong;
    ::Ice::Short shortToString;
    ::Ice::Int intToByte;
    ::Ice::Int intToShort;
    ::Ice::Int intToInt;
    ::Ice::Int intToLong;
    ::Ice::Int intToString;
    ::Ice::Long longToByte;
    ::Ice::Long longToShort;
    ::Ice::Long longToInt;
    ::Ice::Long longToLong;
    ::Ice::Long longToString;
    ::Ice::Float floatToFloat;
    ::Ice::Float floatToDouble;
    ::Ice::Float floatToString;
    ::Ice::Double doubleToFloat;
    ::Ice::Double doubleToDouble;
    ::Ice::Double doubleToString;
    ::std::string stringToBool;
    ::std::string stringToByte;
    ::std::string stringToShort;
    ::std::string stringToInt;
    ::std::string stringToLong;
    ::std::string stringToFloat;
    ::std::string stringToDouble;
    ::std::string stringToString;
    ::std::string stringToEnum;
    ::std::string stringToProxy;
    ::Test::BoolStringSeq boolSeqToStringSeq;
    ::Test::ByteByteSeq byteSeqToByteSeq;
    ::Test::ByteShortSeq byteSeqToShortSeq;
    ::Test::ByteIntSeq byteSeqToIntSeq;
    ::Test::ByteLongSeq byteSeqToLongSeq;
    ::Test::ByteStringSeq byteSeqToStringSeq;
    ::Test::ShortByteSeq shortSeqToByteSeq;
    ::Test::ShortShortSeq shortSeqToShortSeq;
    ::Test::ShortIntSeq shortSeqToIntSeq;
    ::Test::ShortLongSeq shortSeqToLongSeq;
    ::Test::ShortStringSeq shortSeqToStringSeq;
    ::Test::IntByteSeq intSeqToByteSeq;
    ::Test::IntShortSeq intSeqToShortSeq;
    ::Test::IntIntSeq intSeqToIntSeq;
    ::Test::IntLongSeq intSeqToLongSeq;
    ::Test::IntStringSeq intSeqToStringSeq;
    ::Test::LongByteSeq longSeqToByteSeq;
    ::Test::LongShortSeq longSeqToShortSeq;
    ::Test::LongIntSeq longSeqToIntSeq;
    ::Test::LongLongSeq longSeqToLongSeq;
    ::Test::LongStringSeq longSeqToStringSeq;
    ::Test::FloatFloatSeq floatSeqToFloatSeq;
    ::Test::FloatDoubleSeq floatSeqToDoubleSeq;
    ::Test::FloatStringSeq floatSeqToStringSeq;
    ::Test::DoubleFloatSeq doubleSeqToFloatSeq;
    ::Test::DoubleDoubleSeq doubleSeqToDoubleSeq;
    ::Test::DoubleStringSeq doubleSeqToStringSeq;
    ::Test::StringBoolSeq stringSeqToBoolSeq;
    ::Test::StringByteSeq stringSeqToByteSeq;
    ::Test::StringShortSeq stringSeqToShortSeq;
    ::Test::StringIntSeq stringSeqToIntSeq;
    ::Test::StringLongSeq stringSeqToLongSeq;
    ::Test::StringFloatSeq stringSeqToFloatSeq;
    ::Test::StringDoubleSeq stringSeqToDoubleSeq;
    ::Test::StringStringSeq stringSeqToStringSeq;
    ::Test::StringEnumSeq stringSeqToEnumSeq;
    ::Test::StringProxySeq stringSeqToProxySeq;
    ::Test::BoolStringDict boolToStringDict;
    ::Test::LongByteDict longToByteDict;
    ::Test::LongShortDict longToShortDict;
    ::Test::LongIntDict longToIntDict;
    ::Test::LongStringDict longToStringDict;
    ::Test::DoubleFloatDict doubleToFloatDict;
    ::Test::DoubleStringDict doubleToStringDict;
    ::Test::StringBoolDict stringToBoolDict;
    ::Test::StringLongDict stringToLongDict;
    ::Test::StringDoubleDict stringToDoubleDict;
    ::Test::StringEnumDict stringToEnumDict;
    ::Ice::ObjectPtr nilObject;
    ::Ice::ObjectPtr baseObject;
    ::Test::CPtr cObject;
    ::Test::CPtr dAsCObject;
    ::Test::DPtr dObject;
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 175;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::S, S>
{
    static void write(S* __os, const ::Test::S& v)
    {
        __os->write(v.boolToString);
        __os->write(v.byteToByte);
        __os->write(v.byteToShort);
        __os->write(v.byteToInt);
        __os->write(v.byteToLong);
        __os->write(v.byteToString);
        __os->write(v.shortToByte);
        __os->write(v.shortToShort);
        __os->write(v.shortToInt);
        __os->write(v.shortToLong);
        __os->write(v.shortToString);
        __os->write(v.intToByte);
        __os->write(v.intToShort);
        __os->write(v.intToInt);
        __os->write(v.intToLong);
        __os->write(v.intToString);
        __os->write(v.longToByte);
        __os->write(v.longToShort);
        __os->write(v.longToInt);
        __os->write(v.longToLong);
        __os->write(v.longToString);
        __os->write(v.floatToFloat);
        __os->write(v.floatToDouble);
        __os->write(v.floatToString);
        __os->write(v.doubleToFloat);
        __os->write(v.doubleToDouble);
        __os->write(v.doubleToString);
        __os->write(v.stringToBool);
        __os->write(v.stringToByte);
        __os->write(v.stringToShort);
        __os->write(v.stringToInt);
        __os->write(v.stringToLong);
        __os->write(v.stringToFloat);
        __os->write(v.stringToDouble);
        __os->write(v.stringToString);
        __os->write(v.stringToEnum);
        __os->write(v.stringToProxy);
        __os->write(v.boolSeqToStringSeq);
        __os->write(v.byteSeqToByteSeq);
        __os->write(v.byteSeqToShortSeq);
        __os->write(v.byteSeqToIntSeq);
        __os->write(v.byteSeqToLongSeq);
        __os->write(v.byteSeqToStringSeq);
        __os->write(v.shortSeqToByteSeq);
        __os->write(v.shortSeqToShortSeq);
        __os->write(v.shortSeqToIntSeq);
        __os->write(v.shortSeqToLongSeq);
        __os->write(v.shortSeqToStringSeq);
        __os->write(v.intSeqToByteSeq);
        __os->write(v.intSeqToShortSeq);
        __os->write(v.intSeqToIntSeq);
        __os->write(v.intSeqToLongSeq);
        __os->write(v.intSeqToStringSeq);
        __os->write(v.longSeqToByteSeq);
        __os->write(v.longSeqToShortSeq);
        __os->write(v.longSeqToIntSeq);
        __os->write(v.longSeqToLongSeq);
        __os->write(v.longSeqToStringSeq);
        __os->write(v.floatSeqToFloatSeq);
        __os->write(v.floatSeqToDoubleSeq);
        __os->write(v.floatSeqToStringSeq);
        __os->write(v.doubleSeqToFloatSeq);
        __os->write(v.doubleSeqToDoubleSeq);
        __os->write(v.doubleSeqToStringSeq);
        __os->write(v.stringSeqToBoolSeq);
        __os->write(v.stringSeqToByteSeq);
        __os->write(v.stringSeqToShortSeq);
        __os->write(v.stringSeqToIntSeq);
        __os->write(v.stringSeqToLongSeq);
        __os->write(v.stringSeqToFloatSeq);
        __os->write(v.stringSeqToDoubleSeq);
        __os->write(v.stringSeqToStringSeq);
        __os->write(v.stringSeqToEnumSeq);
        __os->write(v.stringSeqToProxySeq);
        __os->write(v.boolToStringDict);
        __os->write(v.longToByteDict);
        __os->write(v.longToShortDict);
        __os->write(v.longToIntDict);
        __os->write(v.longToStringDict);
        __os->write(v.doubleToFloatDict);
        __os->write(v.doubleToStringDict);
        __os->write(v.stringToBoolDict);
        __os->write(v.stringToLongDict);
        __os->write(v.stringToDoubleDict);
        __os->write(v.stringToEnumDict);
        __os->write(v.nilObject);
        __os->write(v.baseObject);
        __os->write(v.cObject);
        __os->write(v.dAsCObject);
        __os->write(v.dObject);
    }
};

template<class S>
struct StreamReader< ::Test::S, S>
{
    static void read(S* __is, ::Test::S& v)
    {
        __is->read(v.boolToString);
        __is->read(v.byteToByte);
        __is->read(v.byteToShort);
        __is->read(v.byteToInt);
        __is->read(v.byteToLong);
        __is->read(v.byteToString);
        __is->read(v.shortToByte);
        __is->read(v.shortToShort);
        __is->read(v.shortToInt);
        __is->read(v.shortToLong);
        __is->read(v.shortToString);
        __is->read(v.intToByte);
        __is->read(v.intToShort);
        __is->read(v.intToInt);
        __is->read(v.intToLong);
        __is->read(v.intToString);
        __is->read(v.longToByte);
        __is->read(v.longToShort);
        __is->read(v.longToInt);
        __is->read(v.longToLong);
        __is->read(v.longToString);
        __is->read(v.floatToFloat);
        __is->read(v.floatToDouble);
        __is->read(v.floatToString);
        __is->read(v.doubleToFloat);
        __is->read(v.doubleToDouble);
        __is->read(v.doubleToString);
        __is->read(v.stringToBool);
        __is->read(v.stringToByte);
        __is->read(v.stringToShort);
        __is->read(v.stringToInt);
        __is->read(v.stringToLong);
        __is->read(v.stringToFloat);
        __is->read(v.stringToDouble);
        __is->read(v.stringToString);
        __is->read(v.stringToEnum);
        __is->read(v.stringToProxy);
        __is->read(v.boolSeqToStringSeq);
        __is->read(v.byteSeqToByteSeq);
        __is->read(v.byteSeqToShortSeq);
        __is->read(v.byteSeqToIntSeq);
        __is->read(v.byteSeqToLongSeq);
        __is->read(v.byteSeqToStringSeq);
        __is->read(v.shortSeqToByteSeq);
        __is->read(v.shortSeqToShortSeq);
        __is->read(v.shortSeqToIntSeq);
        __is->read(v.shortSeqToLongSeq);
        __is->read(v.shortSeqToStringSeq);
        __is->read(v.intSeqToByteSeq);
        __is->read(v.intSeqToShortSeq);
        __is->read(v.intSeqToIntSeq);
        __is->read(v.intSeqToLongSeq);
        __is->read(v.intSeqToStringSeq);
        __is->read(v.longSeqToByteSeq);
        __is->read(v.longSeqToShortSeq);
        __is->read(v.longSeqToIntSeq);
        __is->read(v.longSeqToLongSeq);
        __is->read(v.longSeqToStringSeq);
        __is->read(v.floatSeqToFloatSeq);
        __is->read(v.floatSeqToDoubleSeq);
        __is->read(v.floatSeqToStringSeq);
        __is->read(v.doubleSeqToFloatSeq);
        __is->read(v.doubleSeqToDoubleSeq);
        __is->read(v.doubleSeqToStringSeq);
        __is->read(v.stringSeqToBoolSeq);
        __is->read(v.stringSeqToByteSeq);
        __is->read(v.stringSeqToShortSeq);
        __is->read(v.stringSeqToIntSeq);
        __is->read(v.stringSeqToLongSeq);
        __is->read(v.stringSeqToFloatSeq);
        __is->read(v.stringSeqToDoubleSeq);
        __is->read(v.stringSeqToStringSeq);
        __is->read(v.stringSeqToEnumSeq);
        __is->read(v.stringSeqToProxySeq);
        __is->read(v.boolToStringDict);
        __is->read(v.longToByteDict);
        __is->read(v.longToShortDict);
        __is->read(v.longToIntDict);
        __is->read(v.longToStringDict);
        __is->read(v.doubleToFloatDict);
        __is->read(v.doubleToStringDict);
        __is->read(v.stringToBoolDict);
        __is->read(v.stringToLongDict);
        __is->read(v.stringToDoubleDict);
        __is->read(v.stringToEnumDict);
        __is->read(v.nilObject);
        __is->read(v.baseObject);
        __is->read(v.cObject);
        __is->read(v.dAsCObject);
        __is->read(v.dObject);
    }
};

}

namespace Test
{

}

namespace IceProxy
{

namespace Test
{

class C : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class D : virtual public ::IceProxy::Test::C
{
public:
    
    ::IceInternal::ProxyHandle<D> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_secure(bool __secure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_twoway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_oneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchOneway() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_datagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_batchDatagram() const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_compress(bool __compress) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_timeout(int __timeout) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<D> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<D*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class F : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<F> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_secure(bool __secure) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_twoway() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_oneway() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_batchOneway() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_datagram() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_batchDatagram() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_compress(bool __compress) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_timeout(int __timeout) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Test
{

class C : virtual public ::IceDelegate::Ice::Object
{
public:
};

class D : virtual public ::IceDelegate::Test::C
{
public:
};

class F : virtual public ::IceDelegate::Ice::Object
{
public:
};

}

}

namespace IceDelegateM
{

namespace Test
{

class C : virtual public ::IceDelegate::Test::C,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

class D : virtual public ::IceDelegate::Test::D,
          virtual public ::IceDelegateM::Test::C
{
public:
};

class F : virtual public ::IceDelegate::Test::F,
          virtual public ::IceDelegateM::Ice::Object
{
public:
};

}

}

namespace IceDelegateD
{

namespace Test
{

class C : virtual public ::IceDelegate::Test::C,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

class D : virtual public ::IceDelegate::Test::D,
          virtual public ::IceDelegateD::Test::C
{
public:
};

class F : virtual public ::IceDelegate::Test::F,
          virtual public ::IceDelegateD::Ice::Object
{
public:
};

}

}

namespace Test
{

class C : virtual public ::Ice::Object
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    explicit C(const ::Test::BoolStringDict& __ice_boolToStringDict) :
        boolToStringDict(__ice_boolToStringDict)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::BoolStringDict boolToStringDict;

protected:

    virtual ~C() {}

    friend class C__staticInit;
};

class C__staticInit
{
public:

    ::Test::C _init;
};

static C__staticInit _C_init;

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class D : public ::Test::C, public IceInternal::GCShared
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    D()
    {
    }

    D(const ::Test::BoolStringDict& __ice_boolToStringDict, const ::Test::StringByteSeq& __ice_stringToByteSeq, const ::Ice::ObjectPtr& __ice_obj) :
        ::Test::C(__ice_boolToStringDict)
        ,
        stringToByteSeq(__ice_stringToByteSeq),
        obj(__ice_obj)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::C::__writeImpl;
    using ::Test::C::__readImpl;
    #endif

public:

    ::Test::StringByteSeq stringToByteSeq;

    ::Ice::ObjectPtr obj;

protected:

    virtual ~D() {}
};

inline bool operator==(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const D& l, const D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class F : virtual public ::Ice::Object
{
public:

    typedef FPrx ProxyType;
    typedef FPtr PointerType;

    F()
    {
    }

    explicit F(const ::Test::StringEnumSeq& __ice_stringToEnumSeq) :
        stringToEnumSeq(__ice_stringToEnumSeq)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::StringEnumSeq stringToEnumSeq;

protected:

    virtual ~F() {}
};

inline bool operator==(const F& l, const F& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const F& l, const F& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Test
{

}

#endif
