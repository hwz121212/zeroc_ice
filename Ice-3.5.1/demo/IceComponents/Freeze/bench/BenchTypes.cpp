// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `BenchTypes.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//


// Freeze types in this file:
// name="Demo::IntIntMap", key="int", value="int"
// name="Demo::Struct1Struct2Map", key="Demo::Struct1", value="Demo::Struct2"
// name="Demo::Struct1Class1Map", key="Demo::Struct1", value="Demo::Class1"
// name="Demo::Struct1ObjectMap", key="Demo::Struct1", value="Object"
// name="Demo::IndexedIntIntMap", key="int", value="int"
// name="Demo::IndexedStruct1Struct2Map", key="Demo::Struct1", value="Demo::Struct2"
// name="Demo::IndexedStruct1Class1Map", key="Demo::Struct1", value="Demo::Class1"

#include <Ice/BasicStream.h>
#include <IceUtil/StringUtil.h>
#include <BenchTypes.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

void
Demo::IntIntMapKeyCodec::write(::Ice::Int v, Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.write(v);
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IntIntMapKeyCodec::read(::Ice::Int& v, const Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.read(v);
}

namespace
{
    const ::std::string __Demo__IntIntMapKeyCodec_typeId = "int";
}

const ::std::string&
Demo::IntIntMapKeyCodec::typeId()
{
    return __Demo__IntIntMapKeyCodec_typeId;
}

void
Demo::IntIntMapValueCodec::write(::Ice::Int v, Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.startWriteEncaps();
    stream.write(v);
    stream.endWriteEncaps();
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IntIntMapValueCodec::read(::Ice::Int& v, const Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.startReadEncaps();
    stream.read(v);
    stream.endReadEncaps();
}

namespace
{
    const ::std::string __Demo__IntIntMapValueCodec_typeId = "int";
}

const ::std::string&
Demo::IntIntMapValueCodec::typeId()
{
    return __Demo__IntIntMapValueCodec_typeId;
}

void
Demo::Struct1Struct2MapKeyCodec::write(const ::Demo::Struct1& v, Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.write(v);
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::Struct1Struct2MapKeyCodec::read(::Demo::Struct1& v, const Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.read(v);
}

namespace
{
    const ::std::string __Demo__Struct1Struct2MapKeyCodec_typeId = "::Demo::Struct1";
}

const ::std::string&
Demo::Struct1Struct2MapKeyCodec::typeId()
{
    return __Demo__Struct1Struct2MapKeyCodec_typeId;
}

void
Demo::Struct1Struct2MapValueCodec::write(const ::Demo::Struct2& v, Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.startWriteEncaps();
    stream.write(v);
    stream.endWriteEncaps();
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::Struct1Struct2MapValueCodec::read(::Demo::Struct2& v, const Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.startReadEncaps();
    stream.read(v);
    stream.endReadEncaps();
}

namespace
{
    const ::std::string __Demo__Struct1Struct2MapValueCodec_typeId = "::Demo::Struct2";
}

const ::std::string&
Demo::Struct1Struct2MapValueCodec::typeId()
{
    return __Demo__Struct1Struct2MapValueCodec_typeId;
}

void
Demo::Struct1Class1MapKeyCodec::write(const ::Demo::Struct1& v, Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.write(v);
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::Struct1Class1MapKeyCodec::read(::Demo::Struct1& v, const Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.read(v);
}

namespace
{
    const ::std::string __Demo__Struct1Class1MapKeyCodec_typeId = "::Demo::Struct1";
}

const ::std::string&
Demo::Struct1Class1MapKeyCodec::typeId()
{
    return __Demo__Struct1Class1MapKeyCodec_typeId;
}

void
Demo::Struct1Class1MapValueCodec::write(const ::Demo::Class1Ptr& v, Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.startWriteEncaps();
    stream.write(v);
    stream.writePendingObjects();
    stream.endWriteEncaps();
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::Struct1Class1MapValueCodec::read(::Demo::Class1Ptr& v, const Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.sliceObjects(false);
    stream.startReadEncaps();
    stream.read(v);
    stream.readPendingObjects();
    stream.endReadEncaps();
}

namespace
{
    const ::std::string __Demo__Struct1Class1MapValueCodec_typeId = "::Demo::Class1";
}

const ::std::string&
Demo::Struct1Class1MapValueCodec::typeId()
{
    return __Demo__Struct1Class1MapValueCodec_typeId;
}

void
Demo::Struct1ObjectMapKeyCodec::write(const ::Demo::Struct1& v, Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.write(v);
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::Struct1ObjectMapKeyCodec::read(::Demo::Struct1& v, const Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.read(v);
}

namespace
{
    const ::std::string __Demo__Struct1ObjectMapKeyCodec_typeId = "::Demo::Struct1";
}

const ::std::string&
Demo::Struct1ObjectMapKeyCodec::typeId()
{
    return __Demo__Struct1ObjectMapKeyCodec_typeId;
}

void
Demo::Struct1ObjectMapValueCodec::write(const ::Ice::ObjectPtr& v, Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.startWriteEncaps();
    stream.write(v);
    stream.writePendingObjects();
    stream.endWriteEncaps();
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::Struct1ObjectMapValueCodec::read(::Ice::ObjectPtr& v, const Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.sliceObjects(false);
    stream.startReadEncaps();
    stream.read(v);
    stream.readPendingObjects();
    stream.endReadEncaps();
}

namespace
{
    const ::std::string __Demo__Struct1ObjectMapValueCodec_typeId = "::Ice::Object";
}

const ::std::string&
Demo::Struct1ObjectMapValueCodec::typeId()
{
    return __Demo__Struct1ObjectMapValueCodec_typeId;
}

void
Demo::IndexedIntIntMapKeyCodec::write(::Ice::Int v, Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.write(v);
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IndexedIntIntMapKeyCodec::read(::Ice::Int& v, const Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.read(v);
}

namespace
{
    const ::std::string __Demo__IndexedIntIntMapKeyCodec_typeId = "int";
}

const ::std::string&
Demo::IndexedIntIntMapKeyCodec::typeId()
{
    return __Demo__IndexedIntIntMapKeyCodec_typeId;
}

void
Demo::IndexedIntIntMapValueCodec::write(::Ice::Int v, Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.startWriteEncaps();
    stream.write(v);
    stream.endWriteEncaps();
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IndexedIntIntMapValueCodec::read(::Ice::Int& v, const Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.startReadEncaps();
    stream.read(v);
    stream.endReadEncaps();
}

namespace
{
    const ::std::string __Demo__IndexedIntIntMapValueCodec_typeId = "int";
}

const ::std::string&
Demo::IndexedIntIntMapValueCodec::typeId()
{
    return __Demo__IndexedIntIntMapValueCodec_typeId;
}

Demo::IndexedIntIntMap::ValueIndex::ValueIndex(const std::string& __name, const Freeze::IceEncodingCompare& __compare)
    : Freeze::MapIndex< ::Ice::Int, ValueIndex, Freeze::IceEncodingCompare >(__name, __compare)
{
}

void
Demo::IndexedIntIntMap::ValueIndex::marshalKey(const Freeze::Value& __v, Freeze::Key& __k) const
{
    __k = __v;
}

void
Demo::IndexedIntIntMap::ValueIndex::write(::Ice::Int __index, Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    Demo::IndexedIntIntMapValueCodec::write(__index, __bytes, __communicator, __encoding);
}

void
Demo::IndexedIntIntMap::ValueIndex::read(::Ice::Int& __index, const Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    Demo::IndexedIntIntMapValueCodec::read(__index, __bytes, __communicator, __encoding);
}

Demo::IndexedIntIntMap::IndexedIntIntMap(const Freeze::ConnectionPtr& __connection, const std::string& __dbName ,bool __createDb, const Freeze::IceEncodingCompare& __compare)
    : Freeze::Map< ::Ice::Int, ::Ice::Int, IndexedIntIntMapKeyCodec, IndexedIntIntMapValueCodec, Freeze::IceEncodingCompare >(__connection->getCommunicator(), __connection->getEncoding())
{
    Freeze::KeyCompareBasePtr __keyCompare = new Freeze::KeyCompare< ::Ice::Int, IndexedIntIntMapKeyCodec, Freeze::IceEncodingCompare >(__compare, _communicator, _encoding);
    std::vector<Freeze::MapIndexBasePtr> __indices;
    __indices.push_back(new ValueIndex("index"));
    _helper.reset(Freeze::MapHelper::create(__connection, __dbName, Demo::IndexedIntIntMapKeyCodec::typeId(), Demo::IndexedIntIntMapValueCodec::typeId(), __keyCompare, __indices, __createDb));
}

void
Demo::IndexedIntIntMap::recreate(const Freeze::ConnectionPtr& __connection, const std::string& __dbName , const Freeze::IceEncodingCompare& __compare)
{
    Freeze::KeyCompareBasePtr __keyCompare = new Freeze::KeyCompare< ::Ice::Int, IndexedIntIntMapKeyCodec, Freeze::IceEncodingCompare >(__compare, __connection->getCommunicator(), __connection->getEncoding());
    std::vector<Freeze::MapIndexBasePtr> __indices;
    __indices.push_back(new ValueIndex("index"));
    Freeze::MapHelper::recreate(__connection, __dbName, Demo::IndexedIntIntMapKeyCodec::typeId(), Demo::IndexedIntIntMapValueCodec::typeId(), __keyCompare, __indices);
}

Demo::IndexedIntIntMap::iterator
Demo::IndexedIntIntMap::findByValue(::Ice::Int __index, bool __onlyDups)
{
    Freeze::Key __bytes;
    ValueIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("index")->untypedFind(__bytes, false, __onlyDups), _communicator, _encoding);
}

Demo::IndexedIntIntMap::const_iterator
Demo::IndexedIntIntMap::findByValue(::Ice::Int __index, bool __onlyDups) const
{
    Freeze::Key __bytes;
    ValueIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("index")->untypedFind(__bytes, true, __onlyDups), _communicator, _encoding);
}

Demo::IndexedIntIntMap::iterator
Demo::IndexedIntIntMap::beginForValue()
{
    return iterator(_helper->index("index")->begin(false), _communicator, _encoding);
}

Demo::IndexedIntIntMap::const_iterator
Demo::IndexedIntIntMap::beginForValue() const
{
    return const_iterator(_helper->index("index")->begin(true), _communicator, _encoding);
}

Demo::IndexedIntIntMap::iterator
Demo::IndexedIntIntMap::endForValue()
{
    return iterator();
}

Demo::IndexedIntIntMap::const_iterator
Demo::IndexedIntIntMap::endForValue() const
{
    return const_iterator();
}

Demo::IndexedIntIntMap::iterator
Demo::IndexedIntIntMap::lowerBoundForValue(::Ice::Int __index)
{
    Freeze::Key __bytes;
    ValueIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("index")->untypedLowerBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedIntIntMap::const_iterator
Demo::IndexedIntIntMap::lowerBoundForValue(::Ice::Int __index) const
{
    Freeze::Key __bytes;
    ValueIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("index")->untypedLowerBound(__bytes, true), _communicator, _encoding);
}

Demo::IndexedIntIntMap::iterator
Demo::IndexedIntIntMap::upperBoundForValue(::Ice::Int __index)
{
    Freeze::Key __bytes;
    ValueIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("index")->untypedUpperBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedIntIntMap::const_iterator
Demo::IndexedIntIntMap::upperBoundForValue(::Ice::Int __index) const
{
    Freeze::Key __bytes;
    ValueIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("index")->untypedUpperBound(__bytes, true), _communicator, _encoding);
}

std::pair<Demo::IndexedIntIntMap::iterator, Demo::IndexedIntIntMap::iterator>
Demo::IndexedIntIntMap::equalRangeForValue(::Ice::Int __index)
{
    return std::make_pair(lowerBoundForValue(__index), upperBoundForValue(__index));
}

std::pair<Demo::IndexedIntIntMap::const_iterator, Demo::IndexedIntIntMap::const_iterator>
Demo::IndexedIntIntMap::equalRangeForValue(::Ice::Int __index) const
{
    return std::make_pair(lowerBoundForValue(__index), upperBoundForValue(__index));
}

int
Demo::IndexedIntIntMap::valueCount(::Ice::Int __index) const
{
    Freeze::Key __bytes;
    ValueIndex::write(__index, __bytes, _communicator, _encoding);
    return _helper->index("index")->untypedCount(__bytes);
}

void
Demo::IndexedStruct1Struct2MapKeyCodec::write(const ::Demo::Struct1& v, Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.write(v);
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IndexedStruct1Struct2MapKeyCodec::read(::Demo::Struct1& v, const Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.read(v);
}

namespace
{
    const ::std::string __Demo__IndexedStruct1Struct2MapKeyCodec_typeId = "::Demo::Struct1";
}

const ::std::string&
Demo::IndexedStruct1Struct2MapKeyCodec::typeId()
{
    return __Demo__IndexedStruct1Struct2MapKeyCodec_typeId;
}

void
Demo::IndexedStruct1Struct2MapValueCodec::write(const ::Demo::Struct2& v, Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.startWriteEncaps();
    stream.write(v);
    stream.endWriteEncaps();
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IndexedStruct1Struct2MapValueCodec::read(::Demo::Struct2& v, const Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.startReadEncaps();
    stream.read(v);
    stream.endReadEncaps();
}

namespace
{
    const ::std::string __Demo__IndexedStruct1Struct2MapValueCodec_typeId = "::Demo::Struct2";
}

const ::std::string&
Demo::IndexedStruct1Struct2MapValueCodec::typeId()
{
    return __Demo__IndexedStruct1Struct2MapValueCodec_typeId;
}

Demo::IndexedStruct1Struct2Map::SIndex::SIndex(const std::string& __name, const Freeze::IceEncodingCompare& __compare)
    : Freeze::MapIndex< ::std::string, SIndex, Freeze::IceEncodingCompare >(__name, __compare)
{
}

void
Demo::IndexedStruct1Struct2Map::SIndex::marshalKey(const Freeze::Value& __v, Freeze::Key& __k) const
{
    ::Demo::Struct2 __x;
    Demo::IndexedStruct1Struct2MapValueCodec::read(__x, __v, _communicator, _encoding);
    write(__x.s, __k, _communicator, _encoding);
}

void
Demo::IndexedStruct1Struct2Map::SIndex::write(const ::std::string& __index, Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    IceInternal::InstancePtr __instance = IceInternal::getInstance(__communicator);
    IceInternal::BasicStream __stream(__instance.get(), __encoding, true);
    ::std::string __lowerCaseIndex = IceUtilInternal::toLower(__index);
    __stream.write(__lowerCaseIndex);
    ::std::vector<Ice::Byte>(__stream.b.begin(), __stream.b.end()).swap(__bytes);
}

void
Demo::IndexedStruct1Struct2Map::SIndex::read(::std::string& __index, const Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    IceInternal::InstancePtr __instance = IceInternal::getInstance(__communicator);
    IceInternal::BasicStream __stream(__instance.get(), __encoding, &__bytes[0], &__bytes[0] + __bytes.size());
    __stream.read(__index);
}

Demo::IndexedStruct1Struct2Map::S1Index::S1Index(const std::string& __name, const Freeze::IceEncodingCompare& __compare)
    : Freeze::MapIndex< ::Demo::Struct1, S1Index, Freeze::IceEncodingCompare >(__name, __compare)
{
}

void
Demo::IndexedStruct1Struct2Map::S1Index::marshalKey(const Freeze::Value& __v, Freeze::Key& __k) const
{
    ::Demo::Struct2 __x;
    Demo::IndexedStruct1Struct2MapValueCodec::read(__x, __v, _communicator, _encoding);
    write(__x.s1, __k, _communicator, _encoding);
}

void
Demo::IndexedStruct1Struct2Map::S1Index::write(const ::Demo::Struct1& __index, Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    IceInternal::InstancePtr __instance = IceInternal::getInstance(__communicator);
    IceInternal::BasicStream __stream(__instance.get(), __encoding, true);
    __stream.write(__index);
    ::std::vector<Ice::Byte>(__stream.b.begin(), __stream.b.end()).swap(__bytes);
}

void
Demo::IndexedStruct1Struct2Map::S1Index::read(::Demo::Struct1& __index, const Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    IceInternal::InstancePtr __instance = IceInternal::getInstance(__communicator);
    IceInternal::BasicStream __stream(__instance.get(), __encoding, &__bytes[0], &__bytes[0] + __bytes.size());
    __stream.read(__index);
}

Demo::IndexedStruct1Struct2Map::IndexedStruct1Struct2Map(const Freeze::ConnectionPtr& __connection, const std::string& __dbName ,bool __createDb, const Freeze::IceEncodingCompare& __compare)
    : Freeze::Map< ::Demo::Struct1, ::Demo::Struct2, IndexedStruct1Struct2MapKeyCodec, IndexedStruct1Struct2MapValueCodec, Freeze::IceEncodingCompare >(__connection->getCommunicator(), __connection->getEncoding())
{
    Freeze::KeyCompareBasePtr __keyCompare = new Freeze::KeyCompare< ::Demo::Struct1, IndexedStruct1Struct2MapKeyCodec, Freeze::IceEncodingCompare >(__compare, _communicator, _encoding);
    std::vector<Freeze::MapIndexBasePtr> __indices;
    __indices.push_back(new SIndex("s"));
    __indices.push_back(new S1Index("s1"));
    _helper.reset(Freeze::MapHelper::create(__connection, __dbName, Demo::IndexedStruct1Struct2MapKeyCodec::typeId(), Demo::IndexedStruct1Struct2MapValueCodec::typeId(), __keyCompare, __indices, __createDb));
}

void
Demo::IndexedStruct1Struct2Map::recreate(const Freeze::ConnectionPtr& __connection, const std::string& __dbName , const Freeze::IceEncodingCompare& __compare)
{
    Freeze::KeyCompareBasePtr __keyCompare = new Freeze::KeyCompare< ::Demo::Struct1, IndexedStruct1Struct2MapKeyCodec, Freeze::IceEncodingCompare >(__compare, __connection->getCommunicator(), __connection->getEncoding());
    std::vector<Freeze::MapIndexBasePtr> __indices;
    __indices.push_back(new SIndex("s"));
    __indices.push_back(new S1Index("s1"));
    Freeze::MapHelper::recreate(__connection, __dbName, Demo::IndexedStruct1Struct2MapKeyCodec::typeId(), Demo::IndexedStruct1Struct2MapValueCodec::typeId(), __keyCompare, __indices);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::findByS(const ::std::string& __index, bool __onlyDups)
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s")->untypedFind(__bytes, false, __onlyDups), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::findByS(const ::std::string& __index, bool __onlyDups) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s")->untypedFind(__bytes, true, __onlyDups), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::beginForS()
{
    return iterator(_helper->index("s")->begin(false), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::beginForS() const
{
    return const_iterator(_helper->index("s")->begin(true), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::endForS()
{
    return iterator();
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::endForS() const
{
    return const_iterator();
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::lowerBoundForS(const ::std::string& __index)
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s")->untypedLowerBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::lowerBoundForS(const ::std::string& __index) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s")->untypedLowerBound(__bytes, true), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::upperBoundForS(const ::std::string& __index)
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s")->untypedUpperBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::upperBoundForS(const ::std::string& __index) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s")->untypedUpperBound(__bytes, true), _communicator, _encoding);
}

std::pair<Demo::IndexedStruct1Struct2Map::iterator, Demo::IndexedStruct1Struct2Map::iterator>
Demo::IndexedStruct1Struct2Map::equalRangeForS(const ::std::string& __index)
{
    return std::make_pair(lowerBoundForS(__index), upperBoundForS(__index));
}

std::pair<Demo::IndexedStruct1Struct2Map::const_iterator, Demo::IndexedStruct1Struct2Map::const_iterator>
Demo::IndexedStruct1Struct2Map::equalRangeForS(const ::std::string& __index) const
{
    return std::make_pair(lowerBoundForS(__index), upperBoundForS(__index));
}

int
Demo::IndexedStruct1Struct2Map::sCount(const ::std::string& __index) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return _helper->index("s")->untypedCount(__bytes);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::findByS1(const ::Demo::Struct1& __index, bool __onlyDups)
{
    Freeze::Key __bytes;
    S1Index::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s1")->untypedFind(__bytes, false, __onlyDups), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::findByS1(const ::Demo::Struct1& __index, bool __onlyDups) const
{
    Freeze::Key __bytes;
    S1Index::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s1")->untypedFind(__bytes, true, __onlyDups), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::beginForS1()
{
    return iterator(_helper->index("s1")->begin(false), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::beginForS1() const
{
    return const_iterator(_helper->index("s1")->begin(true), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::endForS1()
{
    return iterator();
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::endForS1() const
{
    return const_iterator();
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::lowerBoundForS1(const ::Demo::Struct1& __index)
{
    Freeze::Key __bytes;
    S1Index::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s1")->untypedLowerBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::lowerBoundForS1(const ::Demo::Struct1& __index) const
{
    Freeze::Key __bytes;
    S1Index::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s1")->untypedLowerBound(__bytes, true), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::iterator
Demo::IndexedStruct1Struct2Map::upperBoundForS1(const ::Demo::Struct1& __index)
{
    Freeze::Key __bytes;
    S1Index::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s1")->untypedUpperBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedStruct1Struct2Map::const_iterator
Demo::IndexedStruct1Struct2Map::upperBoundForS1(const ::Demo::Struct1& __index) const
{
    Freeze::Key __bytes;
    S1Index::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s1")->untypedUpperBound(__bytes, true), _communicator, _encoding);
}

std::pair<Demo::IndexedStruct1Struct2Map::iterator, Demo::IndexedStruct1Struct2Map::iterator>
Demo::IndexedStruct1Struct2Map::equalRangeForS1(const ::Demo::Struct1& __index)
{
    return std::make_pair(lowerBoundForS1(__index), upperBoundForS1(__index));
}

std::pair<Demo::IndexedStruct1Struct2Map::const_iterator, Demo::IndexedStruct1Struct2Map::const_iterator>
Demo::IndexedStruct1Struct2Map::equalRangeForS1(const ::Demo::Struct1& __index) const
{
    return std::make_pair(lowerBoundForS1(__index), upperBoundForS1(__index));
}

int
Demo::IndexedStruct1Struct2Map::s1Count(const ::Demo::Struct1& __index) const
{
    Freeze::Key __bytes;
    S1Index::write(__index, __bytes, _communicator, _encoding);
    return _helper->index("s1")->untypedCount(__bytes);
}

void
Demo::IndexedStruct1Class1MapKeyCodec::write(const ::Demo::Struct1& v, Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.write(v);
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IndexedStruct1Class1MapKeyCodec::read(::Demo::Struct1& v, const Freeze::Key& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.read(v);
}

namespace
{
    const ::std::string __Demo__IndexedStruct1Class1MapKeyCodec_typeId = "::Demo::Struct1";
}

const ::std::string&
Demo::IndexedStruct1Class1MapKeyCodec::typeId()
{
    return __Demo__IndexedStruct1Class1MapKeyCodec_typeId;
}

void
Demo::IndexedStruct1Class1MapValueCodec::write(const ::Demo::Class1Ptr& v, Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, true);
    stream.startWriteEncaps();
    stream.write(v);
    stream.writePendingObjects();
    stream.endWriteEncaps();
    ::std::vector<Ice::Byte>(stream.b.begin(), stream.b.end()).swap(bytes);
}

void
Demo::IndexedStruct1Class1MapValueCodec::read(::Demo::Class1Ptr& v, const Freeze::Value& bytes, const ::Ice::CommunicatorPtr& communicator, const Ice::EncodingVersion& encoding)
{
    IceInternal::InstancePtr instance = IceInternal::getInstance(communicator);
    IceInternal::BasicStream stream(instance.get(), encoding, &bytes[0], &bytes[0] + bytes.size());
    stream.sliceObjects(false);
    stream.startReadEncaps();
    stream.read(v);
    stream.readPendingObjects();
    stream.endReadEncaps();
}

namespace
{
    const ::std::string __Demo__IndexedStruct1Class1MapValueCodec_typeId = "::Demo::Class1";
}

const ::std::string&
Demo::IndexedStruct1Class1MapValueCodec::typeId()
{
    return __Demo__IndexedStruct1Class1MapValueCodec_typeId;
}

Demo::IndexedStruct1Class1Map::SIndex::SIndex(const std::string& __name, const Freeze::IceEncodingCompare& __compare)
    : Freeze::MapIndex< ::std::string, SIndex, Freeze::IceEncodingCompare >(__name, __compare)
{
}

void
Demo::IndexedStruct1Class1Map::SIndex::marshalKey(const Freeze::Value& __v, Freeze::Key& __k) const
{
    ::Demo::Class1Ptr __x;
    Demo::IndexedStruct1Class1MapValueCodec::read(__x, __v, _communicator, _encoding);
    write(__x->s, __k, _communicator, _encoding);
}

void
Demo::IndexedStruct1Class1Map::SIndex::write(const ::std::string& __index, Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    IceInternal::InstancePtr __instance = IceInternal::getInstance(__communicator);
    IceInternal::BasicStream __stream(__instance.get(), __encoding, true);
    __stream.write(__index);
    ::std::vector<Ice::Byte>(__stream.b.begin(), __stream.b.end()).swap(__bytes);
}

void
Demo::IndexedStruct1Class1Map::SIndex::read(::std::string& __index, const Freeze::Key& __bytes, const Ice::CommunicatorPtr& __communicator, const Ice::EncodingVersion& __encoding)
{
    IceInternal::InstancePtr __instance = IceInternal::getInstance(__communicator);
    IceInternal::BasicStream __stream(__instance.get(), __encoding, &__bytes[0], &__bytes[0] + __bytes.size());
    __stream.read(__index);
}

Demo::IndexedStruct1Class1Map::IndexedStruct1Class1Map(const Freeze::ConnectionPtr& __connection, const std::string& __dbName ,bool __createDb, const Freeze::IceEncodingCompare& __compare)
    : Freeze::Map< ::Demo::Struct1, ::Demo::Class1Ptr, IndexedStruct1Class1MapKeyCodec, IndexedStruct1Class1MapValueCodec, Freeze::IceEncodingCompare >(__connection->getCommunicator(), __connection->getEncoding())
{
    Freeze::KeyCompareBasePtr __keyCompare = new Freeze::KeyCompare< ::Demo::Struct1, IndexedStruct1Class1MapKeyCodec, Freeze::IceEncodingCompare >(__compare, _communicator, _encoding);
    std::vector<Freeze::MapIndexBasePtr> __indices;
    __indices.push_back(new SIndex("s"));
    _helper.reset(Freeze::MapHelper::create(__connection, __dbName, Demo::IndexedStruct1Class1MapKeyCodec::typeId(), Demo::IndexedStruct1Class1MapValueCodec::typeId(), __keyCompare, __indices, __createDb));
}

void
Demo::IndexedStruct1Class1Map::recreate(const Freeze::ConnectionPtr& __connection, const std::string& __dbName , const Freeze::IceEncodingCompare& __compare)
{
    Freeze::KeyCompareBasePtr __keyCompare = new Freeze::KeyCompare< ::Demo::Struct1, IndexedStruct1Class1MapKeyCodec, Freeze::IceEncodingCompare >(__compare, __connection->getCommunicator(), __connection->getEncoding());
    std::vector<Freeze::MapIndexBasePtr> __indices;
    __indices.push_back(new SIndex("s"));
    Freeze::MapHelper::recreate(__connection, __dbName, Demo::IndexedStruct1Class1MapKeyCodec::typeId(), Demo::IndexedStruct1Class1MapValueCodec::typeId(), __keyCompare, __indices);
}

Demo::IndexedStruct1Class1Map::iterator
Demo::IndexedStruct1Class1Map::findByS(const ::std::string& __index, bool __onlyDups)
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s")->untypedFind(__bytes, false, __onlyDups), _communicator, _encoding);
}

Demo::IndexedStruct1Class1Map::const_iterator
Demo::IndexedStruct1Class1Map::findByS(const ::std::string& __index, bool __onlyDups) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s")->untypedFind(__bytes, true, __onlyDups), _communicator, _encoding);
}

Demo::IndexedStruct1Class1Map::iterator
Demo::IndexedStruct1Class1Map::beginForS()
{
    return iterator(_helper->index("s")->begin(false), _communicator, _encoding);
}

Demo::IndexedStruct1Class1Map::const_iterator
Demo::IndexedStruct1Class1Map::beginForS() const
{
    return const_iterator(_helper->index("s")->begin(true), _communicator, _encoding);
}

Demo::IndexedStruct1Class1Map::iterator
Demo::IndexedStruct1Class1Map::endForS()
{
    return iterator();
}

Demo::IndexedStruct1Class1Map::const_iterator
Demo::IndexedStruct1Class1Map::endForS() const
{
    return const_iterator();
}

Demo::IndexedStruct1Class1Map::iterator
Demo::IndexedStruct1Class1Map::lowerBoundForS(const ::std::string& __index)
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s")->untypedLowerBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedStruct1Class1Map::const_iterator
Demo::IndexedStruct1Class1Map::lowerBoundForS(const ::std::string& __index) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s")->untypedLowerBound(__bytes, true), _communicator, _encoding);
}

Demo::IndexedStruct1Class1Map::iterator
Demo::IndexedStruct1Class1Map::upperBoundForS(const ::std::string& __index)
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return iterator(_helper->index("s")->untypedUpperBound(__bytes, false), _communicator, _encoding);
}

Demo::IndexedStruct1Class1Map::const_iterator
Demo::IndexedStruct1Class1Map::upperBoundForS(const ::std::string& __index) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return const_iterator(_helper->index("s")->untypedUpperBound(__bytes, true), _communicator, _encoding);
}

std::pair<Demo::IndexedStruct1Class1Map::iterator, Demo::IndexedStruct1Class1Map::iterator>
Demo::IndexedStruct1Class1Map::equalRangeForS(const ::std::string& __index)
{
    return std::make_pair(lowerBoundForS(__index), upperBoundForS(__index));
}

std::pair<Demo::IndexedStruct1Class1Map::const_iterator, Demo::IndexedStruct1Class1Map::const_iterator>
Demo::IndexedStruct1Class1Map::equalRangeForS(const ::std::string& __index) const
{
    return std::make_pair(lowerBoundForS(__index), upperBoundForS(__index));
}

int
Demo::IndexedStruct1Class1Map::sCount(const ::std::string& __index) const
{
    Freeze::Key __bytes;
    SIndex::write(__index, __bytes, _communicator, _encoding);
    return _helper->index("s")->untypedCount(__bytes);
}
